<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LDQ的博客</title>
  <subtitle>前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ldqblog.me/"/>
  <updated>2017-10-12T09:14:53.000Z</updated>
  <id>http://ldqblog.me/</id>
  
  <author>
    <name>ldq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript 入门</title>
    <link href="http://ldqblog.me/2017/08/12/TypeScript-%E5%85%A5%E9%97%A8/"/>
    <id>http://ldqblog.me/2017/08/12/TypeScript-入门/</id>
    <published>2017-08-12T07:13:38.000Z</published>
    <updated>2017-10-12T09:14:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-入门"><a href="#TypeScript-入门" class="headerlink" title="TypeScript 入门"></a>TypeScript 入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 是一门弱类型语言，没有类型检测，这让 JavaScript 很灵活，但也更容易出错</p>
<blockquote>
<p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。  </p>
</blockquote>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><blockquote>
<p>官网<br><a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a><br>中文文档<br><a href="https://www.tslang.cn/index.html" target="_blank" rel="external">tslang</a><br>查看编译后的结果<br><a href="http://www.typescriptlang.org/play/index.html" target="_blank" rel="external">typescriptlang</a></p>
</blockquote>
<h2 id="很多项目开始使用-TypeScript"><a href="#很多项目开始使用-TypeScript" class="headerlink" title="很多项目开始使用 TypeScript"></a>很多项目开始使用 TypeScript</h2><blockquote>
<p>Angular</p>
<div class="github-widget" data-repo="angular/angular"></div>

<p>VSCode</p>
<div class="github-widget" data-repo="Microsoft/vscode"></div>

<p>RxJS</p>
<div class="github-widget" data-repo="Reactive-Extensions/RxJS"></div>

</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install -g typescript
</code></pre><h3 id="安装完后运行-tsc-v-查看是否正确安装"><a href="#安装完后运行-tsc-v-查看是否正确安装" class="headerlink" title="安装完后运行 tsc -v 查看是否正确安装"></a>安装完后运行 tsc -v 查看是否正确安装</h3><pre><code>tsc -v
Version 2.4.2
</code></pre><h3 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h3><p>tsc -h 或 tsc –help 查看帮助</p>
<pre><code>$ tsc -h
Version 2.4.2
Syntax:  tsc [options] [file ...]

Examples: tsc hello.ts
          tsc --outFile file.js file.ts
          tsc @args.txt
Options:
...
</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>生成默认的配置文件 tsconfig.json</p>
<pre><code>tsc init
</code></pre><ul>
<li>配置 es6</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-084ac9734f4aceab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="支持-TypeScript-的文本编辑器和-IDE"><a href="#支持-TypeScript-的文本编辑器和-IDE" class="headerlink" title="支持 TypeScript 的文本编辑器和 IDE"></a>支持 TypeScript 的文本编辑器和 IDE</h3><p>通过本身或插件支持 TypeScript 的语法、智能提示、纠错等</p>
<ul>
<li>VSCode 微软开发的轻量级编辑器，内置支持 TypeScript</li>
<li>Sublime Text 有相关插件</li>
<li>WebStorm 新版内置支持 TypeScript</li>
<li>其他包括 Vim，Atom，Emacs 等</li>
</ul>
<h3 id="将-TypeScrip-编译成-JavaScript"><a href="#将-TypeScrip-编译成-JavaScript" class="headerlink" title="将 TypeScrip 编译成 JavaScript"></a>将 TypeScrip 编译成 JavaScript</h3><p>TypeScript 的文件类型是. ts 文件或 JSX 中的. tsx 文件，不能直接运行在浏览器中，需要编译成. js 文件</p>
<p>方法：</p>
<ol>
<li><p>用命令行工具进行编译</p>
<pre><code>
Syntax:  tsc [options] [file ...]

Examples: tsc hello.ts

        tsc --outFile file.js file.ts

        tsc @args.txt
</code></pre><p>最后一个的作用是从一个文件中插入命令行选项和文件</p>
<pre><code>
@&lt;file&gt;    Insert command line options and files from a file.
</code></pre></li>
<li><p>在 VSCode 或其他文本编辑器和 IDE 上操作</p>
</li>
<li><p>使用自动化构建工具，如 gulp， webpack 等</p>
</li>
</ol>
<h3 id="介绍一下第一种方法"><a href="#介绍一下第一种方法" class="headerlink" title="介绍一下第一种方法"></a>介绍一下第一种方法</h3><p>下面的命令行把 TypeScript 文件 main.ts 编译为 JavaScript 版本的 main.js。如果 main.js 已经存在的话会被覆盖。</p>
<pre><code>    tsc main.ts
</code></pre><p>可以同时编译多个文件</p>
<pre><code>tsc main.ts other.ts

tsc *.ts
</code></pre><p>还可以通过 –watch 或 - w 来自动编译 (修改后能自动转成. js 文件)</p>
<pre><code>tsc main.ts --watch
</code></pre><h3 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h3><p>TypeScript 可以声明变量类型，这样编译器就可以确保赋值时不会产生类型错误<br>如果省略了类型声明，TypeScript 将会从代码中自动推测出正确的类型。</p>
<p>在变量，函数声明时可以定义自己的类型</p>
<pre><code>var burger: string = &#39;hamburger&#39;,    // String 
    calories: number = 300,          // Numeric
    tasty: boolean = true;            // Boolean

function speak(food: string, energy: number): void {
  console.log(&quot;Our&quot; + food + &quot;has&quot; + energy + &quot;calories.&quot;);
}

speak(burger, calories);
</code></pre><p>编译后变量声明都会被移除</p>
<pre><code>var burger = &#39;hamburger&#39;,
    calories = 300, 
    tasty = true; 

function speak(food, energy) {
    console.log(&quot;Our&quot; + food + &quot;has&quot; + energy + &quot;calories.&quot;);
}

speak(burger, calories);
</code></pre><p>如果输入的类型有错，TypeScript 会有代码警告<br>但还是会转成 js 文件</p>
<p>ts 文件</p>
<pre><code>var carNum: Number = &#39;10&#39;
</code></pre><pre><code>$ tsc err.ts --watch
err.ts(1,5): error TS2322: Type &#39;&quot;10&quot;&#39; is not assignable to type &#39;Number&#39;.
10:36:46 - Compilation complete. Watching for file changes.
</code></pre><p>js 文件</p>
<pre><code>var carNum = &#39;10&#39;;
</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>Number ( 数值 ) - 包括整型，浮点型等</li>
</ul>
<pre><code>let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
</code></pre><ul>
<li>String （字符串）- 包括单双引号的字符串</li>
</ul>
<pre><code>let color: string = &quot;blue&quot;;
color = &#39;red&#39;;
let sentence: string = `Hello, my name is ${ fullName }.
I&#39;ll be ${ age + 1 } years old next month.`;
</code></pre><ul>
<li>Boolean （布尔）- true ,false, 不可用其他类型如数字, 空字符串，否则会报错 </li>
</ul>
<pre><code>let isDone: boolean = false
</code></pre><ul>
<li>Array （数组）- 有两种语法：my_arr: number[ ] 或者 my_arr: Array<number></number></li>
</ul>
<pre><code>let list: number[] = [1, 2, 3]

let list: Array&lt;number&gt; = [1, 2, 3]
</code></pre><ul>
<li>Tuple ( 元组 ) - 数组中包含不同的类型，有顺序</li>
</ul>
<pre><code>let x: [string, number];
x = [&quot;hello&quot;, 10]; // OK
x = [10, &quot;hello&quot;]; // Error
</code></pre><p>使用不是该数据类型的方法会报错</p>
<pre><code>console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, &#39;number&#39; does not have &#39;substr&#39;
</code></pre><p>新赋值的类型必须是定义时规定的类型</p>
<pre><code>x[3] = &quot;world&quot;; // OK, &#39;string&#39; can be assigned to &#39;string | number&#39;

console.log(x[5].toString()); // OK, &#39;string&#39; and &#39;number&#39; both have &#39;toString&#39;

x[6] = true; // Error, &#39;boolean&#39; isn&#39;t&#39;string | number&#39;
</code></pre><ul>
<li>Enum （枚举类型）- 它用于声明一组命名的常数，当一个变量有几种可能的取值时，可以将它定义为枚举类型。</li>
</ul>
<p>让代码更有语义化, 可读性</p>
<pre><code>enum Color {Red, Green, Blue}
let c: Color = Color.Green;
</code></pre><p>枚举类型的数字默认从 0 开始，可以自己设置</p>
<pre><code>enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;

enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;
</code></pre><p>当不知道 enum 类型的第 N 项是什么名称时，可以用 N 来代替</p>
<pre><code>enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

alert(colorName);
</code></pre><pre><code>var Color;
(function (Color) {
    Color[Color[&quot;Red&quot;] = 1] = &quot;Red&quot;;
    Color[Color[&quot;Green&quot;] = 2] = &quot;Green&quot;;
    Color[Color[&quot;Blue&quot;] = 3] = &quot;Blue&quot;;
})(Color || (Color = {}));
var colorName = Color[2];
alert(colorName);
</code></pre><ul>
<li>Any （任意）- 任何类型都可以（Never 类型除外）</li>
</ul>
<p>关闭类型检查</p>
<pre><code>let notSure: any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false; // okay, definitely a boolean
</code></pre><pre><code>let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn&#39;t check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property &#39;toFixed&#39; doesn&#39;t exist on type&#39;Object&#39;.
</code></pre><pre><code>let list: any[] = [1, true, &quot;free&quot;];

list[1] = 100;
</code></pre><ul>
<li>Void （空）- 用在不返回任何值的函数中</li>
</ul>
<pre><code>function warnUser(): void {
    alert(&quot;This is my warning message&quot;);
}
</code></pre><p>可以用来标识 undefined 和 null</p>
<pre><code>let unusable: void = undefined;
</code></pre><ul>
<li>Null and Undefined</li>
</ul>
<pre><code>let u: undefined = undefined;
let n: null = null;
</code></pre><p>默认为其他类型的亚类型，就是可以匹配其他类型<br>使用 –strictNullChecks 标识，就只匹配 null 、undefined、void<br>可以使用 string | null | undefined 类型来只匹配 string 、 null 、 undefined 三种类型</p>
<blockquote>
<p>官方鼓励使用 –strictNullChecks</p>
</blockquote>
<ul>
<li>Never - 表示值从未发生</li>
</ul>
<p>Any 类型不能匹配 Never</p>
<pre><code>// Function returning never must have unreachable end point
function error(message: string): never {
    throw new Error(message);
}

// Inferred return type is never
function fail() {
    return error(&quot;Something failed&quot;);
}

// Function returning never must have unreachable end point
function infiniteLoop(): never {
    while (true) {
    }
}
</code></pre><ul>
<li>Type assertions</li>
</ul>
<p>“angle-bracket” syntax</p>
<pre><code>let someValue: any = &quot;this is a string&quot;;

let strLength: number = (&lt;string&gt;someValue).length;
</code></pre><p>as -syntax</p>
<pre><code>let someValue: any = &quot;this is a string&quot;;

let strLength: number = (someValue as string).length;
</code></pre><p>一般情况下，两种写法等价，但在 JSX 中，只能用 as -style</p>
<blockquote>
<p>官方文档中关于数据类型的介绍 <a href="http://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="external">Basic Types</a></p>
</blockquote>
<h3 id="Interfaces-接口"><a href="#Interfaces-接口" class="headerlink" title="Interfaces 接口"></a>Interfaces 接口</h3><p>接口会根据一个对象是否符合某种特定的数据结构来进行类型检查</p>
<p>只在开发是有效，编译后删除</p>
<pre><code>interface Food {
    name: string;
    calories: number;
}

function speak(food: Food): void{
  console.log(&quot;Our&quot; + food.name + &quot;has&quot; + food.calories + &quot;calories.&quot;);
}

var ice_cream = {
  name: &quot;ice cream&quot;, 
  calories: 200
}

speak(ice_cream);
</code></pre><p>属性的顺序并不重要。我们只需必要的属性存在并且是正确的类型。如果哪里有遗漏，类型错误，或者命名不同的话，编译器都会报警告信息。</p>
<pre><code>interface Food {
    name: string;
    calories: number;
}

function speak(food: Food): void{
  console.log(&quot;Our&quot; + food.name + &quot;has&quot; + food.calories + &quot;grams.&quot;);
}

// 将 name 改为 nmae
var ice_cream = {
  nmae: &quot;ice cream&quot;, 
  calories: 200
}

speak(ice_cream);
</code></pre><pre><code>main.ts(16,7): error TS2345: Argument of type &#39;{ nmae: string; calories: number; } 
is not assignable to parameter of type &#39;Food&#39;. 
Property &#39;name&#39; is missing in type &#39;{ nmae: string; calories: number; }&#39;.
</code></pre><p>接口可以在属性后面添加？表示可选<br>可以添加 [propName:  类型] : any 表示可以添加任何某种类型的属性</p>
<pre><code>interface Person {    name: string;
    age?: number;
    [propName: string]: any;
}

const preson: Person = { name: &#39;Tom&#39;, age: 20}
const student: Person = { name: &#39;Tom&#39;}
</code></pre><ul>
<li>类实现接口</li>
</ul>
<p>关键字 implements</p>
<pre><code>interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre><pre><code>interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
</code></pre><blockquote>
<p>官方文档有更详细的介绍 <a href="http://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="external">interfaces</a></p>
</blockquote>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>包括了构造器、继承，抽象类，接口，构造函数、setters、getters、public、private、protected、readonly、static 等</p>
<p>ES6 中也有实现</p>
<ul>
<li>属性<br>默认为 public<br>private 只有自己可以用<br>protected 自己和子类可用<br>readonly 只读 (原理 object.freeze)</li>
<li>抽象类 不能实例化</li>
</ul>
<p>实现继承</p>
<pre><code>class Menu {
  // Our properties:
  // By default they are public, but can also be private or protected.
  items: Array&lt;string&gt;;  // The items in the menu, an array of strings.
  pages: number;        // How many pages will the menu be, a number.

  constructor(item_list: Array&lt;string&gt;, total_pages: number) {
    // The this keyword is mandatory.
    this.items = item_list;    
    this.pages = total_pages;
  }

  // Methods
  list(): void {
    console.log(&quot;Our menu for today:&quot;);
    for(var i=0; i&lt;this.items.length; i++) {
      console.log(this.items[i]);
    }
  }

} 

// Create a new instance of the Menu class.
var sundayMenu = new Menu([&quot;pancakes&quot;,&quot;waffles&quot;,&quot;orange juice&quot;], 1);

// Call the list method.
sundayMenu.list();
</code></pre><pre><code>class HappyMeal extends Menu {
  // Properties are inherited

  // A new constructor has to be defined.
  constructor(item_list: Array&lt;string&gt;, total_pages: number) {
    // In this case we want the exact same constructor as the parent class (Menu), 
    // To automatically copy it we can call super() - a reference to the parent&#39;s constructor.
    super(item_list, total_pages);
  }

  // Just like the properties, methods are inherited from the parent.
  // However, we want to override the list() function so we redefine it.
  list(): void{
    console.log(&quot;Our special menu for children:&quot;);
    for(var i=0; i&lt;this.items.length; i++) {
      console.log(this.items[i]);
    }

  }
}

// Create a new instance of the HappyMeal class.
var menu_for_children = new HappyMeal([&quot;candy&quot;,&quot;drink&quot;,&quot;toy&quot;], 1);

// This time the log message will begin with the special introduction.
menu_for_children.list();
</code></pre><blockquote>
<p>阅读官方文档，获得更多信息 <a href="http://www.typescriptlang.org/docs/handbook/classes.html" target="_blank" rel="external">classes</a></p>
</blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p>
<pre><code>function genericFunc&lt;T&gt;(argument: T): T[] {    
  var arrayOfT: T[] = [];    // Create empty array of type T.
  arrayOfT.push(argument);  // Push, now arrayOfT = [argument].
  return arrayOfT;
}

var arrayFromString = genericFunc&lt;string&gt;(&quot;beep&quot;);
console.log(arrayFromString[0]);        // &quot;beep&quot;
console.log(typeof arrayFromString[0])  // String

var arrayFromNumber = genericFunc(42);
console.log(arrayFromNumber[0]);        // 42
console.log(typeof arrayFromNumber[0])  // number
</code></pre><ul>
<li>带泛型的函数类型</li>
</ul>
<pre><code>let f: () =&gt; any = function() {}

let f: &lt;T&gt;(arg: T) =&gt; T = function() {}
</code></pre><ul>
<li>带泛型的接口</li>
</ul>
<pre><code>interface Gen&lt;T&gt; {    (arg: T) : T
}

function fn&lt;T&gt;(arg: T): T {
    return arg;
}

let id: Gen&lt;number&gt; = fn;

Gen(2)
</code></pre><ul>
<li>带泛型的类 </li>
</ul>
<pre><code>class Gen&lt;T&gt; {    value: T
    add: (x: T, y: T) =&gt; T
}

let myGenNum = new Gen&lt;number&gt;()

myGenNum.value = 0
myGenNum.add = (x, y) =&gt; x + y

myGenNum.add(2,3)
</code></pre><ul>
<li>泛型约束</li>
</ul>
<pre><code>interface Length {    
    length: number
}

function fn&lt;T extends Length&gt;(arg: T): T {
    console.log(arg.length)
    return arg
}

fn&lt;string&gt;(&quot;hello&quot;)
</code></pre><blockquote>
<p>官方文档介绍了更多关于泛型类，泛型类与接口绑定等例子<br><a href="http://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="external">generics</a></p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code>function add(x: number, y: number): number {
    return x + y;
}

let myAdd = function(x: number, y: number): number { return x+y; };
</code></pre><ul>
<li>箭头函数</li>
</ul>
<pre><code>// myAdd has the full function type
let myAdd = function(x: number, y: number): number { return  x + y; };

// The parameters &#39;x&#39; and &#39;y&#39; have the type number
let myAdd: (baseValue:number, increment:number) =&gt; number =
    function(x, y) { return x + y; };
</code></pre><p>参数可选</p>
<pre><code>function buildName(firstName: string, lastName?: string) {
    // ...
}
</code></pre><p>剩余参数</p>
<pre><code>function buildName(firstName: string, ...restOfName: string[]) {
    return firstName + &quot;&quot; + restOfName.join(&quot; &quot;);
}

let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;);
</code></pre><blockquote>
<p>官方文档 <a href="http://www.typescriptlang.org/docs/handbook/functions.html" target="_blank" rel="external">functions</a></p>
</blockquote>
<h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><ul>
<li>联合</li>
</ul>
<pre><code>function padLeft(value: string, padding: string | number) {
    // ...
}

let indentedString = padLeft(&quot;Hello world&quot;, true); // errors during compilation
</code></pre><blockquote>
<p>官方文档 <a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html" target="_blank" rel="external">Advanced Types</a></p>
</blockquote>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>如：require.js （AMD 规范）</p>
<p>exporter.ts</p>
<pre><code>var sayHi = function(): void {
    console.log(&quot;Hello!&quot;);
}

export = sayHi;
</code></pre><p>importer.ts</p>
<pre><code>import sayHi = require(&#39;./exporter&#39;);
sayHi();
</code></pre><p>引入 require.js，查看官方文档 <a href="http://requirejs.org/docs/start.html#add" target="_blank" rel="external">requirejs</a></p>
<pre><code>tsc --module amd *.ts
</code></pre><blockquote>
<p>更多模块化的内容，可查看官方文档 <a href="http://www.typescriptlang.org/docs/handbook/modules.html" target="_blank" rel="external">modules</a></p>
</blockquote>
<h3 id="第三方声明文件"><a href="#第三方声明文件" class="headerlink" title="第三方声明文件"></a>第三方声明文件</h3><p>声明文件用来是说明第三方 JavaScript 库是否和 TypeScript 兼容<br>一个声明文件包含. d.ts 扩展名和关于该库的多种信息，还有 API</p>
<p>声明文件通常是手写的，但也可以用其他人写好的<br><a href="http://definitelytyped.org/" target="_blank" rel="external">DefinitelyTyped</a></p>
<ul>
<li>The repository for high quality TypeScript type definitions<br>也有一个用来管理 TypeScript 定义的 Node.js 流行模块，叫 Typings。</li>
</ul>
<blockquote>
<p>官方文档 <a href="http://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="external">introduction</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong> 三十分钟学会 TypeScript</strong>: <a href="http://web.jobbole.com/87535/" target="_blank" rel="external">http://web.jobbole.com/87535/</a><br><strong> 官方文档 </strong>: <a href="http://www.typescriptlang.org/docs/home.html" target="_blank" rel="external">http://www.typescriptlang.org/docs/home.html</a><br><strong> 中文文档 </strong>: <a href="https://www.tslang.cn/index.html" target="_blank" rel="external">https://www.tslang.cn/index.html</a></p>
]]></content>
    
    <summary type="html">
    
      TypeScript 入门
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="TypeScript" scheme="http://ldqblog.me/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Koa 入门</title>
    <link href="http://ldqblog.me/2017/08/10/Koa-%E5%85%A5%E9%97%A8/"/>
    <id>http://ldqblog.me/2017/08/10/Koa-入门/</id>
    <published>2017-08-10T05:56:00.000Z</published>
    <updated>2017-08-10T06:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Koa-入门"><a href="#Koa-入门" class="headerlink" title="Koa 入门"></a>Koa 入门</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><blockquote>
<p>Node 版本必须 7.6 以上</p>
</blockquote>
<p>克隆代码库</p>
<blockquote>
<p>git clone <a href="https://github.com/ruanyf/koa-demos.git" target="_blank" rel="external">https://github.com/ruanyf/koa-demos.git</a></p>
</blockquote>
<h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><h3 id="1-开启-HTTP-服务器"><a href="#1-开启-HTTP-服务器" class="headerlink" title="1 开启 HTTP 服务器"></a>1 开启 HTTP 服务器</h3><pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

app.listen(3000);
</code></pre><h3 id="2-Context-对象"><a href="#2-Context-对象" class="headerlink" title="2 Context 对象"></a>2 Context 对象</h3><p>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
    ctx.response.body = &#39;Hello World&#39;;
};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-32b69cd94b58aced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>ctx.response 代表 HTTP Response<br>ctx.request 代表 HTTP Request</p>
<h3 id="3-response-类型"><a href="#3-response-类型" class="headerlink" title="3 response 类型"></a>3 response 类型</h3><p>Koa 默认的返回类型是 text/plain</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-cec6dc9a5a3d7674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>ctx.request.accepts 用来判断客户端希望接受什么数据<br>ctx.response.type 指定返回类型</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

if (ctx.request.accepts(&#39;xml&#39;)) {

    ctx.response.type = &#39;xml&#39;;

    ctx.response.body = &#39;&lt;data&gt;Hello World&lt;/data&gt;&#39;;

} else if (ctx.request.accepts(&#39;json&#39;)) {

    ctx.response.type = &#39;json&#39;;

    ctx.response.body = { data: &#39;Hello World&#39; };

} else if (ctx.request.accepts(&#39;html&#39;)) {

    ctx.response.type = &#39;html&#39;;

    ctx.response.body = &#39;&lt;p&gt;Hello World&lt;/p&gt;&#39;;

} else {

    ctx.response.type = &#39;text&#39;;

    ctx.response.body = &#39;Hello World&#39;;

}

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-83caa8dd754ae06e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-df6ccc66b21c55da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-0d84b50c0498d5dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-读取模板文件"><a href="#4-读取模板文件" class="headerlink" title="4 读取模板文件"></a>4 读取模板文件</h3><pre><code>const fs = require(&#39;fs&#39;);
const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

ctx.response.type = &#39;html&#39;;

ctx.response.body = fs.createReadStream(&#39;./demos/template.html&#39;);

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-6cfaa24a42e6277d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="二、路由"><a href="#二、路由" class="headerlink" title="二、路由"></a>二、路由</h2><h3 id="1-原生路由"><a href="#1-原生路由" class="headerlink" title="1 原生路由"></a>1 原生路由</h3><p>ctx.request.path<br>可获取用户请求的路径</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

if (ctx.request.path !== &#39;/&#39;) {

ctx.response.type = &#39;html&#39;;

ctx.response.body = &#39;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&#39;;

} else {

        ctx.response.body = &#39;Hello World&#39;;

}

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-efda28165ef1c82e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-6e9b906b2762e116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-koa-router"><a href="#2-koa-router" class="headerlink" title="2 koa-router"></a>2 koa-router</h3><p>route.get(path, callback)<br>callback 指定 ctx.response.type 和 ctx,response.body</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const route = require(&#39;koa-route&#39;);
const app = new Koa();

const about = ctx =&gt; {

ctx.response.type = &#39;html&#39;;

ctx.response.body = &#39;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&#39;;

};

const main = ctx =&gt; {
        ctx.response.body = &#39;Hello World&#39;;
};

app.use(route.get(&#39;/&#39;, main));
app.use(route.get(&#39;/about&#39;, about));

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-6ba08211d1b585a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-ae9d621c3e1b02a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-6e274232aaba6562.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-52627f567dc12140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="3-静态资源"><a href="#3-静态资源" class="headerlink" title="3 静态资源"></a>3 静态资源</h3><p>koa-static 处理静态资源</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();
const path = require(&#39;path&#39;);
const serve = require(&#39;koa-static&#39;);

const main = serve(path.join(__dirname));

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-51fc1d1d22dd591b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-c10a8f130e9bef9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-32fb0ac20d841137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-302-重定向"><a href="#4-302-重定向" class="headerlink" title="4 302 重定向"></a>4 302 重定向</h3><p>ctx.response.redirect()</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const route = require(&#39;koa-route&#39;);
const app = new Koa();

const redirect = ctx =&gt; {
    ctx.response.redirect(&#39;/&#39;);
};

const main = ctx =&gt; {
    ctx.response.body = &#39;Hello World&#39;;
};

app.use(route.get(&#39;/&#39;, main));
app.use(route.get(&#39;/redirect&#39;, redirect));

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-d49041f899983618.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="三、-中间件"><a href="#三、-中间件" class="headerlink" title="三、 中间件"></a>三、 中间件</h2><h3 id="1-logger"><a href="#1-logger" class="headerlink" title="1 logger"></a>1 logger</h3><p>打印日志</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);

ctx.response.body = &#39;Hello World&#39;;

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-e3ba60c3e0d8d612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-中间件的概念"><a href="#2-中间件的概念" class="headerlink" title="2 中间件的概念"></a>2 中间件的概念</h3><p>logger 函数就叫做 “中间件”（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use() 用来加载中间件。</p>
<p>基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的 main 也是中间件。<br>参数 context 对象， next 函数 （将执行权限交给下一个中间件）</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const logger = (ctx, next) =&gt; {

console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);

next();

}

const main = ctx =&gt; {
ctx.response.body = &#39;Hello World&#39;;
};

app.use(logger);
app.use(main);
app.listen(3000);
</code></pre><h3 id="3-中间件栈"><a href="#3-中间件栈" class="headerlink" title="3 中间件栈"></a>3 中间件栈</h3><p>多个中间件会形成一个栈结构（middle stack），以 “先进后出”（first-in-last-out）的顺序执行。</p>
<blockquote>
<ol>
<li>最外层的中间件首先执行。</li>
<li>调用 next 函数，把执行权交给下一个中间件。    </li>
<li>…  </li>
<li>最内层的中间件最后执行。  </li>
<li>执行结束后，把执行权交回上一层的中间件。  </li>
<li>…  </li>
<li>最外层的中间件收回执行权之后，执行 next 函数后面的代码。  </li>
</ol>
</blockquote>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const one = (ctx, next) =&gt; {

console.log(&#39;&gt;&gt; one&#39;);

next();

console.log(&#39;&lt;&lt; one&#39;);

}

const two = (ctx, next) =&gt; {

console.log(&#39;&gt;&gt; two&#39;);

next();

console.log(&#39;&lt;&lt; two&#39;);

}

const three = (ctx, next) =&gt; {

console.log(&#39;&gt;&gt; three&#39;);

next();

console.log(&#39;&lt;&lt; three&#39;);

}

app.use(one);
app.use(two);
app.use(three);

app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-578836fa12375529.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果没有 next，中间件就不会往内层的中间件执行 而会返回外层中间件</p>
<p>把 two 的 next 注释掉</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-5f85230c6e1857aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-异步中间件"><a href="#4-异步中间件" class="headerlink" title="4 异步中间件"></a>4 异步中间件</h3><pre><code>const fs = require(&#39;fs.promised&#39;);
const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = async function (ctx, next) {
ctx.response.type = &#39;html&#39;;
ctx.response.body = await fs.readFile(&#39;./demos/template.html&#39;, &#39;utf8&#39;);
};

app.use(main);
app.listen(3000);
</code></pre><p>async await 处理异步</p>
<h3 id="5-中间件的合成"><a href="#5-中间件的合成" class="headerlink" title="5 中间件的合成"></a>5 中间件的合成</h3><p>koa-compose 将多个中间件合并成一个</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const compose = require(&#39;koa-compose&#39;);
const app = new Koa();

const logger = (ctx, next) =&gt; {

console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);

next();

}

const main = ctx =&gt; {
    ctx.response.body = &#39;Hello World&#39;;
};

const middlewares = compose([logger, main]);

app.use(middlewares);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-022a1b9a9ed7ab00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-a2cebd71f3c7e6ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="四、错误处理"><a href="#四、错误处理" class="headerlink" title="四、错误处理"></a>四、错误处理</h2><h3 id="500-错误"><a href="#500-错误" class="headerlink" title="500 错误"></a>500 错误</h3><p>500 状态码 —— 代码运行错误</p>
<p>ctx.throw 抛出错误</p>
<p>ctx.throw(500) 抛出 500 错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
  ctx.throw(500);
};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-a8b4b900929fc3d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-5735b99604f5fe9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-759028ee17851586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-20eff4f2acbc2499.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-404-错误"><a href="#2-404-错误" class="headerlink" title="2 404 错误"></a>2 404 错误</h3><p>ctx.response.status = 404 相当于 ctx.throw(404) 返回 404 错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
  ctx.response.status = 404;
  ctx.response.body = &#39;Page Not Found&#39;;
};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-efbe181b5321d060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-feb318b8207c51a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="3-处理错误的中间件"><a href="#3-处理错误的中间件" class="headerlink" title="3 处理错误的中间件"></a>3 处理错误的中间件</h3><p>让最外层中间件负责处理所有中间件的错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const handler = async (ctx, next) =&gt; {
  try {
    await next();
  } catch (err) {
    ctx.response.status = err.statusCode || err.status || 500;
    ctx.response.body = {
      message: err.message
    };
  }
};

const main = ctx =&gt; {
  ctx.throw(500);
};

app.use(handler);
app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-b6a9a47929347e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1e9ed4f3b201c457.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-error-事件的监听"><a href="#4-error-事件的监听" class="headerlink" title="4 error 事件的监听"></a>4 error 事件的监听</h3><p>监听 error 事件也可以处理错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
  ctx.throw(500);
};

app.on(&#39;error&#39;, (err, ctx) =&gt; {
  console.error(&#39;server error&#39;, err);
});

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-5a622ff8b674cb25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-f0dd9f99ad67697b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="5-释放-error-事件"><a href="#5-释放-error-事件" class="headerlink" title="5 释放 error 事件"></a>5 释放 error 事件</h3><p>被 try … catch 捕获的错误不会触发 error 事件</p>
<p>要调用 ctx.app.emit(), 手动释放 error 事件</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const handler = async (ctx, next) =&gt; {
  try {
    await next();
  } catch (err) {
    ctx.response.status = err.statusCode || err.status || 500;
    ctx.response.type = &#39;html&#39;;
    ctx.response.body = &#39;&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;&#39;;
    ctx.app.emit(&#39;error&#39;, err, ctx);
  }
};

const main = ctx =&gt; {
  ctx.throw(500);
};

app.on(&#39;error&#39;, function(err) {
  console.log(&#39;logging error&#39;, err.message);
  console.log(err);
});

app.use(handler);
app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-7d43b2ac6e8bbf7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-506388f40095a28d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-ace175d9f131f842.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="五、Web-App-的功能"><a href="#五、Web-App-的功能" class="headerlink" title="五、Web App 的功能"></a>五、Web App 的功能</h2><h3 id="1-Cookies"><a href="#1-Cookies" class="headerlink" title="1 Cookies"></a>1 Cookies</h3><p>ctx.cookies 读写 Cookie<br>ctx.cookies.get() 获得 Cookie<br>ctx.cookies.set() 设置 Cookie</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = function(ctx) {
  const n = Number(ctx.cookies.get(&#39;view&#39;) || 0) + 1;
  ctx.cookies.set(&#39;view&#39;, n);
  ctx.response.body = n + &#39;views&#39;;
}

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-36da76974f1f7466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1dd21f5fa547ce7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-6878538e8bc07385.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>每刷新一次就会跟增加一次</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-f291e8cb41e4a452.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-fbbf9a5527cfc00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1f41e0f27dbcf93f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-表单"><a href="#2-表单" class="headerlink" title="2 表单"></a>2 表单</h3><p>Web 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。</p>
<p>koa-body 用来从 POST 请求体中提取键值对</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const koaBody = require(&#39;koa-body&#39;);
const app = new Koa();

const main = async function(ctx) {
  const body = ctx.request.body;
  if (!body.name) ctx.throw(400, &#39;.name required&#39;);
  ctx.body = { name: body.name };
};

app.use(koaBody());
app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-b1b4ea7178e40045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-5a56b2cd0f4e2c0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>POST 方法向服务器发送一个键值对，会被正确解析。如果发送的数据不正确，就会收到错误提示。</p>
<p>打开新的命令行窗口</p>
<p>输入</p>
<p>curl -X POST –data “name=Jack” localhost:3000</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1f6bd2a2ae6af739.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>curl -X POST –data “name” localhost:3000</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-bdee1f7139fdeb35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="3-文件上传"><a href="#3-文件上传" class="headerlink" title="3 文件上传"></a>3 文件上传</h3><p>koa-body 处理文件上传</p>
<pre><code>const os = require(&#39;os&#39;);
const path = require(&#39;path&#39;);
const Koa = require(&#39;koa&#39;);
const fs = require(&#39;fs&#39;);
const koaBody = require(&#39;koa-body&#39;);

const app = new Koa();

const main = async function(ctx) {
  const tmpdir = os.tmpdir();
  const filePaths = [];
  const files = ctx.request.body.files || {};

  for (let key in files) {
    const file = files[key];
    const filePath = path.join(tmpdir, file.name);
    console.log(filePath)
    const reader = fs.createReadStream(file.path);
    const writer = fs.createWriteStream(filePath);
    reader.pipe(writer);
    filePaths.push(filePath);
  }

  ctx.body = filePaths;
};

app.use(koaBody({ multipart: true }));
app.use(main);
app.listen(3000);
</code></pre><p>在新的命令行窗口输入</p>
<p>curl –form upload=@/path/to/file <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a></p>
<p>/path/to/file 替换成真实路径</p>
<p>curl –form upload=@/D:/Nodejs/other/koa-demos/demos/21.js <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-7c57a9a9333dccf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">   </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Koa 框架教程 by 阮一峰 </strong>：<a href="http://www.ruanyifeng.com/blog/2017/08/koa.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2017/08/koa.html</a></p>
]]></content>
    
    <summary type="html">
    
      参考阮一峰老师的Koa入门教程
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="node" scheme="http://ldqblog.me/tags/node/"/>
    
      <category term="Koa" scheme="http://ldqblog.me/tags/Koa/"/>
    
      <category term="后端" scheme="http://ldqblog.me/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>music video test</title>
    <link href="http://ldqblog.me/2017/07/31/music-video-test/"/>
    <id>http://ldqblog.me/2017/07/31/music-video-test/</id>
    <published>2017-07-31T13:00:43.000Z</published>
    <updated>2017-07-31T18:02:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="歌曲"><a href="#歌曲" class="headerlink" title="歌曲"></a>歌曲</h3><div class="aplayer" data-id="31673404" data-server="netease" data-type="song"></div>

<h3 id="歌单"><a href="#歌单" class="headerlink" title="歌单"></a>歌单</h3><div class="aplayer" data-id="11100236" data-server="netease" data-type="playlist" data-mode="random"></div>

<h3 id="b-站视频"><a href="#b-站视频" class="headerlink" title="b 站视频"></a>b 站视频</h3><iframe class="bilibiliVideo" src="https://www.bilibili.com/html/html5player.html?cid=5090828&aid=3227348" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

]]></content>
    
    <summary type="html">
    
      测试音乐
    
    </summary>
    
    
      <category term="test" scheme="http://ldqblog.me/tags/test/"/>
    
      <category term="music" scheme="http://ldqblog.me/tags/music/"/>
    
      <category term="video" scheme="http://ldqblog.me/tags/video/"/>
    
  </entry>
  
  <entry>
    <title>Redux 简介</title>
    <link href="http://ldqblog.me/2017/07/23/Redux-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/07/23/Redux-简介/</id>
    <published>2017-07-22T16:29:31.000Z</published>
    <updated>2017-10-12T16:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code>
redux react-redux

const 文件
action 
aciton creator
reducer
store
state
dispatch
combineReducers

connect
mapStateToProps
mapDispatchToProps
middleware
</code></pre><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><pre><code>保存数据的一个单一状态树
</code></pre><p>要通过 createStore 方法生成    </p>
<pre><code>import {createStore} from &#39;redux&#39;
const store = createStore(fn)
</code></pre><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>  Action 是一个对象。其中的 type 属性是必须的，表示 Action 的名称。<br>  其他属性可以自由设置。</p>
<pre><code>  const action = {
    type: &#39;ADD_TODO&#39;,
    payload: &#39;Learn Redux&#39;
  }
</code></pre><h2 id="action-creator"><a href="#action-creator" class="headerlink" title="action creator"></a>action creator</h2><pre><code>每次手写 action 很麻烦，于是要定义一个函数来生成 action，该函数就是
action creator
</code></pre><pre><code>const chooseNav = (index) =&gt; {
    return {
        type: CHOOSE_NAV,
        index
    }
}

const action = chooseNav(1)
</code></pre><h2 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch"></a>store.dispatch</h2><p>  要触发 action，就要使用 store.dispatch</p>
<pre><code>import { createStore } from &#39;redux&#39;;
const store = createStore(fn)

store.dispatch({
  type: &#39;ADD_TODO&#39;,
  payload: &#39;Learn Redux&#39;
})
</code></pre><h2 id="const-文件"><a href="#const-文件" class="headerlink" title="const 文件"></a>const 文件</h2><p>  将 action.type 定义为常量<br>  reducer 通过 action.type 判断是哪个 action</p>
<h2 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h2><p>  更新数据， 返回新的 state</p>
<pre><code>const initState = {

}

const reducer = (state = initState, action) =&gt; {
    switch(action.type) {
        case xxx:
            xxx
            break
        case yyy:
            yyy
            break
        default 
           return state 

    }
}
</code></pre><h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><pre><code>合并多个 reducer
</code></pre><pre><code>import { combineReducers } from &#39;redux&#39;


const chatReducer = combineReducers({
  chatLog,
  statusMessage,
  userName
})

export default chatReducer
</code></pre><h2 id="创建-stroe"><a href="#创建-stroe" class="headerlink" title="创建 stroe"></a>创建 stroe</h2><pre><code>import chatReducer from &#39;./xxx&#39;


const store = createStore(
    chatReducer
)

export default store
</code></pre><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>   store 添加在 Provider 组件</p>
<pre><code>import store from &#39;./yyy&#39;
import {Provider} from &#39;react-redux&#39;



ReactDOM.render(
    &lt; Provider store={store} &gt;
       ...
    &lt; /Provider &gt;, 
document.getElementById(&#39;root&#39;))
</code></pre><h2 id="在组件中使用"><a href="#在组件中使用" class="headerlink" title="在组件中使用"></a>在组件中使用</h2><pre><code> mapStateToProps 传 props 给组件
 mapDispatchToProps 传 dispatch 方法 给组件
 通过 connect 传个组件 
</code></pre><p>例子</p>
<pre><code>import React, { Component } from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;
import CommentList from &#39;../components/CommentList.js&#39;
import { initComments, deleteComment} from &#39;../reducers/comments.js&#39;
import {connect} from &#39;react-redux&#39;



class CommentListContainer extends Component {
    static propTypes = {
        comments: PropTypes.array,
        initComments: PropTypes.func,
        deleteComment: PropTypes.func
    }

    componentWillMount() {
        this._loadComments()
    }

    _loadComments() {
        let comments = localStorage.getItem(&#39;comments&#39;)
        comments = comments ? JSON.parse(comments) : []
        this.props.initComments(comments)
    }

    handleDeleteComment(index) {
        const {comments} = this.props
        const newComments = [
            ...comments.slice(0, index),
            ...comments.slice(index + 1)
        ]
        localStorage.setItem(&#39;comments&#39;, JSON.stringify(newComments))
        if(this.props.onDeleteComment) {
            this.props.onDeleteComment(index)
        }
    }

    render() {
        return (
            &lt; CommentList 
                comments = {this.props.comments}
                onDeleteComment={this.handleDeleteComment.bind(this)}
            / &gt;
        )
    }
}

// 评论列表从 state.comments 中获取
const mapStateToProps = state =&gt; {
    return {
        comments: state.comments
    }
}

const mapDispatchToProps = dispatch =&gt; {
    return {
        // 提供给 CommentListContainer
        // 当从 LocalStorage 加载评论列表以后就会通过这个方法
        // 把评论列表初始化到 state 当中
        initComments: (comments) =&gt; {
            dispatch(initComments(comments))
        } ,
        // 删除评论
        onDeleteComment: (commentIndex) =&gt; {
            dispatch(deleteComment(commentIndex))
        }
    }
}


// 将 CommentListContainer connect 到 store
// 会把 comments、initComments、onDeleteComment 传给 CommentListContainer

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(CommentListContainer)
</code></pre><h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><p>   强化 redux 的功能</p>
<p>原理<br>   改写 store.dispatch </p>
<p>因为 reducer 是纯函数，只承担计算 State 的功能，不合适承担其他功能<br>View 与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。<br>Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</p>
<p>compose<br>  从右到左来组合多个函数。</p>
<p>这是函数式编程中的方法，为了方便，被放到了 Redux 里。<br>当需要把多个 store 增强器 依次执行的时候，需要用到它。</p>
<p>例子</p>
<pre><code>import {createStore, applyMiddleware, compose} from &#39;redux&#39;
import reducers from &#39;./reducers.js&#39;
import thunkMiddleware  from &#39;redux-thunk&#39;
import createLogger from &#39;redux-logger&#39;



export default () =&gt; {
    const middleware = [thunkMiddleware, createLogger]


    const composeEnhancers = 
        process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;
            typeof window === &#39;object&#39; &amp;&amp;
            window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ 
            ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
                // Specify extension’s options like name, actionsBlacklist, actionsCreators, serialize...
                }) 
            : compose

    const enhancers =  composeEnhancers(
        applyMiddleware(...middleware)
    )

    const store = createStore(
        reducers,
        enhancers
    )

    return store
}
</code></pre><h3 id="处理异步"><a href="#处理异步" class="headerlink" title="处理异步"></a>处理异步</h3><pre><code>

redux-think + async/await
    redux-think 让 dispatch 能接受 函数作为参数 （原来参数只能是对象）
    利用 async/await 的调用方式处理异步

redux-promise
    利用 promise 的调用方式处理异步


redux-promise-middleware
    优化 redux-promise


redux-saga (generator/yield)
     利用 generator/yield 的调用方式处理异步
     提供大量的 api


redux-observable (RxJS)
     利用 RxJS 的调用方式处理异步
     提供大量的 api


redux-loop
</code></pre><h3 id="其他中间件"><a href="#其他中间件" class="headerlink" title="其他中间件"></a>其他中间件</h3><pre><code>
redux-logger
</code></pre><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p><a href="https://github.com/sorrycc/blog/issues/1" target="_blank" rel="external">看看 dva 的前身 React + Redux 最佳实践，知道 dva 是怎么来的</a></p>
<h3 id="优秀的相关框架"><a href="#优秀的相关框架" class="headerlink" title="优秀的相关框架"></a>优秀的相关框架</h3><p><a href="https://github.com/dvajs/dva" target="_blank" rel="external">dva</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong> 理解 React</strong>: <a href="https://www.zhihu.com/question/41312576?sort=created" target="_blank" rel="external">https://www.zhihu.com/question/41312576?sort=created</a><br><strong>Redux 入门教程（一）—— 阮一峰 </strong>: <a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</a></p>
]]></content>
    
    <summary type="html">
    
      Redux 入门简单介绍
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://ldqblog.me/tags/React/"/>
    
      <category term="Redux" scheme="http://ldqblog.me/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>React-Router 简介</title>
    <link href="http://ldqblog.me/2017/07/15/React-Router-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/07/15/React-Router-简介/</id>
    <published>2017-07-14T16:27:53.000Z</published>
    <updated>2017-10-12T16:45:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Router"><a href="#React-Router" class="headerlink" title="React-Router"></a>React-Router</h1><p><a href="http://ldqblog.me/learn-react-router/build/">学习 React-Router 的例子</a></p>
<p><a href="https://github.com/LDQ-first/learn-react-router" target="_blank" rel="external">源码</a></p>
]]></content>
    
    <summary type="html">
    
      React-Router 入门简单介绍
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://ldqblog.me/tags/React/"/>
    
      <category term="React-Router" scheme="http://ldqblog.me/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>React 简介</title>
    <link href="http://ldqblog.me/2017/07/13/React-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/07/13/React-简介/</id>
    <published>2017-07-12T16:15:33.000Z</published>
    <updated>2017-10-12T16:27:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-简介"><a href="#React-简介" class="headerlink" title="React 简介"></a>React 简介</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>一般写在 render 生命周期函数里</p>
<p>语法:</p>
<pre><code>return (
    写 HTML 

    注意 有些 属性要改写 
    如 ： class =》 className 

    标签要闭合 &lt;img src=&quot;&quot;&gt; =》 &lt; img src=&quot;&quot; /&gt; 

    可以添加 js
    但要用 {} 括起来 


)
</code></pre><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><pre><code>import React, { Component } from &#39;react&#39;

class NotFound extends Component {

    render () {

        return (


        )
    }
}
</code></pre><p>例子</p>
<pre><code>import React, { Component } from &#39;react&#39;


export default class NotFound extends Component {

    render() {

        return (
            &lt; Container className=&quot;noPadding&quot; &gt;
               &lt; NotFoundDiv &gt;
                   &lt; h1 className=&quot;title&quot; &gt;404&lt; /h1 &gt;
               &lt; /NotFoundDiv &gt;
            &lt; /Container &gt;
        )
    }
}
</code></pre><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>获取 dom 元素</p>
<pre><code>&lt; div className=&quot;contactContent&quot; 
    ref={contact =&gt; this._contact = contact} &gt;       
&lt; /div &gt;
</code></pre><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>数据</p>
<pre><code>constructor(props) {
    super(props) 
    this.state = {

    }
}
</code></pre><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>   更新 state </p>
<p>注意：</p>
<ol>
<li>setState 不会立刻改变 React 组件中 state 的值</li>
<li>函数式的 setState 用法</li>
</ol>
<p>看这篇文章<br>   <a href="https://zhuanlan.zhihu.com/p/25954470" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/25954470</a></p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>子组件接受父组件的数据</p>
<pre><code>const { _this } = this.props
</code></pre><h3 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h3><p>props 类型检查</p>
<pre><code>import PropTypes from &#39;prop-types&#39;


static get propTypes() {
    return {
        _this: PropTypes.object
    }
}
</code></pre><h4 id="classNames-第三方库"><a href="#classNames-第三方库" class="headerlink" title="classNames(第三方库)"></a>classNames(第三方库)</h4><p> 处理各类名</p>
<pre><code>import classNames from &#39;classnames&#39;

const { isSpread } = this.state

className={classNames(&#39;toggle&#39;, {active: isSpread})
</code></pre><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>事件<br>React 支持许多事件<br>官方文档有列出<br><a href="https://reactjs.org/docs/events.html#supported-events" target="_blank" rel="external">https://reactjs.org/docs/events.html#supported-events</a></p>
<pre><code>
&lt;a href=&quot;javascript:;&quot; className=&#39;toggle&#39;} 
onClick={() =&gt; { this._toggle() }}&gt;
    &lt;i className=&quot;bar&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
</code></pre><h3 id="lists-key-map"><a href="#lists-key-map" class="headerlink" title="lists key map"></a>lists key map</h3><p>循环</p>
<pre><code>
const { navArr} = this.state

const navs = navArr.map((item, index) =&gt; {
    return (
        &lt;li key={index} className=&#39;nav&#39;} &gt;
            {item.name}
        &lt;/li&gt;
    )
})

&lt;ul className=&#39;navs&#39;&gt;
    {navs ? navs : null}
&lt;/ul&gt;
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>npm install -g create-react-app

create-react-app my-app
cd my-app/
npm start
</code></pre><p>浏览器自动打开 <a href="http://localhost:3000/" target="_blank" rel="external">http://localhost:3000/</a></p>
<p>写完</p>
<p>npm run build 构建打包</p>
<p>生成的 build 文件夹就是要发布的文件</p>
<h4 id="文件夹结构"><a href="#文件夹结构" class="headerlink" title="文件夹结构"></a>文件夹结构</h4><pre><code>
my-app
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── public
│   └── favicon.ico
│   └── index.html
│   └── manifest.json
└── src
    └── App.css
    └── App.js
    └── App.test.js
    └── index.css
    └── index.js
    └── logo.svg
    └── registerServiceWorker.js
</code></pre><p>在 src 中编写代码</p>
<p>也可以自己搭建一个脚手架</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>React 文档 </strong>: <a href="https://reactjs.org/" target="_blank" rel="external">https://reactjs.org/</a></p>
]]></content>
    
    <summary type="html">
    
      React 入门简单介绍
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://ldqblog.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Vuex 简介</title>
    <link href="http://ldqblog.me/2017/06/24/Vuex-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/06/24/Vuex-简介/</id>
    <published>2017-06-24T15:57:24.000Z</published>
    <updated>2017-10-12T16:16:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>vue 组件通过 dispatch 来触发 actions [这步可省略， 一般用于处理异步]<br>actions 再通过 commit 触发 mutations , 改变 store 上的 state<br>最终改变 vue 组件 的 view </p>
<p>常与 computed 结合 </p>
<p>state 是唯一数据来源</p>
<p>vuex 是单一状态树</p>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>getters 派生出一些新的状态</p>
<p>Vuex 允许我们在 store 中定义 “getter”（可以认为是 store 的计算属性）。<br>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，<br>且只有当它的依赖值发生了改变才会被重新计算。</p>
<pre><code>const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: &#39;...&#39;, done: true },
      { id: 2, text: &#39;...&#39;, done: false }
    ]
  },
  getters: {
    doneTodos: state =&gt; {
      return state.todos.filter(todo =&gt; todo.done)
    }
  }
})
</code></pre><p>Getter 会暴露为 store.getters 对象：</p>
<p>store.getters.doneTodos // -&gt; [{ id: 1, text: ‘…’, done: true }]<br>Getter 也可以接受其他 getter 作为第二个参数：</p>
<pre><code>getters: {
  // ...
  doneTodosCount: (state, getters) =&gt; {
    return getters.doneTodos.length
  }
}
store.getters.doneTodosCount // -&gt; 1
</code></pre><p>我们可以很容易地在任何组件中使用它：</p>
<pre><code>computed: {
  doneTodosCount () {
    return this.$store.getters.doneTodosCount
  }
}
</code></pre><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p>
<pre><code>getters: {
  // ...
  getTodoById: (state, getters) =&gt; (id) =&gt; {
    return state.todos.find(todo =&gt; todo.id === id)
  }
}
store.getters.getTodoById(2) // -&gt; { id: 2, text: &#39;...&#39;, done: false }
</code></pre><p>mapGetters 辅助函数 类似 mapState</p>
<p>在 computed 中使用… 运算符获取 getters</p>
<h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>更改 vuex 的 store 中的状态的唯一方法是提交 mutations</p>
<p>action 通过 mutations 间接改变 store 的状态</p>
<p>acion 处理异步操作</p>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>将 store 状态分割成模块（modules）<br>便于管理</p>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><pre><code>store
  module 
    moduleHome.js
  mutations
    mutationsHome.js
  index.js




moduleHome.js

import mutations from &#39;../mutations/mutationsHome.js&#39;

export default {
    state: {
        isFullScreen: false
    },
    mutations: mutations()
}




mutationsHome.js

export default () =&gt; {
    return {
        FullScreen (state, isFullScreen) {
            state.isFullScreen = isFullScreen
        }
    }
}



index.js

import Vuex from &#39;vuex&#39;
import Vue from &#39;vue&#39;
Vue.use(Vuex)

import moduleHome from &#39;./module/moduleHome.js&#39;


export default new Vuex.Store({
    modules: {
        home: moduleHome
    }
})   





main.js

import Vue from &#39;vue&#39;
import App from &#39;./App&#39;
import store from &#39;./store/index.js&#39;

Vue.config.productionTip = false



new Vue({
  el: &#39;#app&#39;,
  store,
  render: h =&gt; h(App)
})
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>const Sidebar = resolve =&gt; require([&#39;../../components/Sidebar.vue&#39;], resolve)
const MainContent = resolve =&gt; require([&#39;../../components/MainContent.vue&#39;], resolve)
const Buttons = resolve =&gt; require([&#39;../../components/Button.vue&#39;], resolve)

import { mapState } from &#39;vuex&#39;

export default {
    name: &#39;Home&#39;,
    data () {
        return {

        } 
    },
    computed: {
        ...mapState({
            isFullScreen: state =&gt; state.home.isFullScreen
        })
        /*
            isFullScreen() {
                return this.$store.state.home.isFullScreen
            }
        */
    },
    components: {
        Buttons,
        Sidebar,
        MainContent
    },
    methods: {
        cancelFullScreen () {
            this.$store.commit(&#39;FullScreen&#39;, false)
        }
    }
}
</code></pre><h3 id="对比-redux"><a href="#对比-redux" class="headerlink" title="对比 redux"></a>对比 redux</h3><pre><code>
都是基于 Flux
吸取 redux 的优点
放弃强制的 immutability
api 更简洁
性能较好
与 vue 契合度更高
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-c893179ac3e708f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuex.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Vuex 文档 </strong>: <a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="external">https://vuex.vuejs.org/zh-cn/</a><br><strong> 尤大的答案 </strong>: <a href="https://www.zhihu.com/question/38546875/answer/76970954" target="_blank" rel="external">https://www.zhihu.com/question/38546875/answer/76970954</a></p>
]]></content>
    
    <summary type="html">
    
      Vuex 入门简单介绍
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://ldqblog.me/tags/Vue/"/>
    
      <category term="Vuex" scheme="http://ldqblog.me/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Router 简介</title>
    <link href="http://ldqblog.me/2017/06/18/Vue-Router-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/06/18/Vue-Router-简介/</id>
    <published>2017-06-18T15:29:31.000Z</published>
    <updated>2017-10-12T16:04:46.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-Router-简介"><a href="#Vue-Router-简介" class="headerlink" title="Vue-Router 简介"></a>Vue-Router 简介</h1><h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><blockquote>
<p>指根据不同的 url 展示不同的内容或页面</p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>用户体验好，
不需要每次从服务器全部获取
展示更加快速
</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>不利于 SEO
使用浏览器的前进后退功能时，会重新发请求，
不能有效利用缓存

单页面无法记住之前滚动的位置，
无法在前进后退的时候记住之前的位置
</code></pre><h2 id="Vue-路由-——-Vue-Router"><a href="#Vue-路由-——-Vue-Router" class="headerlink" title="Vue 路由 —— Vue-Router"></a>Vue 路由 —— Vue-Router</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><pre><code>
/user/:username
/user/:username/goodlist/:goodlist_id


username，goodlist_id 是变化的

$router.params
</code></pre><h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><p>路由有子路由</p>
<pre><code>export default new Router({
  routes: [
    {
      path: &#39;/goods&#39;,
      name: &#39;GoodList&#39;,
      component: GoodList,
      children:[
        {
          path: &#39;title&#39;,
          name: &#39;title&#39;,
          component: Title
        },
        {
          path: &#39;img&#39;,
          name: &#39;img&#39;,
          component: Image
        }
      ]
    }
  ]
})
</code></pre><h4 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h4><p>不通过 <router-link>&lt; /router-link &gt; 来跳转，而通过<br>事件触发，调用 $router.push() API 来跳转</router-link></p>
<pre><code>$router.push(&quot;name&quot;)
$router.push({path:&quot;name&quot;})
$router.push({path:&quot;name?a=123&quot;})
$router.push({path:&quot;name&quot;, query: {a:&quot;123&quot;}})
$router.go(1)  // 前进 1 页  相当于 history.go(1)


&lt; button @click=&quot;jump&quot; &gt;跳转到购物车页面&lt; /button &gt;

 methods:{
    jump() {
        //this.$router.push(&quot;cart&quot;)
        this.$router.push({path:&#39;cart?goodsId=123&#39;})
    }
}
</code></pre><h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><p>给路由不同的名字，根据名字来进行匹配</p>
<pre><code>import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
import GoodList from &#39;../views/GoodList&#39;
import Title from &#39;@/views/Title&#39;
import Image from &#39;@/views/Image&#39;
import Cart from &#39;@/views/Cart&#39;

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: &#39;/goods&#39;,
      name: &#39;GoodList&#39;,
      component: GoodList,
      children:[
        {
          path: &#39;title&#39;,
          name: &#39;title&#39;,
          component: Title
        },
        {
          path: &#39;img&#39;,
          name: &#39;img&#39;,
          component: Image
        }
      ]
    },
    {
        path: &#39;/cart/:cartId&#39;,
        name: &#39;cart&#39;,
        component: Cart
    }
  ]
})


&lt; router-link :to=&quot;{name:&#39;cart&#39;,params:{cartId: 123}}&quot; &gt;跳转到购物车页面&lt; /router-link &gt;
</code></pre><h4 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h4><p>给不同的 router-view 定义名字，通过名字进行对应组件的渲染</p>
<pre><code>import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
import GoodList from &#39;../views/GoodList&#39;
import Title from &#39;@/views/Title&#39;
import Image from &#39;@/views/Image&#39;
import Cart from &#39;@/views/Cart&#39;

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: &#39;/&#39;,
      name: &#39;GoodList&#39;,
      components: {
        default: GoodList,
        title: Title,
        img: Image 
      },
      children:[
        {
          path: &#39;title&#39;,
          name: &#39;title&#39;,
          component: Title
        },
        {
          path: &#39;img&#39;,
          name: &#39;img&#39;,
          component: Image
        }
      ]
    },
    {
        path: &#39;/cart/:cartId&#39;,
        name: &#39;cart&#39;,
        component: Cart
    }
  ]
})




&lt; router-view class=&quot;main&quot; &gt;&lt; /router-view&gt;
&lt; router-view name=&quot;title&quot; class=&quot;left&quot; &gt;&lt; /router-view&gt;
&lt; router-view name=&quot;img&quot; class=&quot;right&quot; &gt;&lt; /router-view&gt;
</code></pre><h4 id="路由过渡"><a href="#路由过渡" class="headerlink" title="路由过渡"></a>路由过渡</h4><p>切换路由时有动画效果</p>
<pre><code>&lt; transition name=&quot;show&quot; &gt;
    &lt; router-view name=&quot;login&quot; &gt;&lt; /router-view &gt;
&lt; /transition&gt;


.show-enter-active {
  transition: all .3s ease;
}

.show-leave-active {
  transition: all .2s ease-in;
}


.show-enter, .show-leave-active {
  transform: translateX(200px);
  opacity: 0;
}





api，组件

&lt; router-link &gt;&lt; /router-link &gt;
this.$router.push({path: &#39;&#39;})
&lt; router-view &gt;&lt; /router-view &gt;
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>
router 
    index.js

import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
const GoodList = resolve =&gt; require([&#39;../views/GoodList.vue&#39;], resolve)

Vue.use(Router)


Vue.use(Router)

const routes = [
    {
      path: &#39;/goods/:goodsId/user/:name&#39;,
      name: &#39;GoodList&#39;,
      component: GoodList
    }
]


const router =  new Router({
  routes
})

export default router

export {
    router,
    routes
}



main.js

    import Vue from &#39;vue&#39;
    import App from &#39;./App&#39;
    import router from &#39;./router&#39;

new Vue({
    el: &#39;#app&#39;,
    router,
    render: h =&gt; h(App)
})
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Vue-Router 文档 </strong>: <a href="https://router.vuejs.org/zh-cn/index.html" target="_blank" rel="external">https://router.vuejs.org/zh-cn/index.html</a></p>
]]></content>
    
    <summary type="html">
    
      vue-router 入门简单介绍
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://ldqblog.me/tags/Vue/"/>
    
      <category term="Vue-Router" scheme="http://ldqblog.me/tags/Vue-Router/"/>
    
  </entry>
  
  <entry>
    <title>Vue 简介</title>
    <link href="http://ldqblog.me/2017/06/06/Vue-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/06/06/Vue-简介/</id>
    <published>2017-06-06T14:46:11.000Z</published>
    <updated>2017-10-12T15:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-简介"><a href="#Vue-简介" class="headerlink" title="Vue 简介"></a>Vue 简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Vue 是一套构建用户界面的渐进式 MVVM 框架<br>Vue 的核心库只关注视图层，将路由交给 Vue-Router ，状态管理交给 Vuex </p>
</blockquote>
<h3 id="核心概念和关键词"><a href="#核心概念和关键词" class="headerlink" title="核心概念和关键词"></a>核心概念和关键词</h3><p>template<br>data<br>methods<br>components </p>
<p>计算属性<br>watch</p>
<h4 id="计算属性-vs-watch"><a href="#计算属性-vs-watch" class="headerlink" title="计算属性 vs watch"></a>计算属性 vs watch</h4><blockquote>
<p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的 watcher。<br>这是为什么 Vue 通过 watch 选项提供一个更通用的方法，来响应数据的变化。<br>当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的。  </p>
</blockquote>
<p>指令<br>插件<br>生命周期<br>响应式<br>过渡<br>混合<br>过滤器</p>
<p>路由<br>状态管理<br>服务端渲染<br>单元测试</p>
<p>api<br>风格指南</p>
<p>生态</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装好 nodejs, 有命令行工具</p>
<p>在命令行工具中</p>
<pre><code>npm install -g vue-cli
vue init webpack myProject
cd myProject
npm install
npm run dev
</code></pre><p>浏览器会自动打开 <a href="http://localhost:8080/#/" target="_blank" rel="external">http://localhost:8080/#/</a>  (opn 模块)</p>
<p>写完代码</p>
<p>npm run build 构建打包</p>
<p>生成的 dist 文件夹就是要发布的文件</p>
<h4 id="用到的文件"><a href="#用到的文件" class="headerlink" title="用到的文件"></a>用到的文件</h4><p>build 和 config 文件夹</p>
<p>webpack 配置，可以自己修改</p>
<p>一般改 config/index.js 的 build assetsPublicPath，这是打包后的静态文件的路径前添加的路径<br>因为线上路径和开发路径很多时候有所不同</p>
<p>如: assetsPublicPath: ‘/vue-CNode/dist/‘</p>
<p>dev proxyTable</p>
<p>配置代理<br>用于解决开发时的跨域问题</p>
<pre><code>
proxyTable: {
      &#39;/goods&#39;: {
          target: &#39;http://localhost:3000&#39;
      },
      &#39;/goods/*&#39;: {
          target: &#39;http://localhost:3000&#39;
      },
      &#39;/users/**&#39;: {
          target: &#39;http://localhost:3000&#39;
      }
    },
</code></pre><p>src  编写代码</p>
<p>一种项目的录结构</p>
<p>   assets 静态资源<br>   Components 组件<br>   router 路由<br>   store vuex<br>   util 工具脚本<br>   views 路由组件<br>   App.vue 根组件<br>   main.js 入口文件</p>
<p>static<br>  静态资源</p>
<h4 id="assets-和-static-的区别"><a href="#assets-和-static-的区别" class="headerlink" title="assets 和 static 的区别"></a>assets 和 static 的区别</h4><p>assets：<br>一般存放开发过程中自己写的静态资源<br>（image, css, js 等，如：shop.css, car.png, roomListUtil.js）</p>
<p>static：<br>存放第三方静态资源（jquery.js, bootstrap.css 等），<br>这里的资源一般是直接引用，当打包编译后 assets 中的静态资源也会编译到 static 目录下，<br>这样原来引用 static 资源的地址也不用改变。<br>最后编译发布的时候会将所有的静态资源整合到 /dist/static/ 目录下，当然也可以自定义其他路径。</p>
<p>index.html<br>    模板 HTML 文件 </p>
<h4 id="Vue-的页面架构流程"><a href="#Vue-的页面架构流程" class="headerlink" title="Vue 的页面架构流程"></a>Vue 的页面架构流程</h4><p><img src="http://upload-images.jianshu.io/upload_images/3563580-ddbf4fee1d6de4c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vue.png"></p>
<h3 id="独立构建-运行时构建"><a href="#独立构建-运行时构建" class="headerlink" title="独立构建 运行时构建"></a>独立构建 运行时构建</h3><p>一、独立构建包含模板编译器，运行时构建不包含模板编译器。<br>二、模板编译器的作用就是将 template 选项编译成 render 函数，render 函数是渲染的关键。<br>三、鉴于以上两点，使用运行时构建时，不能出现 template 选项，因为此时没有模板编译器。<br>但是有一种情况除外：即 webpack+vue-loader 情况下单文件组件中出现 template 是可以的。<br>四、使用 vue-cli 生成项目时，会提醒使用哪种构建方式，npm 包默认导出的是运行时构建，<br>如果需要使用独立构建，需要在 webpack 中配置 alias(设置 alias 为 vue.common.js)<br>五、目前暂时发现的两者的应用场景上的区别有：</p>
<p>需要注意 Vue 实例化时的方式，运行时构建方式下实例化 Vue 时，不要出现 template 属性<br>index.html 中不要出现 template 或者是通过 vue-router 渲染的 route-view</p>
<p>运行时构建一定要 render 函数</p>
<pre><code>new Vue({
    el: &#39;#app&#39;,
    render: h =&gt; h(App)
})


独立构建，是指可以在 html 里放置模板，并在 Vue 实例选项中通过 el 指定模板元素（同时也是挂载元素）
</code></pre><h2 id="框架对比"><a href="#框架对比" class="headerlink" title="框架对比"></a>框架对比</h2><h4 id="Vue-和-React-的共同点"><a href="#Vue-和-React-的共同点" class="headerlink" title="Vue 和 React 的共同点"></a>Vue 和 React 的共同点</h4><p>使用 Virtual DOM<br>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件<br>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库</p>
<h4 id="Vue-的优势"><a href="#Vue-的优势" class="headerlink" title="Vue 的优势"></a>Vue 的优势</h4><p>在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，<br>所以系统能精确知晓哪个组件确实需要被重渲染。<br>React 由于 发生变化时会重新渲染整个组件树，所以需要做一些额外的优化工作<br>(PureComponent shouldComponentUpdate Immutable Reselect)</p>
<p>vue 的 template 模板就是 HTML 写法，比起 jsx 更容易编写和理解</p>
<p>vue 在每个单文件组件中可以访问自己独立的 css module，<br>在 style 标签里添加一个属性 scoped，不会污染全局</p>
<p>vue 提供大量的指令来简化开发中的重复劳动<br>如：v-for 可以构建循环，在 React 中要自己写（使用 map 构建）</p>
<p>Vue 设置样式的默认方法是单文件组件里类似 style 的标签</p>
<h4 id="Vue-的劣势"><a href="#Vue-的劣势" class="headerlink" title="Vue 的劣势"></a>Vue 的劣势</h4><p>生态比不上 React</p>
<p>在原生开发中，Weex 还没有 React Native 成熟</p>
<h4 id="Vue-与-Angular1"><a href="#Vue-与-Angular1" class="headerlink" title="Vue 与 Angular1"></a>Vue 与 Angular1</h4><p>在 API 与设计两方面上 Vue.js 都比 AngularJS 简单得多</p>
<p>Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，<br>而不是在任何时候都必须遵循 AngularJS 制定的规则，这让 Vue 能适用于各种项目。</p>
<p>AngularJS 使用双向绑定，Vue 在不同组件间强制使用单向数据流。<br>这使应用中的数据流更加清晰易懂。</p>
<p>在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，<br>而组件代表一个自给自足的独立单元——有自己的视图和数据逻辑。<br>在 AngularJS 中两者有不少相混的地方。</p>
<p>Vue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。</p>
<h4 id="Vue-与-Angular2"><a href="#Vue-与-Angular2" class="headerlink" title="Vue 与 Angular2"></a>Vue 与 Angular2</h4><p>Vue 和 TS 的整合可能不如 Angular 那么深入<br>在中小型规模的项目中，引入 TS 可能并不会带来太多明显的优势。<br>在这些情况下，用 Vue 会是更好的选择，<br>因为在不用 TS 的情况下使用 Angular 会很有挑战性。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Vue 文档 </strong>: <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="external">https://cn.vuejs.org/v2/guide/</a></p>
]]></content>
    
    <summary type="html">
    
      Vue 入门简单介绍
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://ldqblog.me/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>test description</title>
    <link href="http://ldqblog.me/2017/02/02/test-description/"/>
    <id>http://ldqblog.me/2017/02/02/test-description/</id>
    <published>2017-02-02T13:06:49.000Z</published>
    <updated>2017-07-31T19:56:44.270Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>在 scaffolds/post.md 文件中添加 description</li>
</ul>
<pre><code>$(window).load(function(){
 $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);
   prettyPrint();
 })
</code></pre>]]></content>
    
    <summary type="html">
    
      测试decription
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://ldqblog.me/2017/01/17/hello-world/"/>
    <id>http://ldqblog.me/2017/01/17/hello-world/</id>
    <published>2017-01-17T09:48:44.039Z</published>
    <updated>2017-07-31T15:42:45.080Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      官方自带的Hello World
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>photoTest</title>
    <link href="http://ldqblog.me/2017/01/13/photoTest/"/>
    <id>http://ldqblog.me/2017/01/13/photoTest/</id>
    <published>2017-01-13T08:30:23.000Z</published>
    <updated>2017-08-01T15:54:00.862Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>测试图片功能</li>
</ul>
<p><img src="http://otyr3ojiw.bkt.clouddn.com/blog/170801/GgD6FJfKF9.jpeg?imageslim" alt="photos-0.jpg"><br><img src="http://otyr3ojiw.bkt.clouddn.com/blog/170801/7L37AEEbdj.jpg?imageslim" alt="photos-1.jpg"></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;测试图片功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://otyr3ojiw.bkt.clouddn.com/blog/170801/GgD6FJfKF9.jpeg?imageslim&quot; alt=&quot;photos-0.jpg&quot;&gt;&lt;br&gt;&lt;img 
    
    </summary>
    
      <category term="test" scheme="http://ldqblog.me/categories/test/"/>
    
      <category term="图片" scheme="http://ldqblog.me/categories/test/%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="test" scheme="http://ldqblog.me/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>第一篇 Hexo 文章</title>
    <link href="http://ldqblog.me/2016/11/05/%E7%AC%AC%E4%B8%80%E7%AF%87Hexo%E6%96%87%E7%AB%A0/"/>
    <id>http://ldqblog.me/2016/11/05/第一篇Hexo文章/</id>
    <published>2016-11-05T06:19:23.000Z</published>
    <updated>2017-07-31T18:03:00.747Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>第一次写 Hexo 博客</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;第一次写 Hexo 博客&lt;/li&gt;
&lt;/ul&gt;

    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="hexo" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/hexo/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="hexo" scheme="http://ldqblog.me/tags/hexo/"/>
    
  </entry>
  
</feed>
