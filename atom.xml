<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LDQ的博客</title>
  <subtitle>前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ldqblog.me/"/>
  <updated>2017-10-12T09:14:53.000Z</updated>
  <id>https://ldqblog.me/</id>
  
  <author>
    <name>ldq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript 入门</title>
    <link href="https://ldqblog.me/2017/08/12/TypeScript-%E5%85%A5%E9%97%A8/"/>
    <id>https://ldqblog.me/2017/08/12/TypeScript-入门/</id>
    <published>2017-08-12T07:13:38.000Z</published>
    <updated>2017-10-12T09:14:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-入门"><a href="#TypeScript-入门" class="headerlink" title="TypeScript 入门"></a>TypeScript 入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 是一门弱类型语言，没有类型检测，这让 JavaScript 很灵活，但也更容易出错</p>
<blockquote>
<p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。  </p>
</blockquote>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><blockquote>
<p>官网<br><a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a><br>中文文档<br><a href="https://www.tslang.cn/index.html" target="_blank" rel="external">tslang</a><br>查看编译后的结果<br><a href="http://www.typescriptlang.org/play/index.html" target="_blank" rel="external">typescriptlang</a></p>
</blockquote>
<h2 id="很多项目开始使用-TypeScript"><a href="#很多项目开始使用-TypeScript" class="headerlink" title="很多项目开始使用 TypeScript"></a>很多项目开始使用 TypeScript</h2><blockquote>
<p>Angular</p>
<div class="github-widget" data-repo="angular/angular"></div>

<p>VSCode</p>
<div class="github-widget" data-repo="Microsoft/vscode"></div>

<p>RxJS</p>
<div class="github-widget" data-repo="Reactive-Extensions/RxJS"></div>

</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install -g typescript
</code></pre><h3 id="安装完后运行-tsc-v-查看是否正确安装"><a href="#安装完后运行-tsc-v-查看是否正确安装" class="headerlink" title="安装完后运行 tsc -v 查看是否正确安装"></a>安装完后运行 tsc -v 查看是否正确安装</h3><pre><code>tsc -v
Version 2.4.2
</code></pre><h3 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h3><p>tsc -h 或 tsc –help 查看帮助</p>
<pre><code>$ tsc -h
Version 2.4.2
Syntax:  tsc [options] [file ...]

Examples: tsc hello.ts
          tsc --outFile file.js file.ts
          tsc @args.txt
Options:
...
</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>生成默认的配置文件 tsconfig.json</p>
<pre><code>tsc init
</code></pre><ul>
<li>配置 es6</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-084ac9734f4aceab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="支持-TypeScript-的文本编辑器和-IDE"><a href="#支持-TypeScript-的文本编辑器和-IDE" class="headerlink" title="支持 TypeScript 的文本编辑器和 IDE"></a>支持 TypeScript 的文本编辑器和 IDE</h3><p>通过本身或插件支持 TypeScript 的语法、智能提示、纠错等</p>
<ul>
<li>VSCode 微软开发的轻量级编辑器，内置支持 TypeScript</li>
<li>Sublime Text 有相关插件</li>
<li>WebStorm 新版内置支持 TypeScript</li>
<li>其他包括 Vim，Atom，Emacs 等</li>
</ul>
<h3 id="将-TypeScrip-编译成-JavaScript"><a href="#将-TypeScrip-编译成-JavaScript" class="headerlink" title="将 TypeScrip 编译成 JavaScript"></a>将 TypeScrip 编译成 JavaScript</h3><p>TypeScript 的文件类型是. ts 文件或 JSX 中的. tsx 文件，不能直接运行在浏览器中，需要编译成. js 文件</p>
<p>方法：</p>
<ol>
<li><p>用命令行工具进行编译</p>
<pre><code>
Syntax:  tsc [options] [file ...]

Examples: tsc hello.ts

        tsc --outFile file.js file.ts

        tsc @args.txt
</code></pre><p>最后一个的作用是从一个文件中插入命令行选项和文件</p>
<pre><code>
@&lt;file&gt;    Insert command line options and files from a file.
</code></pre></li>
<li><p>在 VSCode 或其他文本编辑器和 IDE 上操作</p>
</li>
<li><p>使用自动化构建工具，如 gulp， webpack 等</p>
</li>
</ol>
<h3 id="介绍一下第一种方法"><a href="#介绍一下第一种方法" class="headerlink" title="介绍一下第一种方法"></a>介绍一下第一种方法</h3><p>下面的命令行把 TypeScript 文件 main.ts 编译为 JavaScript 版本的 main.js。如果 main.js 已经存在的话会被覆盖。</p>
<pre><code>    tsc main.ts
</code></pre><p>可以同时编译多个文件</p>
<pre><code>tsc main.ts other.ts

tsc *.ts
</code></pre><p>还可以通过 –watch 或 - w 来自动编译 (修改后能自动转成. js 文件)</p>
<pre><code>tsc main.ts --watch
</code></pre><h3 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h3><p>TypeScript 可以声明变量类型，这样编译器就可以确保赋值时不会产生类型错误<br>如果省略了类型声明，TypeScript 将会从代码中自动推测出正确的类型。</p>
<p>在变量，函数声明时可以定义自己的类型</p>
<pre><code>var burger: string = &#39;hamburger&#39;,    // String 
    calories: number = 300,          // Numeric
    tasty: boolean = true;            // Boolean

function speak(food: string, energy: number): void {
  console.log(&quot;Our&quot; + food + &quot;has&quot; + energy + &quot;calories.&quot;);
}

speak(burger, calories);
</code></pre><p>编译后变量声明都会被移除</p>
<pre><code>var burger = &#39;hamburger&#39;,
    calories = 300, 
    tasty = true; 

function speak(food, energy) {
    console.log(&quot;Our&quot; + food + &quot;has&quot; + energy + &quot;calories.&quot;);
}

speak(burger, calories);
</code></pre><p>如果输入的类型有错，TypeScript 会有代码警告<br>但还是会转成 js 文件</p>
<p>ts 文件</p>
<pre><code>var carNum: Number = &#39;10&#39;
</code></pre><pre><code>$ tsc err.ts --watch
err.ts(1,5): error TS2322: Type &#39;&quot;10&quot;&#39; is not assignable to type &#39;Number&#39;.
10:36:46 - Compilation complete. Watching for file changes.
</code></pre><p>js 文件</p>
<pre><code>var carNum = &#39;10&#39;;
</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>Number ( 数值 ) - 包括整型，浮点型等</li>
</ul>
<pre><code>let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
</code></pre><ul>
<li>String （字符串）- 包括单双引号的字符串</li>
</ul>
<pre><code>let color: string = &quot;blue&quot;;
color = &#39;red&#39;;
let sentence: string = `Hello, my name is ${ fullName }.
I&#39;ll be ${ age + 1 } years old next month.`;
</code></pre><ul>
<li>Boolean （布尔）- true ,false, 不可用其他类型如数字, 空字符串，否则会报错 </li>
</ul>
<pre><code>let isDone: boolean = false
</code></pre><ul>
<li>Array （数组）- 有两种语法：my_arr: number[ ] 或者 my_arr: Array<number></number></li>
</ul>
<pre><code>let list: number[] = [1, 2, 3]

let list: Array&lt;number&gt; = [1, 2, 3]
</code></pre><ul>
<li>Tuple ( 元组 ) - 数组中包含不同的类型，有顺序</li>
</ul>
<pre><code>let x: [string, number];
x = [&quot;hello&quot;, 10]; // OK
x = [10, &quot;hello&quot;]; // Error
</code></pre><p>使用不是该数据类型的方法会报错</p>
<pre><code>console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, &#39;number&#39; does not have &#39;substr&#39;
</code></pre><p>新赋值的类型必须是定义时规定的类型</p>
<pre><code>x[3] = &quot;world&quot;; // OK, &#39;string&#39; can be assigned to &#39;string | number&#39;

console.log(x[5].toString()); // OK, &#39;string&#39; and &#39;number&#39; both have &#39;toString&#39;

x[6] = true; // Error, &#39;boolean&#39; isn&#39;t&#39;string | number&#39;
</code></pre><ul>
<li>Enum （枚举类型）- 它用于声明一组命名的常数，当一个变量有几种可能的取值时，可以将它定义为枚举类型。</li>
</ul>
<p>让代码更有语义化, 可读性</p>
<pre><code>enum Color {Red, Green, Blue}
let c: Color = Color.Green;
</code></pre><p>枚举类型的数字默认从 0 开始，可以自己设置</p>
<pre><code>enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;

enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;
</code></pre><p>当不知道 enum 类型的第 N 项是什么名称时，可以用 N 来代替</p>
<pre><code>enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

alert(colorName);
</code></pre><pre><code>var Color;
(function (Color) {
    Color[Color[&quot;Red&quot;] = 1] = &quot;Red&quot;;
    Color[Color[&quot;Green&quot;] = 2] = &quot;Green&quot;;
    Color[Color[&quot;Blue&quot;] = 3] = &quot;Blue&quot;;
})(Color || (Color = {}));
var colorName = Color[2];
alert(colorName);
</code></pre><ul>
<li>Any （任意）- 任何类型都可以（Never 类型除外）</li>
</ul>
<p>关闭类型检查</p>
<pre><code>let notSure: any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false; // okay, definitely a boolean
</code></pre><pre><code>let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn&#39;t check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property &#39;toFixed&#39; doesn&#39;t exist on type&#39;Object&#39;.
</code></pre><pre><code>let list: any[] = [1, true, &quot;free&quot;];

list[1] = 100;
</code></pre><ul>
<li>Void （空）- 用在不返回任何值的函数中</li>
</ul>
<pre><code>function warnUser(): void {
    alert(&quot;This is my warning message&quot;);
}
</code></pre><p>可以用来标识 undefined 和 null</p>
<pre><code>let unusable: void = undefined;
</code></pre><ul>
<li>Null and Undefined</li>
</ul>
<pre><code>let u: undefined = undefined;
let n: null = null;
</code></pre><p>默认为其他类型的亚类型，就是可以匹配其他类型<br>使用 –strictNullChecks 标识，就只匹配 null 、undefined、void<br>可以使用 string | null | undefined 类型来只匹配 string 、 null 、 undefined 三种类型</p>
<blockquote>
<p>官方鼓励使用 –strictNullChecks</p>
</blockquote>
<ul>
<li>Never - 表示值从未发生</li>
</ul>
<p>Any 类型不能匹配 Never</p>
<pre><code>// Function returning never must have unreachable end point
function error(message: string): never {
    throw new Error(message);
}

// Inferred return type is never
function fail() {
    return error(&quot;Something failed&quot;);
}

// Function returning never must have unreachable end point
function infiniteLoop(): never {
    while (true) {
    }
}
</code></pre><ul>
<li>Type assertions</li>
</ul>
<p>“angle-bracket” syntax</p>
<pre><code>let someValue: any = &quot;this is a string&quot;;

let strLength: number = (&lt;string&gt;someValue).length;
</code></pre><p>as -syntax</p>
<pre><code>let someValue: any = &quot;this is a string&quot;;

let strLength: number = (someValue as string).length;
</code></pre><p>一般情况下，两种写法等价，但在 JSX 中，只能用 as -style</p>
<blockquote>
<p>官方文档中关于数据类型的介绍 <a href="http://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="external">Basic Types</a></p>
</blockquote>
<h3 id="Interfaces-接口"><a href="#Interfaces-接口" class="headerlink" title="Interfaces 接口"></a>Interfaces 接口</h3><p>接口会根据一个对象是否符合某种特定的数据结构来进行类型检查</p>
<p>只在开发是有效，编译后删除</p>
<pre><code>interface Food {
    name: string;
    calories: number;
}

function speak(food: Food): void{
  console.log(&quot;Our&quot; + food.name + &quot;has&quot; + food.calories + &quot;calories.&quot;);
}

var ice_cream = {
  name: &quot;ice cream&quot;, 
  calories: 200
}

speak(ice_cream);
</code></pre><p>属性的顺序并不重要。我们只需必要的属性存在并且是正确的类型。如果哪里有遗漏，类型错误，或者命名不同的话，编译器都会报警告信息。</p>
<pre><code>interface Food {
    name: string;
    calories: number;
}

function speak(food: Food): void{
  console.log(&quot;Our&quot; + food.name + &quot;has&quot; + food.calories + &quot;grams.&quot;);
}

// 将 name 改为 nmae
var ice_cream = {
  nmae: &quot;ice cream&quot;, 
  calories: 200
}

speak(ice_cream);
</code></pre><pre><code>main.ts(16,7): error TS2345: Argument of type &#39;{ nmae: string; calories: number; } 
is not assignable to parameter of type &#39;Food&#39;. 
Property &#39;name&#39; is missing in type &#39;{ nmae: string; calories: number; }&#39;.
</code></pre><p>接口可以在属性后面添加？表示可选<br>可以添加 [propName:  类型] : any 表示可以添加任何某种类型的属性</p>
<pre><code>interface Person {    name: string;
    age?: number;
    [propName: string]: any;
}

const preson: Person = { name: &#39;Tom&#39;, age: 20}
const student: Person = { name: &#39;Tom&#39;}
</code></pre><ul>
<li>类实现接口</li>
</ul>
<p>关键字 implements</p>
<pre><code>interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre><pre><code>interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
</code></pre><blockquote>
<p>官方文档有更详细的介绍 <a href="http://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="external">interfaces</a></p>
</blockquote>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>包括了构造器、继承，抽象类，接口，构造函数、setters、getters、public、private、protected、readonly、static 等</p>
<p>ES6 中也有实现</p>
<ul>
<li>属性<br>默认为 public<br>private 只有自己可以用<br>protected 自己和子类可用<br>readonly 只读 (原理 object.freeze)</li>
<li>抽象类 不能实例化</li>
</ul>
<p>实现继承</p>
<pre><code>class Menu {
  // Our properties:
  // By default they are public, but can also be private or protected.
  items: Array&lt;string&gt;;  // The items in the menu, an array of strings.
  pages: number;        // How many pages will the menu be, a number.

  constructor(item_list: Array&lt;string&gt;, total_pages: number) {
    // The this keyword is mandatory.
    this.items = item_list;    
    this.pages = total_pages;
  }

  // Methods
  list(): void {
    console.log(&quot;Our menu for today:&quot;);
    for(var i=0; i&lt;this.items.length; i++) {
      console.log(this.items[i]);
    }
  }

} 

// Create a new instance of the Menu class.
var sundayMenu = new Menu([&quot;pancakes&quot;,&quot;waffles&quot;,&quot;orange juice&quot;], 1);

// Call the list method.
sundayMenu.list();
</code></pre><pre><code>class HappyMeal extends Menu {
  // Properties are inherited

  // A new constructor has to be defined.
  constructor(item_list: Array&lt;string&gt;, total_pages: number) {
    // In this case we want the exact same constructor as the parent class (Menu), 
    // To automatically copy it we can call super() - a reference to the parent&#39;s constructor.
    super(item_list, total_pages);
  }

  // Just like the properties, methods are inherited from the parent.
  // However, we want to override the list() function so we redefine it.
  list(): void{
    console.log(&quot;Our special menu for children:&quot;);
    for(var i=0; i&lt;this.items.length; i++) {
      console.log(this.items[i]);
    }

  }
}

// Create a new instance of the HappyMeal class.
var menu_for_children = new HappyMeal([&quot;candy&quot;,&quot;drink&quot;,&quot;toy&quot;], 1);

// This time the log message will begin with the special introduction.
menu_for_children.list();
</code></pre><blockquote>
<p>阅读官方文档，获得更多信息 <a href="http://www.typescriptlang.org/docs/handbook/classes.html" target="_blank" rel="external">classes</a></p>
</blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p>
<pre><code>function genericFunc&lt;T&gt;(argument: T): T[] {    
  var arrayOfT: T[] = [];    // Create empty array of type T.
  arrayOfT.push(argument);  // Push, now arrayOfT = [argument].
  return arrayOfT;
}

var arrayFromString = genericFunc&lt;string&gt;(&quot;beep&quot;);
console.log(arrayFromString[0]);        // &quot;beep&quot;
console.log(typeof arrayFromString[0])  // String

var arrayFromNumber = genericFunc(42);
console.log(arrayFromNumber[0]);        // 42
console.log(typeof arrayFromNumber[0])  // number
</code></pre><ul>
<li>带泛型的函数类型</li>
</ul>
<pre><code>let f: () =&gt; any = function() {}

let f: &lt;T&gt;(arg: T) =&gt; T = function() {}
</code></pre><ul>
<li>带泛型的接口</li>
</ul>
<pre><code>interface Gen&lt;T&gt; {    (arg: T) : T
}

function fn&lt;T&gt;(arg: T): T {
    return arg;
}

let id: Gen&lt;number&gt; = fn;

Gen(2)
</code></pre><ul>
<li>带泛型的类 </li>
</ul>
<pre><code>class Gen&lt;T&gt; {    value: T
    add: (x: T, y: T) =&gt; T
}

let myGenNum = new Gen&lt;number&gt;()

myGenNum.value = 0
myGenNum.add = (x, y) =&gt; x + y

myGenNum.add(2,3)
</code></pre><ul>
<li>泛型约束</li>
</ul>
<pre><code>interface Length {    
    length: number
}

function fn&lt;T extends Length&gt;(arg: T): T {
    console.log(arg.length)
    return arg
}

fn&lt;string&gt;(&quot;hello&quot;)
</code></pre><blockquote>
<p>官方文档介绍了更多关于泛型类，泛型类与接口绑定等例子<br><a href="http://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="external">generics</a></p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code>function add(x: number, y: number): number {
    return x + y;
}

let myAdd = function(x: number, y: number): number { return x+y; };
</code></pre><ul>
<li>箭头函数</li>
</ul>
<pre><code>// myAdd has the full function type
let myAdd = function(x: number, y: number): number { return  x + y; };

// The parameters &#39;x&#39; and &#39;y&#39; have the type number
let myAdd: (baseValue:number, increment:number) =&gt; number =
    function(x, y) { return x + y; };
</code></pre><p>参数可选</p>
<pre><code>function buildName(firstName: string, lastName?: string) {
    // ...
}
</code></pre><p>剩余参数</p>
<pre><code>function buildName(firstName: string, ...restOfName: string[]) {
    return firstName + &quot;&quot; + restOfName.join(&quot; &quot;);
}

let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;);
</code></pre><blockquote>
<p>官方文档 <a href="http://www.typescriptlang.org/docs/handbook/functions.html" target="_blank" rel="external">functions</a></p>
</blockquote>
<h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><ul>
<li>联合</li>
</ul>
<pre><code>function padLeft(value: string, padding: string | number) {
    // ...
}

let indentedString = padLeft(&quot;Hello world&quot;, true); // errors during compilation
</code></pre><blockquote>
<p>官方文档 <a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html" target="_blank" rel="external">Advanced Types</a></p>
</blockquote>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>如：require.js （AMD 规范）</p>
<p>exporter.ts</p>
<pre><code>var sayHi = function(): void {
    console.log(&quot;Hello!&quot;);
}

export = sayHi;
</code></pre><p>importer.ts</p>
<pre><code>import sayHi = require(&#39;./exporter&#39;);
sayHi();
</code></pre><p>引入 require.js，查看官方文档 <a href="http://requirejs.org/docs/start.html#add" target="_blank" rel="external">requirejs</a></p>
<pre><code>tsc --module amd *.ts
</code></pre><blockquote>
<p>更多模块化的内容，可查看官方文档 <a href="http://www.typescriptlang.org/docs/handbook/modules.html" target="_blank" rel="external">modules</a></p>
</blockquote>
<h3 id="第三方声明文件"><a href="#第三方声明文件" class="headerlink" title="第三方声明文件"></a>第三方声明文件</h3><p>声明文件用来是说明第三方 JavaScript 库是否和 TypeScript 兼容<br>一个声明文件包含. d.ts 扩展名和关于该库的多种信息，还有 API</p>
<p>声明文件通常是手写的，但也可以用其他人写好的<br><a href="http://definitelytyped.org/" target="_blank" rel="external">DefinitelyTyped</a></p>
<ul>
<li>The repository for high quality TypeScript type definitions<br>也有一个用来管理 TypeScript 定义的 Node.js 流行模块，叫 Typings。</li>
</ul>
<blockquote>
<p>官方文档 <a href="http://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="external">introduction</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong> 三十分钟学会 TypeScript</strong>: <a href="http://web.jobbole.com/87535/" target="_blank" rel="external">http://web.jobbole.com/87535/</a><br><strong> 官方文档 </strong>: <a href="http://www.typescriptlang.org/docs/home.html" target="_blank" rel="external">http://www.typescriptlang.org/docs/home.html</a><br><strong> 中文文档 </strong>: <a href="https://www.tslang.cn/index.html" target="_blank" rel="external">https://www.tslang.cn/index.html</a></p>
]]></content>
    
    <summary type="html">
    
      TypeScript 入门
    
    </summary>
    
      <category term="技术" scheme="https://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="TypeScript" scheme="https://ldqblog.me/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Koa 入门</title>
    <link href="https://ldqblog.me/2017/08/10/Koa-%E5%85%A5%E9%97%A8/"/>
    <id>https://ldqblog.me/2017/08/10/Koa-入门/</id>
    <published>2017-08-10T05:56:00.000Z</published>
    <updated>2017-08-10T06:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Koa-入门"><a href="#Koa-入门" class="headerlink" title="Koa 入门"></a>Koa 入门</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><blockquote>
<p>Node 版本必须 7.6 以上</p>
</blockquote>
<p>克隆代码库</p>
<blockquote>
<p>git clone <a href="https://github.com/ruanyf/koa-demos.git" target="_blank" rel="external">https://github.com/ruanyf/koa-demos.git</a></p>
</blockquote>
<h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><h3 id="1-开启-HTTP-服务器"><a href="#1-开启-HTTP-服务器" class="headerlink" title="1 开启 HTTP 服务器"></a>1 开启 HTTP 服务器</h3><pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

app.listen(3000);
</code></pre><h3 id="2-Context-对象"><a href="#2-Context-对象" class="headerlink" title="2 Context 对象"></a>2 Context 对象</h3><p>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
    ctx.response.body = &#39;Hello World&#39;;
};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-32b69cd94b58aced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>ctx.response 代表 HTTP Response<br>ctx.request 代表 HTTP Request</p>
<h3 id="3-response-类型"><a href="#3-response-类型" class="headerlink" title="3 response 类型"></a>3 response 类型</h3><p>Koa 默认的返回类型是 text/plain</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-cec6dc9a5a3d7674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>ctx.request.accepts 用来判断客户端希望接受什么数据<br>ctx.response.type 指定返回类型</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

if (ctx.request.accepts(&#39;xml&#39;)) {

    ctx.response.type = &#39;xml&#39;;

    ctx.response.body = &#39;&lt;data&gt;Hello World&lt;/data&gt;&#39;;

} else if (ctx.request.accepts(&#39;json&#39;)) {

    ctx.response.type = &#39;json&#39;;

    ctx.response.body = { data: &#39;Hello World&#39; };

} else if (ctx.request.accepts(&#39;html&#39;)) {

    ctx.response.type = &#39;html&#39;;

    ctx.response.body = &#39;&lt;p&gt;Hello World&lt;/p&gt;&#39;;

} else {

    ctx.response.type = &#39;text&#39;;

    ctx.response.body = &#39;Hello World&#39;;

}

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-83caa8dd754ae06e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-df6ccc66b21c55da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-0d84b50c0498d5dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-读取模板文件"><a href="#4-读取模板文件" class="headerlink" title="4 读取模板文件"></a>4 读取模板文件</h3><pre><code>const fs = require(&#39;fs&#39;);
const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

ctx.response.type = &#39;html&#39;;

ctx.response.body = fs.createReadStream(&#39;./demos/template.html&#39;);

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-6cfaa24a42e6277d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="二、路由"><a href="#二、路由" class="headerlink" title="二、路由"></a>二、路由</h2><h3 id="1-原生路由"><a href="#1-原生路由" class="headerlink" title="1 原生路由"></a>1 原生路由</h3><p>ctx.request.path<br>可获取用户请求的路径</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

if (ctx.request.path !== &#39;/&#39;) {

ctx.response.type = &#39;html&#39;;

ctx.response.body = &#39;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&#39;;

} else {

        ctx.response.body = &#39;Hello World&#39;;

}

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-efda28165ef1c82e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-6e9b906b2762e116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-koa-router"><a href="#2-koa-router" class="headerlink" title="2 koa-router"></a>2 koa-router</h3><p>route.get(path, callback)<br>callback 指定 ctx.response.type 和 ctx,response.body</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const route = require(&#39;koa-route&#39;);
const app = new Koa();

const about = ctx =&gt; {

ctx.response.type = &#39;html&#39;;

ctx.response.body = &#39;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&#39;;

};

const main = ctx =&gt; {
        ctx.response.body = &#39;Hello World&#39;;
};

app.use(route.get(&#39;/&#39;, main));
app.use(route.get(&#39;/about&#39;, about));

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-6ba08211d1b585a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-ae9d621c3e1b02a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-6e274232aaba6562.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-52627f567dc12140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="3-静态资源"><a href="#3-静态资源" class="headerlink" title="3 静态资源"></a>3 静态资源</h3><p>koa-static 处理静态资源</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();
const path = require(&#39;path&#39;);
const serve = require(&#39;koa-static&#39;);

const main = serve(path.join(__dirname));

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-51fc1d1d22dd591b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-c10a8f130e9bef9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-32fb0ac20d841137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-302-重定向"><a href="#4-302-重定向" class="headerlink" title="4 302 重定向"></a>4 302 重定向</h3><p>ctx.response.redirect()</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const route = require(&#39;koa-route&#39;);
const app = new Koa();

const redirect = ctx =&gt; {
    ctx.response.redirect(&#39;/&#39;);
};

const main = ctx =&gt; {
    ctx.response.body = &#39;Hello World&#39;;
};

app.use(route.get(&#39;/&#39;, main));
app.use(route.get(&#39;/redirect&#39;, redirect));

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-d49041f899983618.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="三、-中间件"><a href="#三、-中间件" class="headerlink" title="三、 中间件"></a>三、 中间件</h2><h3 id="1-logger"><a href="#1-logger" class="headerlink" title="1 logger"></a>1 logger</h3><p>打印日志</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);

ctx.response.body = &#39;Hello World&#39;;

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-e3ba60c3e0d8d612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-中间件的概念"><a href="#2-中间件的概念" class="headerlink" title="2 中间件的概念"></a>2 中间件的概念</h3><p>logger 函数就叫做 “中间件”（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use() 用来加载中间件。</p>
<p>基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的 main 也是中间件。<br>参数 context 对象， next 函数 （将执行权限交给下一个中间件）</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const logger = (ctx, next) =&gt; {

console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);

next();

}

const main = ctx =&gt; {
ctx.response.body = &#39;Hello World&#39;;
};

app.use(logger);
app.use(main);
app.listen(3000);
</code></pre><h3 id="3-中间件栈"><a href="#3-中间件栈" class="headerlink" title="3 中间件栈"></a>3 中间件栈</h3><p>多个中间件会形成一个栈结构（middle stack），以 “先进后出”（first-in-last-out）的顺序执行。</p>
<blockquote>
<ol>
<li>最外层的中间件首先执行。</li>
<li>调用 next 函数，把执行权交给下一个中间件。    </li>
<li>…  </li>
<li>最内层的中间件最后执行。  </li>
<li>执行结束后，把执行权交回上一层的中间件。  </li>
<li>…  </li>
<li>最外层的中间件收回执行权之后，执行 next 函数后面的代码。  </li>
</ol>
</blockquote>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const one = (ctx, next) =&gt; {

console.log(&#39;&gt;&gt; one&#39;);

next();

console.log(&#39;&lt;&lt; one&#39;);

}

const two = (ctx, next) =&gt; {

console.log(&#39;&gt;&gt; two&#39;);

next();

console.log(&#39;&lt;&lt; two&#39;);

}

const three = (ctx, next) =&gt; {

console.log(&#39;&gt;&gt; three&#39;);

next();

console.log(&#39;&lt;&lt; three&#39;);

}

app.use(one);
app.use(two);
app.use(three);

app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-578836fa12375529.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果没有 next，中间件就不会往内层的中间件执行 而会返回外层中间件</p>
<p>把 two 的 next 注释掉</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-5f85230c6e1857aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-异步中间件"><a href="#4-异步中间件" class="headerlink" title="4 异步中间件"></a>4 异步中间件</h3><pre><code>const fs = require(&#39;fs.promised&#39;);
const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = async function (ctx, next) {
ctx.response.type = &#39;html&#39;;
ctx.response.body = await fs.readFile(&#39;./demos/template.html&#39;, &#39;utf8&#39;);
};

app.use(main);
app.listen(3000);
</code></pre><p>async await 处理异步</p>
<h3 id="5-中间件的合成"><a href="#5-中间件的合成" class="headerlink" title="5 中间件的合成"></a>5 中间件的合成</h3><p>koa-compose 将多个中间件合并成一个</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const compose = require(&#39;koa-compose&#39;);
const app = new Koa();

const logger = (ctx, next) =&gt; {

console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);

next();

}

const main = ctx =&gt; {
    ctx.response.body = &#39;Hello World&#39;;
};

const middlewares = compose([logger, main]);

app.use(middlewares);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-022a1b9a9ed7ab00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-a2cebd71f3c7e6ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="四、错误处理"><a href="#四、错误处理" class="headerlink" title="四、错误处理"></a>四、错误处理</h2><h3 id="500-错误"><a href="#500-错误" class="headerlink" title="500 错误"></a>500 错误</h3><p>500 状态码 —— 代码运行错误</p>
<p>ctx.throw 抛出错误</p>
<p>ctx.throw(500) 抛出 500 错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
  ctx.throw(500);
};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-a8b4b900929fc3d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-5735b99604f5fe9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-759028ee17851586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-20eff4f2acbc2499.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-404-错误"><a href="#2-404-错误" class="headerlink" title="2 404 错误"></a>2 404 错误</h3><p>ctx.response.status = 404 相当于 ctx.throw(404) 返回 404 错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
  ctx.response.status = 404;
  ctx.response.body = &#39;Page Not Found&#39;;
};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-efbe181b5321d060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-feb318b8207c51a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="3-处理错误的中间件"><a href="#3-处理错误的中间件" class="headerlink" title="3 处理错误的中间件"></a>3 处理错误的中间件</h3><p>让最外层中间件负责处理所有中间件的错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const handler = async (ctx, next) =&gt; {
  try {
    await next();
  } catch (err) {
    ctx.response.status = err.statusCode || err.status || 500;
    ctx.response.body = {
      message: err.message
    };
  }
};

const main = ctx =&gt; {
  ctx.throw(500);
};

app.use(handler);
app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-b6a9a47929347e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1e9ed4f3b201c457.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-error-事件的监听"><a href="#4-error-事件的监听" class="headerlink" title="4 error 事件的监听"></a>4 error 事件的监听</h3><p>监听 error 事件也可以处理错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
  ctx.throw(500);
};

app.on(&#39;error&#39;, (err, ctx) =&gt; {
  console.error(&#39;server error&#39;, err);
});

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-5a622ff8b674cb25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-f0dd9f99ad67697b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="5-释放-error-事件"><a href="#5-释放-error-事件" class="headerlink" title="5 释放 error 事件"></a>5 释放 error 事件</h3><p>被 try … catch 捕获的错误不会触发 error 事件</p>
<p>要调用 ctx.app.emit(), 手动释放 error 事件</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const handler = async (ctx, next) =&gt; {
  try {
    await next();
  } catch (err) {
    ctx.response.status = err.statusCode || err.status || 500;
    ctx.response.type = &#39;html&#39;;
    ctx.response.body = &#39;&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;&#39;;
    ctx.app.emit(&#39;error&#39;, err, ctx);
  }
};

const main = ctx =&gt; {
  ctx.throw(500);
};

app.on(&#39;error&#39;, function(err) {
  console.log(&#39;logging error&#39;, err.message);
  console.log(err);
});

app.use(handler);
app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-7d43b2ac6e8bbf7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-506388f40095a28d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-ace175d9f131f842.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="五、Web-App-的功能"><a href="#五、Web-App-的功能" class="headerlink" title="五、Web App 的功能"></a>五、Web App 的功能</h2><h3 id="1-Cookies"><a href="#1-Cookies" class="headerlink" title="1 Cookies"></a>1 Cookies</h3><p>ctx.cookies 读写 Cookie<br>ctx.cookies.get() 获得 Cookie<br>ctx.cookies.set() 设置 Cookie</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = function(ctx) {
  const n = Number(ctx.cookies.get(&#39;view&#39;) || 0) + 1;
  ctx.cookies.set(&#39;view&#39;, n);
  ctx.response.body = n + &#39;views&#39;;
}

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-36da76974f1f7466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1dd21f5fa547ce7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-6878538e8bc07385.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>每刷新一次就会跟增加一次</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-f291e8cb41e4a452.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-fbbf9a5527cfc00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1f41e0f27dbcf93f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-表单"><a href="#2-表单" class="headerlink" title="2 表单"></a>2 表单</h3><p>Web 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。</p>
<p>koa-body 用来从 POST 请求体中提取键值对</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const koaBody = require(&#39;koa-body&#39;);
const app = new Koa();

const main = async function(ctx) {
  const body = ctx.request.body;
  if (!body.name) ctx.throw(400, &#39;.name required&#39;);
  ctx.body = { name: body.name };
};

app.use(koaBody());
app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-b1b4ea7178e40045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-5a56b2cd0f4e2c0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>POST 方法向服务器发送一个键值对，会被正确解析。如果发送的数据不正确，就会收到错误提示。</p>
<p>打开新的命令行窗口</p>
<p>输入</p>
<p>curl -X POST –data “name=Jack” localhost:3000</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1f6bd2a2ae6af739.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>curl -X POST –data “name” localhost:3000</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-bdee1f7139fdeb35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="3-文件上传"><a href="#3-文件上传" class="headerlink" title="3 文件上传"></a>3 文件上传</h3><p>koa-body 处理文件上传</p>
<pre><code>const os = require(&#39;os&#39;);
const path = require(&#39;path&#39;);
const Koa = require(&#39;koa&#39;);
const fs = require(&#39;fs&#39;);
const koaBody = require(&#39;koa-body&#39;);

const app = new Koa();

const main = async function(ctx) {
  const tmpdir = os.tmpdir();
  const filePaths = [];
  const files = ctx.request.body.files || {};

  for (let key in files) {
    const file = files[key];
    const filePath = path.join(tmpdir, file.name);
    console.log(filePath)
    const reader = fs.createReadStream(file.path);
    const writer = fs.createWriteStream(filePath);
    reader.pipe(writer);
    filePaths.push(filePath);
  }

  ctx.body = filePaths;
};

app.use(koaBody({ multipart: true }));
app.use(main);
app.listen(3000);
</code></pre><p>在新的命令行窗口输入</p>
<p>curl –form upload=@/path/to/file <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a></p>
<p>/path/to/file 替换成真实路径</p>
<p>curl –form upload=@/D:/Nodejs/other/koa-demos/demos/21.js <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-7c57a9a9333dccf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">   </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Koa 框架教程 by 阮一峰 </strong>：<a href="http://www.ruanyifeng.com/blog/2017/08/koa.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2017/08/koa.html</a></p>
]]></content>
    
    <summary type="html">
    
      参考阮一峰老师的Koa入门教程
    
    </summary>
    
      <category term="技术" scheme="https://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="node" scheme="https://ldqblog.me/tags/node/"/>
    
      <category term="Koa" scheme="https://ldqblog.me/tags/Koa/"/>
    
      <category term="后端" scheme="https://ldqblog.me/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>music video test</title>
    <link href="https://ldqblog.me/2017/07/31/music-video-test/"/>
    <id>https://ldqblog.me/2017/07/31/music-video-test/</id>
    <published>2017-07-31T13:00:43.000Z</published>
    <updated>2017-07-31T18:02:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="歌曲"><a href="#歌曲" class="headerlink" title="歌曲"></a>歌曲</h3><div class="aplayer" data-id="31673404" data-server="netease" data-type="song"></div>

<h3 id="歌单"><a href="#歌单" class="headerlink" title="歌单"></a>歌单</h3><div class="aplayer" data-id="11100236" data-server="netease" data-type="playlist" data-mode="random"></div>

<h3 id="b-站视频"><a href="#b-站视频" class="headerlink" title="b 站视频"></a>b 站视频</h3><iframe class="bilibiliVideo" src="https://www.bilibili.com/html/html5player.html?cid=5090828&aid=3227348" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

]]></content>
    
    <summary type="html">
    
      测试音乐
    
    </summary>
    
    
      <category term="music" scheme="https://ldqblog.me/tags/music/"/>
    
      <category term="video" scheme="https://ldqblog.me/tags/video/"/>
    
      <category term="test" scheme="https://ldqblog.me/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>test description</title>
    <link href="https://ldqblog.me/2017/02/02/test-description/"/>
    <id>https://ldqblog.me/2017/02/02/test-description/</id>
    <published>2017-02-02T13:06:49.000Z</published>
    <updated>2017-07-31T19:56:44.270Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>在 scaffolds/post.md 文件中添加 description</li>
</ul>
<pre><code>$(window).load(function(){
 $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);
   prettyPrint();
 })
</code></pre>]]></content>
    
    <summary type="html">
    
      测试decription
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ldqblog.me/2017/01/17/hello-world/"/>
    <id>https://ldqblog.me/2017/01/17/hello-world/</id>
    <published>2017-01-17T09:48:44.039Z</published>
    <updated>2017-07-31T15:42:45.080Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      官方自带的Hello World
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>photoTest</title>
    <link href="https://ldqblog.me/2017/01/13/photoTest/"/>
    <id>https://ldqblog.me/2017/01/13/photoTest/</id>
    <published>2017-01-13T08:30:23.000Z</published>
    <updated>2017-08-01T15:54:00.862Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>测试图片功能</li>
</ul>
<p><img src="http://otyr3ojiw.bkt.clouddn.com/blog/170801/GgD6FJfKF9.jpeg?imageslim" alt="photos-0.jpg"><br><img src="http://otyr3ojiw.bkt.clouddn.com/blog/170801/7L37AEEbdj.jpg?imageslim" alt="photos-1.jpg"></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;测试图片功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://otyr3ojiw.bkt.clouddn.com/blog/170801/GgD6FJfKF9.jpeg?imageslim&quot; alt=&quot;photos-0.jpg&quot;&gt;&lt;br&gt;&lt;img 
    
    </summary>
    
      <category term="test" scheme="https://ldqblog.me/categories/test/"/>
    
      <category term="图片" scheme="https://ldqblog.me/categories/test/%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="test" scheme="https://ldqblog.me/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>第一篇 Hexo 文章</title>
    <link href="https://ldqblog.me/2016/11/05/%E7%AC%AC%E4%B8%80%E7%AF%87Hexo%E6%96%87%E7%AB%A0/"/>
    <id>https://ldqblog.me/2016/11/05/第一篇Hexo文章/</id>
    <published>2016-11-05T06:19:23.000Z</published>
    <updated>2017-07-31T18:03:00.747Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>第一次写 Hexo 博客</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;第一次写 Hexo 博客&lt;/li&gt;
&lt;/ul&gt;

    
    </summary>
    
      <category term="技术" scheme="https://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="hexo" scheme="https://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/hexo/"/>
    
    
      <category term="hexo" scheme="https://ldqblog.me/tags/hexo/"/>
    
      <category term="前端" scheme="https://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
