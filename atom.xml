<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LDQ的博客</title>
  <subtitle>前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ldqblog.me/"/>
  <updated>2017-10-14T01:45:02.000Z</updated>
  <id>http://ldqblog.me/</id>
  
  <author>
    <name>ldq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react 生命周期</title>
    <link href="http://ldqblog.me/2017/09/26/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://ldqblog.me/2017/09/26/React-生命周期/</id>
    <published>2017-09-26T01:40:21.000Z</published>
    <updated>2017-10-14T01:45:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>每个生命周期钩子的调用例子讲解的比较详细</li>
</ul>
<p><a href="https://github.com/LDQ-first/react-lifecycle" target="_blank" rel="external">一个 react 生命周期例子</a></p>
<p><a href="https://github.com/LDQ-first/react-lifecycle" target="_blank" rel="external">源码</a></p>
<p>生命周期钩子的函数</p>
<p>React 的生命周期包括三个阶段：mount（挂载）、update（更新）和 unmount（移除）</p>
<p>mount 阶段</p>
<pre><code> constructor()   - 初始化 props 和 state
 componentWillMount() - 将要挂载了!
 render()             - 将 return 里的内容挂载到页面中
 componentDidMount()  - 挂在完了要干点什么?
</code></pre><p>update 阶段</p>
<pre><code>componentWillReceiveProps(nextProps) - 我要读取 props 啦！
shouldComponentUpdate(nextProps, nextState) - 请问要不要更新组件？true / false
componentWillUpdate() - 我要更新组件啦！
render() - 更新！
componentDidUpdate() - 更新完毕啦！
</code></pre><p>unmount 阶段</p>
<pre><code>componentWillUnmount() - 我要死啦！
</code></pre><p>setState 应该放在哪？</p>
<p>一般，我们只在这几个钩子里 setState：</p>
<pre><code>componentWillMount  -  一个组件只执行一次
componentDidMount   -  一个组件只执行一次
componentWillReceiveProps  - 每次数据更新时执行一次
</code></pre><p>因为在 componentWillUpdate 和 componentDidUpdate 里 setState 后<br>又会触发这两个钩子，最终会导致 call stack 溢出</p>
]]></content>
    
    <summary type="html">
    
      react 生命周期梳理
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://ldqblog.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 版开眼 (二)</title>
    <link href="http://ldqblog.me/2017/09/25/React%E7%89%88%E5%BC%80%E7%9C%BC-%E4%BA%8C/"/>
    <id>http://ldqblog.me/2017/09/25/React版开眼-二/</id>
    <published>2017-09-25T02:18:44.000Z</published>
    <updated>2017-10-13T05:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-版开眼技术详情"><a href="#React-版开眼技术详情" class="headerlink" title="React 版开眼技术详情"></a>React 版开眼技术详情</h1><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>配合 React-Router 4 , Redux, Immutable, Reselect 使用</p>
<p>React 层面分为路由组件（views 文件夹中）<br>和非路由组件（components 文件夹中）</p>
<p>利用 Redux 进行路由组件的状态管理，<br>利用 Redux-think（让 dispatch 接受函数做参数），<br> async/await（处理异步）<br>与 componentWillMount 等生命周期实现 api 请求</p>
<p>利用 Prop 进行路由组件和非路由组件的通信,<br>propTypes 作为 Prop 的类型检查</p>
<pre><code> static get propTypes() { 
        return { 
            location: PropTypes.obj.isRequired,
            history: PropTypes.obj.isRequired,
            match: PropTypes.obj.isRequired,
            IndexData: PropTypes.object,
            getIndexData: PropTypes.func,
            getSearchData: PropTypes.func,
        }
    }
</code></pre><p>利用 Bundle 组件实现路由异步加载（官网有示例）</p>
<p>利用 Immutable(不可变的数据结构), Reselect(避免不必要的 stroe 更新) 优化 Redux</p>
<h2 id="第三方-UI-框架"><a href="#第三方-UI-框架" class="headerlink" title="第三方 UI 框架"></a>第三方 UI 框架</h2><p>使用 Material-UI 框架中的组件<br>配合 Styled-components 使用<br>提高开发效率</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>利用 <a href="https://bird.ioliu.cn" target="_blank" rel="external">https://bird.ioliu.cn</a> 跨域</p>
<p>理由<br>    开眼 api 不支持 jsonp 跨域，<br>    第三方 API 实现 CORS 跨域，需要使用服务端<br>     <a href="https://bird.ioliu.cn" target="_blank" rel="external">https://bird.ioliu.cn</a> 简单易用</p>
<h2 id="Immutable-不可变的数据结构"><a href="#Immutable-不可变的数据结构" class="headerlink" title="Immutable(不可变的数据结构)"></a>Immutable(不可变的数据结构)</h2><p><a href="http://facebook.github.io/immutable-js/docs/#/" target="_blank" rel="external">文档</a></p>
<blockquote>
<p>Immutable.js 是一个完全独立的库，并非 React 一家独有，无论基于什么框架都可以用它。<br>弥补了 Javascript 没有不可变数据结构的问题<br>Immutable Data 是指一旦被创造后，就不可以被改变的数据<br>Immutable.js 提供了 7 种不可变的数据结构：List, Stack, Map, OrderedMap, Set, OrderedSet, Record </p>
</blockquote>
<p>在 JS 中，由于引用类型会指向同一个地址, 所以更新一个会影响其他的<br>在复杂开发中会影响性能</p>
<pre><code>a = { a: 1 }
b = a 
b.a = 10
a.a =&gt; 10
</code></pre><p>解决方法有利用浅拷贝和深拷贝的</p>
<pre><code>var  defaultObj = { /* 默认值 */}
var Obj = $.extend({}, defaultObj, initObj) // jQuery 用法。initObj 是自定义值
var Obj = $.extend(true, {}, defaultObj, initObj) // 如果对象是多层的，就用到深拷贝了
</code></pre><p>Object.assign 和 Object.freeze 是浅拷贝</p>
<p>利用 ImmutableJS</p>
<pre><code>var defaultObj = Immutable.fromJS({/* 默认值 */})
var Obj = defaultObj.merge(initObj) //defaultObj 不会改变，返回新值给 Obj
var Obj = defaultObj.mergeDeep(initObj) // 深 merge
</code></pre><p>ImmutableJS 的性能在于通过通过 structural sharing, 改变父子节点关系来更新数据<br>修改数据的时候就检查差异，不变返回原引用，有变化则直接返回一个新的引用<br>深拷贝需要递归遍历整个对象</p>
<h3 id="为什么要在-React-js-中使用-Immutable-js"><a href="#为什么要在-React-js-中使用-Immutable-js" class="headerlink" title="为什么要在 React.js 中使用 Immutable.js"></a>为什么要在 React.js 中使用 Immutable.js</h3><p>React.js 是一个 UI = f(states) 的框架，为了解决更新的问题，<br>React.js 使用了 virtual dom，virtual dom 通过 diff 修改 dom，来实现高效的 dom 更新。<br>但是当 state 更新时，如果数据没变，也会去做 virtual dom 的 diff，这就产生了浪费。</p>
<p>可以利用 PureRenderMixin，但 PureRenderMixin 只是简单的浅比较，不使用于多层比较</p>
<p>所以使用 Immutable.js 实现 Immutable Data</p>
<p><img src="http://ldqblog.me/img/Immutable/000.gif" alt="000"></p>
<h2 id="Reselect-避免不必要的-stroe-更新"><a href="#Reselect-避免不必要的-stroe-更新" class="headerlink" title="Reselect(避免不必要的 stroe 更新)"></a>Reselect(避免不必要的 stroe 更新)</h2><p>mapStateToProps 也被叫做 selector，在 store 发生变化的时候就会被调用，<br>而不管是不是 selector 关心的数据发生改变它都会被调用，<br>所以如果 selector 计算量非常大，每次更新都重新计算可能会带来性能问题。</p>
<p>Reselect 能帮你省去这些没必要的重新计算。<br>Reselect 提供 createSelector 函数来创建可记忆的 selector。</p>
<p>createSelector 接收一个 input-selectors 数组和一个转换函数作为参数。</p>
<p>如果 state tree 的改变会引起 input-selector 值变化，那么 selector 会调用转换函数，<br>传入 input-selectors 作为参数，并返回结果。</p>
<p>如果 input-selectors 的值和前一次的一样，<br>它将会直接返回前一次计算的数据，而不会再调用一次转换函数。<br>这样就可以避免不必要的计算，为性能带来提升。</p>
<pre><code>export const eyeSelector = createSelector(
    selectGolbal,
    appState =&gt; appState.get(&#39;eye&#39;)
)

export const IndexDataSelector = createSelector(
    eyeSelector,
    eyeState =&gt; {
        if(!eyeState) return
        return eyeState.get(&#39;IndexData&#39;)
    }
)


const mapStateToProps = (state) =&gt; ({
    IndexData: IndexDataSelector(state)
})


static get propTypes() { 
    return { 
        IndexData: PropTypes.object
    }
}
</code></pre><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>用于搭建 React 脚手架</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><strong>immutable.js 文档 </strong>: <a href="http://facebook.github.io/immutable-js/docs/#/" target="_blank" rel="external">http://facebook.github.io/immutable-js/docs/#/</a><br><strong>immutable.js 在 React、Redux 中的实践以及常用 API 简介 </strong>: <a href="https://yq.aliyun.com/articles/69516" target="_blank" rel="external">https://yq.aliyun.com/articles/69516</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;React-版开眼技术详情&quot;&gt;&lt;a href=&quot;#React-版开眼技术详情&quot; class=&quot;headerlink&quot; title=&quot;React 版开眼技术详情&quot;&gt;&lt;/a&gt;React 版开眼技术详情&lt;/h1&gt;&lt;h2 id=&quot;React&quot;&gt;&lt;a href=&quot;#Reac
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://ldqblog.me/tags/React/"/>
    
      <category term="SPA" scheme="http://ldqblog.me/tags/SPA/"/>
    
  </entry>
  
  <entry>
    <title>React 版开眼 (一)</title>
    <link href="http://ldqblog.me/2017/09/23/React%E7%89%88%E5%BC%80%E7%9C%BC-%E4%B8%80/"/>
    <id>http://ldqblog.me/2017/09/23/React版开眼-一/</id>
    <published>2017-09-23T02:18:35.000Z</published>
    <updated>2017-10-13T03:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-版开眼介绍"><a href="#React-版开眼介绍" class="headerlink" title="React 版开眼介绍"></a>React 版开眼介绍</h1><h2 id="预览地址"><a href="#预览地址" class="headerlink" title="预览地址"></a>预览地址</h2><p><a href="http://ldqblog.me/react-eyepetizer/dist/#/">预览地址</a></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/LDQ-first/react-eyepetizer" target="_blank" rel="external">GitHub</a></p>
<h2 id="手机可访问二维码"><a href="#手机可访问二维码" class="headerlink" title="手机可访问二维码"></a>手机可访问二维码</h2><p><img src="http://ldqblog.me/react-eyepetizer/static/img/QR/mobile.png" alt="React 版开眼"></p>
<hr>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>做 React 版开眼的原因：</p>
<pre><code>1. 学习 React 全家桶
2. 实现开眼的网页版
</code></pre><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li><strong>React 15.6</strong>: [ 前端框架 ]</li>
<li><strong>Redux 3.7</strong>: [ 状态管理, 组件通信 ] </li>
<li><strong>React-router 4.2</strong>: [ 配置路由，组件切换, 按需加载 ]</li>
<li><strong>ES6/7</strong>: [ JS 版本 ]</li>
<li><strong>Webpack</strong>: [ 模块化处理，编译打包 ]</li>
<li><strong>material-ui</strong>: [ UI 框架 ]</li>
<li><strong>Axios</strong>: [ 基于 Promise 处理 HTTP 请求 ]</li>
<li><strong>Classnames</strong>: [ 处理类名 ]</li>
<li><strong>Moment</strong>: [ 处理时间显示 ]</li>
<li><strong>Prop-types</strong>: [ 组件的 props 中的变量进行类型检测 ]</li>
<li><strong>Immutable</strong>: [ Immutable 数据化 ]</li>
<li><strong>Reselect</strong>: [ 使用缓存机制优化 state ]</li>
<li><strong>Styled-components</strong>: [ CSS in JS ]</li>
<li><strong>Redux-thunk&amp;async/await</strong>: [ redux 中间件，处理异步事件 ]</li>
<li><strong>LoaclStorge</strong>: [ 本地存储相关数据 ]</li>
</ul>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>实现了首页，发现，关注，<br>搜索，热门，分类，作者，排行榜，<br>往期精选，播放视频详情，<br>查看评论, 查看作者详情等功能</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>后端 json 数据的过滤比较繁琐，<br>考虑是否有优化方法</li>
</ul>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><a href="http://ldqblog.me/react-eyepetizer/static/result/index.gif">index</a></p>
<p><img src="http://ldqblog.me/react-eyepetizer/static/result/shortcut/index.jpg" alt="index"></p>
<p><a href="http://ldqblog.me/react-eyepetizer/static/result/hot.gif">hot</a></p>
<p><img src="http://ldqblog.me/react-eyepetizer/static/result/shortcut/hot.jpg" alt="hot"></p>
<p><a href="http://ldqblog.me/react-eyepetizer/static/result/search.gif">search</a></p>
<p><img src="http://ldqblog.me/react-eyepetizer/static/result/shortcut/search.jpg" alt="search"></p>
<p><a href="http://ldqblog.me/react-eyepetizer/static/result/detail.gif">detail</a></p>
<p><img src="http://ldqblog.me/react-eyepetizer/static/result/shortcut/detail.jpg" alt="detail"></p>
<blockquote>
<p><a href="https://github.com/LDQ-first/react-eyepetizer/tree/master/static/result" target="_blank" rel="external">更多效果图</a></p>
</blockquote>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><pre><code class="javascript">
│  index.js
├─api
├─components
│  ├─App
│  │      
│  ├─AuthorCarousel
│  │      
│  ├─AuthorHorizontal
│  │      
│  ├─AuthorInfo
│  │      
│  ├─AuthorLeftInfo
│  │      
│  ├─AuthorSingle
│  │      
│  ├─AuthorVideoInfo
│  │      
│  ├─Carousel
│  │      
│  ├─Categorys
│  │      
│  ├─DatePicker
│  │      
│  ├─DetailFooter
│  │      
│  ├─Download
│  │      
│  ├─Footer
│  │      
│  ├─GoToFeed
│  │      
│  ├─GoToTop
│  │      
│  ├─Header
│  │      
│  ├─Hot
│  │      
│  ├─Loading
│  │      
│  ├─Navigation
│  │      
│  ├─Pgcas
│  │      
│  ├─RelatedVideo
│  │      
│  ├─ReplyLists
│  │      
│  ├─ReturnIndex
│  │      
│  ├─Search
│  │      
│  ├─showQRCode
│  │      
│  ├─Tabs
│  │      
│  ├─Tags
│  │      
│  ├─TopScreen
│  │      
│  ├─Video
│  │      
│  ├─VideoArea
│  │      
│  ├─VideoHorizontal
│  │      
│  ├─VideoImg
│  │      
│  ├─VideoInfo
│  │      
│  └─VideoLists
│          
├─redux
│  │  reducers.js
│  │  store.js
│  │  
│  ├─actions
│  │      
│  ├─const
│  │      
│  └─reducer
│          
├─router
│      
├─selector
│      
├─styled
│      
├─utils
│      
└─views
    ├─Author
    │      
    ├─Detail
    │      
    ├─Feed
    │      
    ├─Find
    │      
    ├─Follow
    │      
    ├─Home
    │      
    ├─NotFound
    │      
    ├─Ranklist
    │      
    └─SearchArea
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;React-版开眼介绍&quot;&gt;&lt;a href=&quot;#React-版开眼介绍&quot; class=&quot;headerlink&quot; title=&quot;React 版开眼介绍&quot;&gt;&lt;/a&gt;React 版开眼介绍&lt;/h1&gt;&lt;h2 id=&quot;预览地址&quot;&gt;&lt;a href=&quot;#预览地址&quot; class=&quot;
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://ldqblog.me/tags/React/"/>
    
      <category term="SPA" scheme="http://ldqblog.me/tags/SPA/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 简介</title>
    <link href="http://ldqblog.me/2017/09/02/Webpack-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/09/02/Webpack-简介/</id>
    <published>2017-09-02T11:18:10.000Z</published>
    <updated>2017-10-14T11:31:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>一切皆模块的思想<br>将前端的资源通过各种 loader 处理成浏览器可使用的资源</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>npm install --save-dev webpack
npm install --save-dev webpack@&lt;version&gt;
npm install --save-dev webpack-dev-server //webpack 基于 express 的服务器 可以不要

&quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack --config webpack.config.js&quot;
}
</code></pre><p>主要工作就是编写 webpack.config.js<br>和下载 loader，plugin</p>
<p>plugin 分 webpack 自带的和第三方的</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code>
const webpack = require(&#39;webpack&#39;)
const path = require(&#39;path&#39;)
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)
const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;)
const CopyWebpackPlugin = require(&#39;copy-webpack-plugin&#39;)


// 分离 css 文件
const extractCSS = new ExtractTextPlugin({
    filename: &#39;static/css/main.[name].[contenthash:8].css&#39;
})
const extractSASS = new ExtractTextPlugin({
    filename: &#39;static/css/sass.[name].[contenthash:8].css&#39;
})


module.exports = {
    devtool: &#39;cheap-module-eval-source-map&#39;, //source-map 用于 debugger 时能否看到源码
    entry: {  // 入口文件
        app: [
            path.join(__dirname, &#39;../src/index.js&#39;) 
        ],
    }, 
    output: {  // 出口文件
        path: path.join(__dirname, &#39;../dist&#39;),
        filename: &#39;static/js/[name].[chunkhash:8].js&#39;,
        chunkFilename: &#39;static/js/[name].[chunkhash:8].js&#39;,
        publicPath: &#39;/&#39;          // 静态资源路径前要添加的路径                 
    },
    resolve: { // 扩展名，别名
        extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.json&#39;],
        alias: {
        // ================================
        // 自定义路径别名
        // ================================
        &#39;@&#39;: path.join(__dirname, &#39;../src&#39;)
        }
    },
     module: {
        rules: [{  //loader 配置
            test: /\.(js|jsx)$/,
            use: [{
                loader: &#39;babel-loader?cacheDirectory=true&#39;,
                options: {
                    plugins: [&#39;syntax-dynamic-import&#39;]                         
                }
            }, &#39;eslint-loader&#39;],
            include: path.join(__dirname, &#39;../src&#39;),
            exclude: /node_modules/
        }, {
                test: /\.css$/,
                exclude: &#39;/node_modules/&#39;,
                use: extractCSS.extract({
                    fallback: &#39;style-loader&#39;,
                    use: [{
                        loader: &#39;css-loader&#39;,
                        options: {
                            modules: false                         
                        }
                    }]
                })
            },
            {
                test: /\.scss$/,
                exclude: /node_modules/,
                use: extractSASS.extract({
                    fallback: &#39;style-loader&#39;,
                    use: [{
                        loader: &#39;css-loader&#39;,
                        options: {
                            modules: false
                        }
                    },
                    {
                        loader: &#39;sass-loader&#39;
                    }]
                })
            },
            {
                test: /\.(png|svg|jpe?g|gif|ico)$/,
                use: [
                    {
                        loader: &#39;url-loader&#39;,
                        options: {
                            limit: 10240, // 10KB 以下使用 base64
                            name: &#39;img/[name].[sha512:hash:base64:7].[ext]&#39;
                        }
                    }
                ]
            },
            {
                test: /\.(woff2?|eot|ttf|otf|svg)((-|\?)?.*)?$/,
                exclude: /static\/img/,
                loader: &#39;url-loader&#39;,
                options: {
                    name: &#39;css/fonts/[name].[hash:8].[ext]&#39;
                }
            },{
                test: /\.json$/,
                exclude: &#39;/node_modules/&#39;,
                loader: &#39;json-loader&#39;
            }]
    },
    plugins: [  // 插件
        new webpack.BannerPlugin(&quot;author by ldq-first&quot;),
        extractCSS,
        extractSASS,
        new webpack.LoaderOptionsPlugin({
            options: {
                postcss: require(&#39;autoprefixer&#39;)
            }
        }),
        new HtmlWebpackPlugin({
            template:  path.join(__dirname, &#39;../index.html&#39;)
        }),
        new CopyWebpackPlugin([
            {
                from: path.join(__dirname, &#39;../static&#39;),
                to: path.join(__dirname, &#39;../dist/static/&#39;),
              //  ignore: [&#39;.*&#39;]
            }
        ]),
        new webpack.HashedModuleIdsPlugin(),
        // 这个 plugin 是用于引入 dll 里生成的 json 的。
        new webpack.DllReferencePlugin({  
            context: __dirname,
            manifest: require(&#39;../static/public/js/vendor-mainfest.json&#39;)  // 指向这个 json
        })
    ],
    devServer: {  //webpack-dev-server
        historyApiFallback: true,
        host: &#39;0.0.0.0&#39;,  // 手机局域网访问 如：http://10.30.4.227:5050
        hot: true,
        port: 5050
    }
}
</code></pre><h3 id="常用-loader"><a href="#常用-loader" class="headerlink" title="常用 loader"></a>常用 loader</h3><p><a href="https://webpack.js.org/loaders/" target="_blank" rel="external">loader</a></p>
<pre><code>
babel-loader
style-loader
css-loader
sass-loader
url-loader
json-loader
less-loader
html-loader
postcss-loader
eslint-loader
</code></pre><h3 id="常用-plugin"><a href="#常用-plugin" class="headerlink" title="常用 plugin"></a>常用 plugin</h3><p><a href="https://webpack.js.org/plugins/" target="_blank" rel="external">插件列表</a></p>
<pre><code>
html-webpack-plugin
extract-text-webpack-plugin
copy-webpack-plugin
copy-webpack-plugin

webpack.BannerPlugin
webpack.LoaderOptionsPlugin
webpack.HashedModuleIdsPlugin
webpack.DllReferencePlugin
webpack.DefinePlugin
webpack.optimize.OccurrenceOrderPlugin
webpack.optimize.UglifyJsPlugin
</code></pre><h3 id="webpack-DllReferencePlugin"><a href="#webpack-DllReferencePlugin" class="headerlink" title="webpack.DllReferencePlugin"></a>webpack.DllReferencePlugin</h3><p>提取不变的第三方代码，提高打包速度，减少打包文件大小，<br>防止首屏加载的单个 js 文件太大，影响用户体验，还能利用缓存</p>
<p>编写配置文件<br>webpack.dll.config.js</p>
<pre><code>在 webpack.config.js 的 plugin 中添加

// 这个 plugin 是用于引入 dll 里生成的 json 的。
new webpack.DllReferencePlugin({  
    context: __dirname,
    manifest: require(&#39;../static/public/js/vendor-mainfest.json&#39;)  // 指向这个 json
})
</code></pre><p>运行命令</p>
<pre><code>webpack --config ./build/webpack.dll.config.js

在 index.html 中引入最终的 js 文件
&lt; script src=&quot;./static/public/js/vendor.dll.js&quot; &gt;&lt; /script &gt;
</code></pre><p>例子</p>
<pre><code>const webpack = require(&#39;webpack&#39;)
const path = require(&#39;path&#39;)


module.exports = {
    entry: {
        vendor: [&#39;react&#39;, &#39;react-router-dom&#39;, &#39;redux&#39;, &#39;react-dom&#39;, &#39;react-redux&#39;,
         &#39;react-router-redux&#39;, &#39;prop-types&#39;, &#39;history&#39;, &#39;styled-components&#39;, 
         &#39;redux-thunk&#39;]
    },
    output: {
        path: path.join(__dirname , &#39;../static/public/js&#39;),
        filename: &#39;[name].dll.js&#39;, // 输出的文件，将会根据 entry 命名为 vendor.dll.js
        library: &#39;[name]_library&#39; // 暴露出的全局变量名
    },
    plugins: [
        new webpack.DllPlugin({
             //path 是 manifest.json 文件的输出路径，这个文件会用于后续的业务代码打包
            path: path.join(__dirname, &#39;../static/public/js/&#39;, &#39;[name]-mainfest.json&#39;),
            // 是 dll 暴露的对象名，要跟 output.library 保持一致
            name: &#39;[name]_library&#39;, 
            //context 是解析包路径的上下文，这个要跟接下来配置的 webpack.config.js 一致
            context: __dirname
        }),
        new webpack.DefinePlugin({
            &#39;process.env&#39;:{
                &#39;NODE_ENV&#39;: JSON.stringify(&#39;production&#39;)
            }
        }),
        new webpack.optimize.UglifyJsPlugin({
             compress: {
                warnings: false
            }
        })
    ]
}
</code></pre><h3 id="Happypack"><a href="#Happypack" class="headerlink" title="Happypack"></a>Happypack</h3><p>它可以建立线程，加速我们的 rebuild，并很好的利用缓存。首次 build 时速度甚至会变慢，<br>这是由于 happypack 在进行分析和配置，当进入开发阶段，<br>改动代码后的 rebuild 会快到让你吓一跳。</p>
<p>未来可尝试一下</p>
<h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>Webpack 支持两种按需拆分，切入点分别是 import() 和 require.ensure()，<br>首选前者，它是 ECMAScript 的建议，import 也是 es6 的关键词；后者是 webpack 所特有的。</p>
<p>动态导入 import</p>
<p>Webpack 把 import() 作为拆分点，把导入的模块放在单独的 chunk 中。<br>import() 接收模块名作为参数并返回 Promise：import(name) -&gt; Promise。</p>
<p>用于演示的目录结构：</p>
<pre><code>demo
├── index.html
├── index.js
└── webpack.config.js
</code></pre><p>index.js</p>
<pre><code>function test(){
  import(/* webpackChunkName: &quot;my-chunk-name&quot; */&#39;moment&#39;).then(function(moment){
    console.log(moment().format(&#39;MMMM Do YYYY, h:mm:ss a&#39;));
  }).catch(function(err){
    console.log(err);
  }); 
}
test();




webpack.config.js

module.exports = { 
  entry: &#39;./index.js&#39;,
  output: {
      filename: &#39;dist.js&#39;,
  },  
  module: {
    rules: [{
      test: /\.js$/,
      use: [{
        loader: &#39;babel-loader&#39;,
        options: {
          presets: &#39;es2015&#39;,
          plugins: [&#39;syntax-dynamic-import&#39;]
        }
      }]  
    }]  
  }
}
</code></pre><p>index.html</p>
<pre><code>&lt;!doctype html&gt;
&lt; script src=&quot;0.dist.js&quot; &gt;&lt; /script &gt;
&lt; script src=&quot;dist.js&quot; &gt;&lt; /script &gt;
</code></pre><p>由于使用动态的导入，因此需要使用插件 syntax-dynamic-import</p>
<pre><code>npm install --save-dev babel-core babel-loader babel-plugin-syntax-dynamic-import babel-preset-es2015 webpack
npm install --save moment
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><strong>webpack 文档 </strong>: <a href="https://webpack.js.org/guides/installation/" target="_blank" rel="external">https://webpack.js.org/guides/installation/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Webpack&quot;&gt;&lt;a href=&quot;#Webpack&quot; class=&quot;headerlink&quot; title=&quot;Webpack&quot;&gt;&lt;/a&gt;Webpack&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Webpack" scheme="http://ldqblog.me/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>glup 简介</title>
    <link href="http://ldqblog.me/2017/09/01/glup-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/09/01/glup-简介/</id>
    <published>2017-09-01T11:28:20.000Z</published>
    <updated>2017-10-14T11:31:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="glup"><a href="#glup" class="headerlink" title="glup"></a>glup</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><pre><code>
打造前端工作流
打包，压缩，合并，git，远程操作


本质：将命令行转变成 js 代码来执行


思想
   数据流
   流水线

   操作过的文件，不输出
   下次再操作时，操作流水线
   最后才输出
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>    npm install gulp-cli -g

    npm install gulp -D

    touch gulpfile.js

    gulp --help
</code></pre><p>编写 glupfile.js 文件</p>
<pre><code>var gulp = require(&#39;gulp&#39;);
var pug = require(&#39;gulp-pug&#39;);
var less = require(&#39;gulp-less&#39;);
var minifyCSS = require(&#39;gulp-csso&#39;);



gulp.task(&#39;html&#39;, function(){
  return gulp.src(&#39;client/templates/*.pug&#39;)
    .pipe(pug())
    .pipe(gulp.dest(&#39;build/html&#39;))
});

gulp.task(&#39;css&#39;, function(){
  return gulp.src(&#39;client/templates/*.less&#39;)
    .pipe(less())
    .pipe(minifyCSS())
    .pipe(gulp.dest(&#39;build/css&#39;))
});

gulp.task(&#39;default&#39;, [ &#39;html&#39;, &#39;css&#39; ]);
</code></pre><p>常用 API</p>
<pre><code>task
src
pipe
dest
</code></pre><p>gulp.src(globs[, options])</p>
<p>globs 字符串 / 数组<br>数据流</p>
<p>pipe<br>传数据流</p>
<p>task(name, deps, callback)<br>创建任务<br>deps 并行执行</p>
<p>watch 监听文件改动</p>
<p>常用插件</p>
<pre><code>
gulp-htmlmin
gulp plugin to minify HTML.


gulp-cssnano
Minify CSS with cssnano.

gulp-clean-css
gulp plugin to minify CSS, using clean-css

gulp-less
gulp-sass
gulp-requirejs-optimize


gulp-concat
合并数据流


gulp-uglify
Minify JavaScript with UglifyJS2.

gulp-imagemin 
Minify PNG, JPEG, GIF and SVG images with imagemin

gulp-rename
gulp-rename is a gulp plugin to rename files easily.

gulp-clean
Removes files and folders.


gulp-eslint
A gulp plugin for ESLint.


gulp-jslint
It&#39;s JSLint for Gulp.js.

gulp-postcss
PostCSS gulp plugin to pipe CSS through several plugins, but parse CSS only once.

glob-stream 
A Readable Stream interface over node-glob.

gulp-typescript 
A gulp plugin for handling TypeScript compilation workflow. 
The plugin exposes TypeScript&#39;s compiler options to gulp using TypeScript API.


gulp-filter 
Filter files in a Vinyl stream

Enables you to work on a subset of the original files
 by filtering them using glob patterns. 
 When you&#39;re done and want all the original files back 
 you just use the restore stream.


gulp-sourcemaps
Write inline source maps
Inline source maps are embedded in the source file.


gulp-if
A ternary gulp plugin: conditionally control the flow of vinyl objects.

Note: Badly behaved plugins can often get worse when used with gulp-if.
 Typically the fix is not in gulp-if.

Note: Works great with lazypipe, see below


gulp-autoprefixer
Prefix CSS with Autoprefixer


gulp-babel
Use next generation JavaScript, today, with Babel

gulp-rev
添加版本号

gulp-rev-replace
版本号替换

gulp-useref
解析 html 资源定位
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><strong>glup 文档 </strong>: <a href="https://gulpjs.com/" target="_blank" rel="external">https://gulpjs.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;glup&quot;&gt;&lt;a href=&quot;#glup&quot; class=&quot;headerlink&quot; title=&quot;glup&quot;&gt;&lt;/a&gt;glup&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Glup" scheme="http://ldqblog.me/tags/Glup/"/>
    
  </entry>
  
  <entry>
    <title>React 版动态简历</title>
    <link href="http://ldqblog.me/2017/08/23/React%E7%89%88%E5%8A%A8%E6%80%81%E7%AE%80%E5%8E%86/"/>
    <id>http://ldqblog.me/2017/08/23/React版动态简历/</id>
    <published>2017-08-23T02:19:10.000Z</published>
    <updated>2017-10-13T07:18:24.795Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="http://ldqblog.me/react-animating-resume/build/">预览地址</a></strong></p>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul>
<li>React  前端框架</li>
<li>ES6/7 采用最新 JS 语法</li>
<li>Async/Await Promise 用于处理异步事件流</li>
<li>Marked 识别 markdown 语法</li>
<li>Prismjs/react-prism 实现语法高亮</li>
<li>styled-components 在 JS 中写 CSS</li>
<li>classnames 处理 className</li>
<li>Express create-react-app 自带服务器</li>
<li>icomoom.css 字体图标</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>利用 Async/Await Promise 实现按步骤绘制动态简历<br>实现了加速、播放、暂停、跳过、重来、下载 PDF 等功能<br>用于 FireFox 显示 pdf 排版有错，所以遇到 Firefox 时，点击下载 PDF 后没有预览而采用直接下载</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>定时的在页面添加字符串</p>
<p>用一定的方法解析字符串</p>
<p>如字符串内容为 CSS 就添加到 style 标签中</p>
<p>如字符串内容为 HTML 和 markdown 就用 marked 模块解析</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://ldqblog.me/react-animating-resume/build/&quot;&gt;预览地址&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;技术&quot;&gt;&lt;a href=&quot;#技术&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://ldqblog.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Vue 版动态简历</title>
    <link href="http://ldqblog.me/2017/08/20/Vue%E7%89%88%E5%8A%A8%E6%80%81%E7%AE%80%E5%8E%86/"/>
    <id>http://ldqblog.me/2017/08/20/Vue版动态简历/</id>
    <published>2017-08-20T02:19:22.000Z</published>
    <updated>2017-10-13T07:18:43.774Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="http://ldqblog.me/vue-animating-resume/dist/">预览地址</a></strong></p>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li>Vue  前端框架</li>
<li>ES6/7 采用最新 JS 语法</li>
<li>Async/Await Promise 用于处理异步事件流</li>
<li>Marked 识别 markdown 语法</li>
<li>Prismjs 实现语法高亮</li>
<li>Express vue-cli 自带服务器</li>
<li>svg 字体图标</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>利用 Async/Await Promise 实现按步骤绘制动态简历<br>实现了加速、播放、暂停、跳过、重来、下载 PDF 等功能<br>开启 webpack 和 babel-loader 缓存提高构建速度<br>用于 FireFox 显示 pdf 排版有错，所以遇到 Firefox 时，点击下载 PDF 后没有预览而采用直接下载</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>定时的在页面添加字符串</p>
<p>用一定的方法解析字符串</p>
<p>如字符串内容为 CSS 就添加到 style 标签中</p>
<p>如字符串内容为 HTML 和 markdown 就用 marked 模块解析</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://ldqblog.me/vue-animating-resume/dist/&quot;&gt;预览地址&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;技术栈&quot;&gt;&lt;a href=&quot;#技术栈&quot; class=&quot;headerlink&quot; title
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://ldqblog.me/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 版商城 (二)</title>
    <link href="http://ldqblog.me/2017/08/18/Vue%E7%89%88%E5%95%86%E5%9F%8E-%E4%BA%8C/"/>
    <id>http://ldqblog.me/2017/08/18/Vue版商城-二/</id>
    <published>2017-08-18T02:17:45.000Z</published>
    <updated>2017-10-14T10:01:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-版商城技术详情"><a href="#Vue-版商城技术详情" class="headerlink" title="Vue 版商城技术详情"></a>Vue 版商城技术详情</h1><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue 配合 Vue-Router，Vuex</p>
<p>实现路由跳转，路由过渡，状态管理</p>
<p>Vue-lazyload<br>头像图片懒加载</p>
<p>Vue-infinite-scroll<br>滚动加载</p>
<p>Vue-pull-to-refresh<br>自己开发的下拉刷新（实现插件）</p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>实现 api 请求等的异步处理</p>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>后端服务器</p>
<p>获取数据 get 请求<br>操作数据 post 请求</p>
<p>利用中间件，路由实现后端逻辑</p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>数据库</p>
<p>MongoDB 是一个基于文档的数据库，所有数据是从磁盘上进行读写的。<br>MongoDB 善长的是对无模式 JSON 数据的查询。<br>MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值 (key=&gt;value) 对组成。<br>MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<h3 id="Robomongo"><a href="#Robomongo" class="headerlink" title="Robomongo"></a>Robomongo</h3><p>可视化 MongeDB 工具</p>
<h2 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h2><p>连接数据库和 Express</p>
<p>使用 promise 的调用方式</p>
<pre><code>
const mongoose = require(&#39;mongoose&#39;)
const Schema =  mongoose.Schema
mongoose.Promise = global.Promise

const productSchema = new Schema({
    &quot;productId&quot;: String,
    &quot;productName&quot;: String,
    &quot;salePrice&quot;: Number,
    &quot;productImage&quot;: String,
    &quot;checked&quot;: Number,
    &quot;productNum&quot;: Number
})


module.exports = mongoose.model(&#39;Good&#39;, productSchema)
</code></pre><h3 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h3><pre><code>    插入数据
    save

    更新数据
    update

    查找
    find

    查找并更新
    findByIdAndUpdate

    移除
    remove

    数量查询
    count

    根据_id 查询
    findById
</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code>　 $or　　　　或关系

　　$nor　　　 或关系取反

　　$gt　　　　大于

　　$gte　　　 大于等于

　　$lt　　　　 小于

　　$lte　　　  小于等于

　　$ne            不等于

　　$in             在多个值范围内

　　$nin           不在多个值范围内

　　$all            匹配数组中多个值

　　$regex　　正则，用于模糊查询

　　$size　　　匹配数组大小

　　$maxDistance　　范围查询，距离（基于 LBS）

　　$mod　　   取模运算

　　$near　　　邻域查询，查询附近的位置（基于 LBS）

　　$exists　　  字段是否存在

　　$elemMatch　　匹配内数组内的元素

　　$within　　范围查询（基于 LBS）

　　$box　　　 范围查询，矩形范围（基于 LBS）

　　$center       范围醒询，圆形范围（基于 LBS）

　　$centerSphere　　范围查询，球形范围（基于 LBS）

　　$slice　　　　查询字段集合中的元素（比如从第几个之后，第 N 到第 M 个元素）
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>const Goods = require(&#39;../models/goods.js&#39;)
mongoose.Promise = global.Promise

var env = process.env.NODE_ENV || &#39;development&#39;
if(env === &#39;development&#39;) {
    console.log(&#39;NODE_ENV:&#39;, env)
    mongoose.connect(&#39;mongodb://IP:port/shopdb&#39;)
}
else {
  console.log(&#39;NODE_ENV:&#39;, env)
  mongoose.connect(&#39;mongodb:// 用户. 数据库: password@IP:port/shopdb&#39;)
}



router.get(&#39;/list&#39;, (req, res, next) =&gt; {
   const sort = req.query.sort
   const page = req.query.page
   const pageSize = req.query.pageSize
   const priceChecked = req.query.priceChecked
   let params = {}
   let priceGt = &#39;&#39;, priceLte =&#39;&#39;
   if(priceChecked !== &#39;all&#39;) {
       switch(priceChecked) {
            case &#39;0&#39;: priceGt = 0; priceLte=500; break;
            case &#39;1&#39;: priceGt = 500; priceLte=1000; break;
            case &#39;2&#39;: priceGt = 1000; priceLte=2000; break;
            case &#39;3&#39;: priceGt = 2000; priceLte=4000; break;
        }
        params = {
            salePrice: {
                $gt: priceGt,
                $lte: priceLte
            }
        }
        console.log(params)
   }

   const skip = (page - 1) * pageSize;
   const goodsModel = Goods.find(params).skip(skip).limit(parseInt(pageSize))

   goodsModel.sort({&#39;salePrice&#39;: sort})

   goodsModel.exec((err, doc) =&gt; {
       if(err) {
           res.json({
               status: &#39;404&#39;,
               msg: err.message
           })
       }
       else {
           res.json({
               status: &#39;200&#39;,
               msg: &#39;OK&#39;,
               result: {
                   count: doc.length,
                   list: doc
               }
           })
       }
   })
})
</code></pre><h3 id="根据环境连接数据库"><a href="#根据环境连接数据库" class="headerlink" title="根据环境连接数据库"></a>根据环境连接数据库</h3><pre><code>var env = process.env.NODE_ENV || &#39;development&#39;
var sessionUrl = &#39;&#39;if(env ===&#39;development&#39;) {
    console.log(&#39;app.NODE_ENV:&#39;, env)
    sessionUrl = &#39;mongodb://IP:port/shopdb&#39;
}
else {
  console.log(&#39;app.NODE_ENV:&#39;, env)
  sessionUrl = &#39;mongodb:// 用户. 数据库: password@IP:port/shopdb&#39;
}
</code></pre><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="代理转发"><a href="#代理转发" class="headerlink" title="代理转发"></a>代理转发</h3><pre><code>upstream vue {
    server 本地 IP:port;
}

server {
    listen port;
    # server_name *. 主域名;
    server_name  外部 IP;
    location / {
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
        proxy_set_header X-Nginx-Proxy true;
        proxy_pass http://vue;
        proxy_redirect off;
    }
    location /goods/ {
        proxy_pass http:// 本地 IP:port/goods/;
    }

    location /users/ {
        proxy_pass http:// 本地 IP:port/users/;
    }
    location /vueshop/ {
        alias 路径;
    }
    location ~* ^.+\.(jpg|jpeg|gif|png|svg|ico|webp|css|js|map|pdf|txt)$ {
        root 路径;
    }
}
</code></pre><h3 id="开启-gzip-压缩"><a href="#开启-gzip-压缩" class="headerlink" title="开启 gzip 压缩"></a>开启 gzip 压缩</h3><p>sudo vi /etc/nginx/nginx.conf</p>
<pre><code>##
# Gzip Settings
##

gzip on;
gzip_disable &quot;msie6&quot;;
# 启用 gzip 压缩的最小文件，小于设置值的文件将不会压缩
gzip_min_length 1k;
# 是否在 http header 中添加 Vary: Accept-Encoding，建议开启
    gzip_vary on;
# gzip_proxied any;
# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用 CPU 时间
    gzip_comp_level 4;
    gzip_buffers 16 8k;
# gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
</code></pre><h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p>做守护进程, 发布更新项目</p>
<p>使用 ecosystem.json </p>
<p> pm2 deploy ecosystem.json start</p>
<p> 可以配置服务器 ip，指定 github 仓库<br> 实现代码更新后快速部署到服务器中</p>
<pre><code>{
    &quot;apps&quot;:[
        {
            &quot;name&quot;:&quot;vueshop&quot;,
            &quot;script&quot;:&quot;入口脚本&quot;,           
            &quot;env&quot;: {              // 传进去的变量
                &quot;COMMON_VARIABLE&quot;: &quot;true&quot;
            },
            &quot;env_production&quot;: {
                &quot;NODE_ENV&quot;: &quot;production&quot;
            }
        }
    ],
    &quot;deploy&quot;: { // 部署任务
        &quot;start&quot;: { // 任务名
            &quot;user&quot;: &quot;&quot;,// 服务器上用来发布应用的 user&quot;host&quot;: [&quot;IP&quot;],&quot;port&quot;:&quot;port&quot;,&quot;ref&quot;:&quot;origin/master&quot;,&quot;repo&quot;:&quot;git 仓库 &quot;,&quot;path&quot;:&quot;&quot;, // 服务器项目位置
            &quot;ssh_options&quot;: &quot;StrictHostKeyChecking=no&quot;, // 取消 key 校验
            &quot;post-deploy&quot;: &quot;执行的命令行 &amp;&amp; pm2 startOrRestart ../ecosystem.json --env production&quot;,
            &quot;env&quot;: {
                &quot;NODE_ENV&quot;: &quot;production&quot;
            }
        }
    }
}
</code></pre><h2 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h2><p>数据可视化显示</p>
<p>显示价格趋势，数据来自数据库（自己编的）</p>
<p>显示订单详情</p>
<h2 id="Svg-captcha"><a href="#Svg-captcha" class="headerlink" title="Svg-captcha"></a>Svg-captcha</h2><p>验证码</p>
<p>在考虑要使用验证码时, 发现许多相关的 npm 模块都要<br>安装其它支持库（C 或 C++ 编写，而且平台兼容性极差）</p>
<p>最终在 CNode 社区发现了以 svg 为基础的 Svg-captcha</p>
<blockquote>
<p>内部使用 opentype.js ， 把字符转换为 svg 路径，然后生成验证码</p>
</blockquote>
<p>简单易用</p>
<pre><code>
const svgCaptcha = require(&#39;svg-captcha&#39;)

router.get(&#39;/captcha&#39;, (req, res, next) =&gt; {
  const captcha = svgCaptcha.create({
    background: &quot;#3E96D6&quot;
  })
  req.session.captcha = captcha.text

  res.set(&#39;Content-Type&#39;, &#39;image/svg+xml&#39;)
  res.json({
    status: &#39;200&#39;,
    msg: &#39;OK&#39;,
    result: captcha
  })
})


router.get(&#39;/isCaptchaTrue&#39;, (req, res, next) =&gt; {
  const captcha = req.query.captcha.toLowerCase()
  if (req.session.captcha.toLowerCase() !== captcha) {
    res.json({
      status: &#39;500&#39;,
      msg: &#39;验证码有错&#39;,
      result: &#39;&#39;
    })
    return
  } else {
    res.json({
      status: &#39;200&#39;,
      msg: &#39;验证码正确&#39;,
      result: &#39;&#39;
    })
  }
})
</code></pre><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>express 在 4.x 版本之后，session 管理和 cookies 等许多模块都不再直接包含在 express 中，<br>而是需要单独添加相应模块。</p>
<p>express4 中操作 cookie 使用 cookie-parser 模块<br>express4 中操作 session 使用 express-session 模块</p>
<p>session 的运作通过一个 session_id 来进行。session_id 通常是存放在客户端的 cookie 中，<br>比如在 express 中，默认是 connect.sid 这个字段，当请求到来时，<br>服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，<br>进行数据的保存和修改。</p>
<p>这意思就是说，当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，<br>然后存在你 cookie 中的 connect.sid 字段中。<br>当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然<br>后从服务器的存储中取出上次记录在你身上的数据。<br>由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。<br>伪造成功的概率比坐在家里编程时被邻居家的狗突然闯入并咬死的几率还低。</p>
<p>session 可以存放在 1）内存、2）cookie 本身、3）redis 或 memcached 等缓存中，或者 4）数据库中。</p>
<p>使用 session 验证用户<br>session 存储在数据库中</p>
<p>app.js</p>
<pre><code>
配置
const session = require(&#39;express-session&#39;)
const mongoStore = require(&#39;connect-mongo&#39;)(session)



app.use(session({
  secret: &#39;recommand 128 bytes random string&#39;, // 建议使用 128 个字符的随机字符串  
 // 作为服务器端生成 session  cookie 的签名 ，防止篡改 ,
  // 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改。
 name: &#39;user&#39;,         
 // cookie 的名字 保存 session 的字段名称, 返回客户端的 key 的名称，默认为 connect.sid, 也可以自己设置。
 resave:  false,
 // 强制保存 session 即使它并没有变化 （默认： true）
 //saveUninitialized:
 // 初始化 session 时是否保存到存储。默认为 true， 但是 (后续版本) 有可能默认失效，所以最好手动添加。
cookie:  { maxAge: 60 * 1000 * 60 * 24 * 7 },
//session cookie 设置 设置返回到前端 key 的属性，默认值为{ path: ‘/’, httpOnly: true, secure: false, maxAge: null }。
//genid - 生成新 session ID 的函数 （默认使用 uid2 库）
 //rolling: false,
 // 在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false）
//proxy: true,
// 当设置了 secure cookies（通过”x-forwarded-proto” header ）时信任反向代理。当设定为 true 时，
//”x-forwarded-proto” header 将被使用。
// 当设定为 false 时，所有 headers 将被忽略。当该属性没有被设定时，将使用 Express 的 trust proxy。
saveUninitialized: false,
// 强制将未初始化的 session 存储。当新建了一个 session 且未设定属性或值时，它就处于
// 未初始化状态。在设定一个 cookie 前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。（默认：true）
// unset
// 控制 req.session 是否取消（例如通过 delete，或者将它的值设置为 null）。这可以使 session 保持存储
// 状态但忽略修改或删除的请求（默认：keep）
//session 存储实例
  store: new mongoStore({
  //  db: &#39;VueShop&#39;,
    url: sessionUrl,
    collection: &#39;sessions&#39;
  })
}))
</code></pre><p>使用</p>
<p>routes<br>    user.js</p>
<pre><code>

// 登录
router.post(&#39;/login&#39;, (req, res, next) =&gt; {
  const captcha = req.body.captcha.toLowerCase()
  console.log(captcha)
  console.log(req.session.captcha.toLowerCase())
  if (req.session.captcha.toLowerCase() !== captcha) {
    res.json({
      status: &#39;500&#39;,
      msg: &#39;验证码有错&#39;,
      result: &#39;&#39;
    })
    return
  }
  console.log(&#39;param&#39;)
  const param = {
    userName: req.body.userName,
    userPwd: req.body.userPwd
  }

  User.findOne(param)
    .then(doc =&gt; {
      if (doc) {
        res.cookie(&quot;userId&quot;, doc.userId, {
          path: &#39;/&#39;,
          maxAge: 1000 * 60 * 60 * 24 * 7
        })
        res.cookie(&quot;userName&quot;, doc.userName, {
          path: &#39;/&#39;,
          maxAge: 1000 * 60 * 60 * 24 * 7
        })

        req.session.user = {
          userName: doc.userName,
          userId: doc.userId
        }
        res.json({
          status: &#39;200&#39;,
          msg: &#39;OK&#39;,
          result: {
            userName: doc.userName
          }
        })
      } else {
        res.json({
          status: &#39;400&#39;,
          msg: &#39;用户名或者密码错误&#39;,
          result: &#39;&#39;
        })
      }
    })
    .catch(err =&gt; {
      res.json({
        status: &#39;404&#39;,
        msg: err.message,
        result: &#39;&#39;
      })
    })

})
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vue-版商城技术详情&quot;&gt;&lt;a href=&quot;#Vue-版商城技术详情&quot; class=&quot;headerlink&quot; title=&quot;Vue 版商城技术详情&quot;&gt;&lt;/a&gt;Vue 版商城技术详情&lt;/h1&gt;&lt;h2 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;he
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="SPA" scheme="http://ldqblog.me/tags/SPA/"/>
    
      <category term="Vue" scheme="http://ldqblog.me/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 版商城 (一)</title>
    <link href="http://ldqblog.me/2017/08/15/Vue%E7%89%88%E5%95%86%E5%9F%8E-%E4%B8%80/"/>
    <id>http://ldqblog.me/2017/08/15/Vue版商城-一/</id>
    <published>2017-08-15T02:10:51.000Z</published>
    <updated>2017-10-13T06:50:51.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-版商城介绍"><a href="#Vue-版商城介绍" class="headerlink" title="Vue 版商城介绍"></a>Vue 版商城介绍</h1><h2 id="预览地址"><a href="#预览地址" class="headerlink" title="预览地址"></a>预览地址</h2><p><a href="http://39.108.141.131/vueshop/#/" target="_blank" rel="external">预览地址</a></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><blockquote>
<p>部署在阿里云<br>采用 Nginx 进行代理转发<br>PM2 做守护进程</p>
</blockquote>
<p><img src="http://ldqblog.me/Vue-shop/static/font/%E6%B3%A8%E6%84%8F.svg" alt="注意"></p>
<p></p><h2 style="font-size: 26px; color: red;"> 注意存在的问题 </h2><p></p>
<p style="font-size: 24px; line-height: 1.5; font-weight: bold;"><br>    由于域名没有备案，所以用 ip 访问，防止被阿里云封 &lt; br&gt;<br>    由于没有使用 Https[国内的免费证书都要备案域名]<br><br>    Chrome，Firefox 等遇到 &lt;input type=”password”&gt; 会报不安全 &lt; br&gt;<br>    并非代码本身有问题 &lt; br&gt;<br></p>



<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/LDQ-first/Vue-shop" target="_blank" rel="external">GitHub</a></p>
<hr>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>做 Vue 版商城的原因：</p>
<pre><code>1. 了解前后端通信
2. 了解服务器部署
3. 了解 MongoDB
4. 了解 Nginx
</code></pre><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li><strong>Vue2.3</strong>: [ 前端框架 ]</li>
<li><strong>Vuex</strong>: [ 状态管理, 组件通信 ] </li>
<li><strong>Vue-router</strong>: [ 配置路由，组件切换 ]</li>
<li><strong>Vue-lazyload</strong>: [ 图片懒加载 ]</li>
<li><strong>Vue-infinite-scroll</strong>: [ 滚动加载 ]</li>
<li><strong>Vue-pull-to-refresh</strong>: [ 自己开发的下拉刷新 ]</li>
<li><strong>ES6/7</strong>: [ JS 版本 ]</li>
<li><strong>Webpack</strong>: [ 模块化处理，编译打包 ]</li>
<li><strong>Express</strong>: [ 服务器 ]</li>
<li><strong>Mongoose</strong>: [ 连接 MongoDB 数据库 ]</li>
<li><strong>Nginx</strong>: [ 代理转发，gzip 压缩等 ]</li>
<li><strong>PM2</strong>: [ 做守护进程, 发布更新项目 ]</li>
<li><strong>Axios</strong>: [ 基于 Promise 处理 HTTP 请求 ]</li>
<li><strong>SASS</strong>(<strong>SCSS</strong>): [ css 预处理器 ]</li>
<li><strong>Flex</strong>: [ 弹性布局 ]</li>
<li><strong>loaclStorge</strong>: [ 本地存储用户信息 ]</li>
<li><strong>Echarts</strong>: [ 数据可视化显示 ]</li>
<li><strong>Svg-captcha</strong>: [ 验证码 ]</li>
</ul>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://ldqblog.me/img/VShop/01.jpg" alt="01"> </p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>实现登录，注册，<br>添加删除购物车，添加删除地址，<br>完成订单，查看订单详情，<br>下拉刷新</p>
<p>阿里云部署</p>
<ol>
<li>创建新用户</li>
<li>更换端口，禁止 root 登录</li>
<li>安装配置 iptables， fail2ban，nginx，mongodb，nodejs</li>
<li>利用公私钥实现 ssh 无密码登录</li>
<li>利用 git，github，pm2 实现高效的部署代码</li>
<li>利用 nginx 开启 gizp</li>
</ol>
<p>注意<br>阿里云安全组本身就有做端口访问限制</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>没有备案, 没有使用 HTTPS，导致 chrome 提示不安全<br>没有实现 RESTful API</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>解决问题<br>优化代码<br>优化服务器配置</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Vue 文档 </strong>: <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="external">https://cn.vuejs.org/v2/guide/</a><br><strong>Mongoose 文档 </strong>: <a href="http://mongoosejs.com/" target="_blank" rel="external">http://mongoosejs.com/</a><br><strong>Mongodb 文档 </strong>: <a href="https://docs.mongodb.com/" target="_blank" rel="external">https://docs.mongodb.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vue-版商城介绍&quot;&gt;&lt;a href=&quot;#Vue-版商城介绍&quot; class=&quot;headerlink&quot; title=&quot;Vue 版商城介绍&quot;&gt;&lt;/a&gt;Vue 版商城介绍&lt;/h1&gt;&lt;h2 id=&quot;预览地址&quot;&gt;&lt;a href=&quot;#预览地址&quot; class=&quot;headerli
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="SPA" scheme="http://ldqblog.me/tags/SPA/"/>
    
      <category term="Vue" scheme="http://ldqblog.me/tags/Vue/"/>
    
      <category term="Express" scheme="http://ldqblog.me/tags/Express/"/>
    
      <category term="MongoDB" scheme="http://ldqblog.me/tags/MongoDB/"/>
    
      <category term="Mongoose" scheme="http://ldqblog.me/tags/Mongoose/"/>
    
      <category term="Linux" scheme="http://ldqblog.me/tags/Linux/"/>
    
      <category term="阿里云" scheme="http://ldqblog.me/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="Nginx" scheme="http://ldqblog.me/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 入门</title>
    <link href="http://ldqblog.me/2017/08/12/TypeScript-%E5%85%A5%E9%97%A8/"/>
    <id>http://ldqblog.me/2017/08/12/TypeScript-入门/</id>
    <published>2017-08-12T07:13:38.000Z</published>
    <updated>2017-10-12T09:14:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript-入门"><a href="#TypeScript-入门" class="headerlink" title="TypeScript 入门"></a>TypeScript 入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 是一门弱类型语言，没有类型检测，这让 JavaScript 很灵活，但也更容易出错</p>
<blockquote>
<p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。  </p>
</blockquote>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><blockquote>
<p>官网<br><a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a><br>中文文档<br><a href="https://www.tslang.cn/index.html" target="_blank" rel="external">tslang</a><br>查看编译后的结果<br><a href="http://www.typescriptlang.org/play/index.html" target="_blank" rel="external">typescriptlang</a></p>
</blockquote>
<h2 id="很多项目开始使用-TypeScript"><a href="#很多项目开始使用-TypeScript" class="headerlink" title="很多项目开始使用 TypeScript"></a>很多项目开始使用 TypeScript</h2><blockquote>
<p>Angular</p>
<div class="github-widget" data-repo="angular/angular"></div>

<p>VSCode</p>
<div class="github-widget" data-repo="Microsoft/vscode"></div>

<p>RxJS</p>
<div class="github-widget" data-repo="Reactive-Extensions/RxJS"></div>

</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install -g typescript
</code></pre><h3 id="安装完后运行-tsc-v-查看是否正确安装"><a href="#安装完后运行-tsc-v-查看是否正确安装" class="headerlink" title="安装完后运行 tsc -v 查看是否正确安装"></a>安装完后运行 tsc -v 查看是否正确安装</h3><pre><code>tsc -v
Version 2.4.2
</code></pre><h3 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h3><p>tsc -h 或 tsc –help 查看帮助</p>
<pre><code>$ tsc -h
Version 2.4.2
Syntax:  tsc [options] [file ...]

Examples: tsc hello.ts
          tsc --outFile file.js file.ts
          tsc @args.txt
Options:
...
</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>生成默认的配置文件 tsconfig.json</p>
<pre><code>tsc init
</code></pre><ul>
<li>配置 es6</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-084ac9734f4aceab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="支持-TypeScript-的文本编辑器和-IDE"><a href="#支持-TypeScript-的文本编辑器和-IDE" class="headerlink" title="支持 TypeScript 的文本编辑器和 IDE"></a>支持 TypeScript 的文本编辑器和 IDE</h3><p>通过本身或插件支持 TypeScript 的语法、智能提示、纠错等</p>
<ul>
<li>VSCode 微软开发的轻量级编辑器，内置支持 TypeScript</li>
<li>Sublime Text 有相关插件</li>
<li>WebStorm 新版内置支持 TypeScript</li>
<li>其他包括 Vim，Atom，Emacs 等</li>
</ul>
<h3 id="将-TypeScrip-编译成-JavaScript"><a href="#将-TypeScrip-编译成-JavaScript" class="headerlink" title="将 TypeScrip 编译成 JavaScript"></a>将 TypeScrip 编译成 JavaScript</h3><p>TypeScript 的文件类型是. ts 文件或 JSX 中的. tsx 文件，不能直接运行在浏览器中，需要编译成. js 文件</p>
<p>方法：</p>
<ol>
<li><p>用命令行工具进行编译</p>
<pre><code>
Syntax:  tsc [options] [file ...]

Examples: tsc hello.ts

        tsc --outFile file.js file.ts

        tsc @args.txt
</code></pre><p>最后一个的作用是从一个文件中插入命令行选项和文件</p>
<pre><code>
@&lt;file&gt;    Insert command line options and files from a file.
</code></pre></li>
<li><p>在 VSCode 或其他文本编辑器和 IDE 上操作</p>
</li>
<li><p>使用自动化构建工具，如 gulp， webpack 等</p>
</li>
</ol>
<h3 id="介绍一下第一种方法"><a href="#介绍一下第一种方法" class="headerlink" title="介绍一下第一种方法"></a>介绍一下第一种方法</h3><p>下面的命令行把 TypeScript 文件 main.ts 编译为 JavaScript 版本的 main.js。如果 main.js 已经存在的话会被覆盖。</p>
<pre><code>    tsc main.ts
</code></pre><p>可以同时编译多个文件</p>
<pre><code>tsc main.ts other.ts

tsc *.ts
</code></pre><p>还可以通过 –watch 或 - w 来自动编译 (修改后能自动转成. js 文件)</p>
<pre><code>tsc main.ts --watch
</code></pre><h3 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h3><p>TypeScript 可以声明变量类型，这样编译器就可以确保赋值时不会产生类型错误<br>如果省略了类型声明，TypeScript 将会从代码中自动推测出正确的类型。</p>
<p>在变量，函数声明时可以定义自己的类型</p>
<pre><code>var burger: string = &#39;hamburger&#39;,    // String 
    calories: number = 300,          // Numeric
    tasty: boolean = true;            // Boolean

function speak(food: string, energy: number): void {
  console.log(&quot;Our&quot; + food + &quot;has&quot; + energy + &quot;calories.&quot;);
}

speak(burger, calories);
</code></pre><p>编译后变量声明都会被移除</p>
<pre><code>var burger = &#39;hamburger&#39;,
    calories = 300, 
    tasty = true; 

function speak(food, energy) {
    console.log(&quot;Our&quot; + food + &quot;has&quot; + energy + &quot;calories.&quot;);
}

speak(burger, calories);
</code></pre><p>如果输入的类型有错，TypeScript 会有代码警告<br>但还是会转成 js 文件</p>
<p>ts 文件</p>
<pre><code>var carNum: Number = &#39;10&#39;
</code></pre><pre><code>$ tsc err.ts --watch
err.ts(1,5): error TS2322: Type &#39;&quot;10&quot;&#39; is not assignable to type &#39;Number&#39;.
10:36:46 - Compilation complete. Watching for file changes.
</code></pre><p>js 文件</p>
<pre><code>var carNum = &#39;10&#39;;
</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>Number ( 数值 ) - 包括整型，浮点型等</li>
</ul>
<pre><code>let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
</code></pre><ul>
<li>String （字符串）- 包括单双引号的字符串</li>
</ul>
<pre><code>let color: string = &quot;blue&quot;;
color = &#39;red&#39;;
let sentence: string = `Hello, my name is ${ fullName }.
I&#39;ll be ${ age + 1 } years old next month.`;
</code></pre><ul>
<li>Boolean （布尔）- true ,false, 不可用其他类型如数字, 空字符串，否则会报错 </li>
</ul>
<pre><code>let isDone: boolean = false
</code></pre><ul>
<li>Array （数组）- 有两种语法：my_arr: number[ ] 或者 my_arr: Array<number></number></li>
</ul>
<pre><code>let list: number[] = [1, 2, 3]

let list: Array&lt;number&gt; = [1, 2, 3]
</code></pre><ul>
<li>Tuple ( 元组 ) - 数组中包含不同的类型，有顺序</li>
</ul>
<pre><code>let x: [string, number];
x = [&quot;hello&quot;, 10]; // OK
x = [10, &quot;hello&quot;]; // Error
</code></pre><p>使用不是该数据类型的方法会报错</p>
<pre><code>console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, &#39;number&#39; does not have &#39;substr&#39;
</code></pre><p>新赋值的类型必须是定义时规定的类型</p>
<pre><code>x[3] = &quot;world&quot;; // OK, &#39;string&#39; can be assigned to &#39;string | number&#39;

console.log(x[5].toString()); // OK, &#39;string&#39; and &#39;number&#39; both have &#39;toString&#39;

x[6] = true; // Error, &#39;boolean&#39; isn&#39;t&#39;string | number&#39;
</code></pre><ul>
<li>Enum （枚举类型）- 它用于声明一组命名的常数，当一个变量有几种可能的取值时，可以将它定义为枚举类型。</li>
</ul>
<p>让代码更有语义化, 可读性</p>
<pre><code>enum Color {Red, Green, Blue}
let c: Color = Color.Green;
</code></pre><p>枚举类型的数字默认从 0 开始，可以自己设置</p>
<pre><code>enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;

enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;
</code></pre><p>当不知道 enum 类型的第 N 项是什么名称时，可以用 N 来代替</p>
<pre><code>enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

alert(colorName);
</code></pre><pre><code>var Color;
(function (Color) {
    Color[Color[&quot;Red&quot;] = 1] = &quot;Red&quot;;
    Color[Color[&quot;Green&quot;] = 2] = &quot;Green&quot;;
    Color[Color[&quot;Blue&quot;] = 3] = &quot;Blue&quot;;
})(Color || (Color = {}));
var colorName = Color[2];
alert(colorName);
</code></pre><ul>
<li>Any （任意）- 任何类型都可以（Never 类型除外）</li>
</ul>
<p>关闭类型检查</p>
<pre><code>let notSure: any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false; // okay, definitely a boolean
</code></pre><pre><code>let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn&#39;t check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property &#39;toFixed&#39; doesn&#39;t exist on type&#39;Object&#39;.
</code></pre><pre><code>let list: any[] = [1, true, &quot;free&quot;];

list[1] = 100;
</code></pre><ul>
<li>Void （空）- 用在不返回任何值的函数中</li>
</ul>
<pre><code>function warnUser(): void {
    alert(&quot;This is my warning message&quot;);
}
</code></pre><p>可以用来标识 undefined 和 null</p>
<pre><code>let unusable: void = undefined;
</code></pre><ul>
<li>Null and Undefined</li>
</ul>
<pre><code>let u: undefined = undefined;
let n: null = null;
</code></pre><p>默认为其他类型的亚类型，就是可以匹配其他类型<br>使用 –strictNullChecks 标识，就只匹配 null 、undefined、void<br>可以使用 string | null | undefined 类型来只匹配 string 、 null 、 undefined 三种类型</p>
<blockquote>
<p>官方鼓励使用 –strictNullChecks</p>
</blockquote>
<ul>
<li>Never - 表示值从未发生</li>
</ul>
<p>Any 类型不能匹配 Never</p>
<pre><code>// Function returning never must have unreachable end point
function error(message: string): never {
    throw new Error(message);
}

// Inferred return type is never
function fail() {
    return error(&quot;Something failed&quot;);
}

// Function returning never must have unreachable end point
function infiniteLoop(): never {
    while (true) {
    }
}
</code></pre><ul>
<li>Type assertions</li>
</ul>
<p>“angle-bracket” syntax</p>
<pre><code>let someValue: any = &quot;this is a string&quot;;

let strLength: number = (&lt;string&gt;someValue).length;
</code></pre><p>as -syntax</p>
<pre><code>let someValue: any = &quot;this is a string&quot;;

let strLength: number = (someValue as string).length;
</code></pre><p>一般情况下，两种写法等价，但在 JSX 中，只能用 as -style</p>
<blockquote>
<p>官方文档中关于数据类型的介绍 <a href="http://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="external">Basic Types</a></p>
</blockquote>
<h3 id="Interfaces-接口"><a href="#Interfaces-接口" class="headerlink" title="Interfaces 接口"></a>Interfaces 接口</h3><p>接口会根据一个对象是否符合某种特定的数据结构来进行类型检查</p>
<p>只在开发是有效，编译后删除</p>
<pre><code>interface Food {
    name: string;
    calories: number;
}

function speak(food: Food): void{
  console.log(&quot;Our&quot; + food.name + &quot;has&quot; + food.calories + &quot;calories.&quot;);
}

var ice_cream = {
  name: &quot;ice cream&quot;, 
  calories: 200
}

speak(ice_cream);
</code></pre><p>属性的顺序并不重要。我们只需必要的属性存在并且是正确的类型。如果哪里有遗漏，类型错误，或者命名不同的话，编译器都会报警告信息。</p>
<pre><code>interface Food {
    name: string;
    calories: number;
}

function speak(food: Food): void{
  console.log(&quot;Our&quot; + food.name + &quot;has&quot; + food.calories + &quot;grams.&quot;);
}

// 将 name 改为 nmae
var ice_cream = {
  nmae: &quot;ice cream&quot;, 
  calories: 200
}

speak(ice_cream);
</code></pre><pre><code>main.ts(16,7): error TS2345: Argument of type &#39;{ nmae: string; calories: number; } 
is not assignable to parameter of type &#39;Food&#39;. 
Property &#39;name&#39; is missing in type &#39;{ nmae: string; calories: number; }&#39;.
</code></pre><p>接口可以在属性后面添加？表示可选<br>可以添加 [propName:  类型] : any 表示可以添加任何某种类型的属性</p>
<pre><code>interface Person {    name: string;
    age?: number;
    [propName: string]: any;
}

const preson: Person = { name: &#39;Tom&#39;, age: 20}
const student: Person = { name: &#39;Tom&#39;}
</code></pre><ul>
<li>类实现接口</li>
</ul>
<p>关键字 implements</p>
<pre><code>interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre><pre><code>interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
</code></pre><blockquote>
<p>官方文档有更详细的介绍 <a href="http://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="external">interfaces</a></p>
</blockquote>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>包括了构造器、继承，抽象类，接口，构造函数、setters、getters、public、private、protected、readonly、static 等</p>
<p>ES6 中也有实现</p>
<ul>
<li>属性<br>默认为 public<br>private 只有自己可以用<br>protected 自己和子类可用<br>readonly 只读 (原理 object.freeze)</li>
<li>抽象类 不能实例化</li>
</ul>
<p>实现继承</p>
<pre><code>class Menu {
  // Our properties:
  // By default they are public, but can also be private or protected.
  items: Array&lt;string&gt;;  // The items in the menu, an array of strings.
  pages: number;        // How many pages will the menu be, a number.

  constructor(item_list: Array&lt;string&gt;, total_pages: number) {
    // The this keyword is mandatory.
    this.items = item_list;    
    this.pages = total_pages;
  }

  // Methods
  list(): void {
    console.log(&quot;Our menu for today:&quot;);
    for(var i=0; i&lt;this.items.length; i++) {
      console.log(this.items[i]);
    }
  }

} 

// Create a new instance of the Menu class.
var sundayMenu = new Menu([&quot;pancakes&quot;,&quot;waffles&quot;,&quot;orange juice&quot;], 1);

// Call the list method.
sundayMenu.list();
</code></pre><pre><code>class HappyMeal extends Menu {
  // Properties are inherited

  // A new constructor has to be defined.
  constructor(item_list: Array&lt;string&gt;, total_pages: number) {
    // In this case we want the exact same constructor as the parent class (Menu), 
    // To automatically copy it we can call super() - a reference to the parent&#39;s constructor.
    super(item_list, total_pages);
  }

  // Just like the properties, methods are inherited from the parent.
  // However, we want to override the list() function so we redefine it.
  list(): void{
    console.log(&quot;Our special menu for children:&quot;);
    for(var i=0; i&lt;this.items.length; i++) {
      console.log(this.items[i]);
    }

  }
}

// Create a new instance of the HappyMeal class.
var menu_for_children = new HappyMeal([&quot;candy&quot;,&quot;drink&quot;,&quot;toy&quot;], 1);

// This time the log message will begin with the special introduction.
menu_for_children.list();
</code></pre><blockquote>
<p>阅读官方文档，获得更多信息 <a href="http://www.typescriptlang.org/docs/handbook/classes.html" target="_blank" rel="external">classes</a></p>
</blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p>
<pre><code>function genericFunc&lt;T&gt;(argument: T): T[] {    
  var arrayOfT: T[] = [];    // Create empty array of type T.
  arrayOfT.push(argument);  // Push, now arrayOfT = [argument].
  return arrayOfT;
}

var arrayFromString = genericFunc&lt;string&gt;(&quot;beep&quot;);
console.log(arrayFromString[0]);        // &quot;beep&quot;
console.log(typeof arrayFromString[0])  // String

var arrayFromNumber = genericFunc(42);
console.log(arrayFromNumber[0]);        // 42
console.log(typeof arrayFromNumber[0])  // number
</code></pre><ul>
<li>带泛型的函数类型</li>
</ul>
<pre><code>let f: () =&gt; any = function() {}

let f: &lt;T&gt;(arg: T) =&gt; T = function() {}
</code></pre><ul>
<li>带泛型的接口</li>
</ul>
<pre><code>interface Gen&lt;T&gt; {    (arg: T) : T
}

function fn&lt;T&gt;(arg: T): T {
    return arg;
}

let id: Gen&lt;number&gt; = fn;

Gen(2)
</code></pre><ul>
<li>带泛型的类 </li>
</ul>
<pre><code>class Gen&lt;T&gt; {    value: T
    add: (x: T, y: T) =&gt; T
}

let myGenNum = new Gen&lt;number&gt;()

myGenNum.value = 0
myGenNum.add = (x, y) =&gt; x + y

myGenNum.add(2,3)
</code></pre><ul>
<li>泛型约束</li>
</ul>
<pre><code>interface Length {    
    length: number
}

function fn&lt;T extends Length&gt;(arg: T): T {
    console.log(arg.length)
    return arg
}

fn&lt;string&gt;(&quot;hello&quot;)
</code></pre><blockquote>
<p>官方文档介绍了更多关于泛型类，泛型类与接口绑定等例子<br><a href="http://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="external">generics</a></p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code>function add(x: number, y: number): number {
    return x + y;
}

let myAdd = function(x: number, y: number): number { return x+y; };
</code></pre><ul>
<li>箭头函数</li>
</ul>
<pre><code>// myAdd has the full function type
let myAdd = function(x: number, y: number): number { return  x + y; };

// The parameters &#39;x&#39; and &#39;y&#39; have the type number
let myAdd: (baseValue:number, increment:number) =&gt; number =
    function(x, y) { return x + y; };
</code></pre><p>参数可选</p>
<pre><code>function buildName(firstName: string, lastName?: string) {
    // ...
}
</code></pre><p>剩余参数</p>
<pre><code>function buildName(firstName: string, ...restOfName: string[]) {
    return firstName + &quot;&quot; + restOfName.join(&quot; &quot;);
}

let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;);
</code></pre><blockquote>
<p>官方文档 <a href="http://www.typescriptlang.org/docs/handbook/functions.html" target="_blank" rel="external">functions</a></p>
</blockquote>
<h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><ul>
<li>联合</li>
</ul>
<pre><code>function padLeft(value: string, padding: string | number) {
    // ...
}

let indentedString = padLeft(&quot;Hello world&quot;, true); // errors during compilation
</code></pre><blockquote>
<p>官方文档 <a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html" target="_blank" rel="external">Advanced Types</a></p>
</blockquote>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>如：require.js （AMD 规范）</p>
<p>exporter.ts</p>
<pre><code>var sayHi = function(): void {
    console.log(&quot;Hello!&quot;);
}

export = sayHi;
</code></pre><p>importer.ts</p>
<pre><code>import sayHi = require(&#39;./exporter&#39;);
sayHi();
</code></pre><p>引入 require.js，查看官方文档 <a href="http://requirejs.org/docs/start.html#add" target="_blank" rel="external">requirejs</a></p>
<pre><code>tsc --module amd *.ts
</code></pre><blockquote>
<p>更多模块化的内容，可查看官方文档 <a href="http://www.typescriptlang.org/docs/handbook/modules.html" target="_blank" rel="external">modules</a></p>
</blockquote>
<h3 id="第三方声明文件"><a href="#第三方声明文件" class="headerlink" title="第三方声明文件"></a>第三方声明文件</h3><p>声明文件用来是说明第三方 JavaScript 库是否和 TypeScript 兼容<br>一个声明文件包含. d.ts 扩展名和关于该库的多种信息，还有 API</p>
<p>声明文件通常是手写的，但也可以用其他人写好的<br><a href="http://definitelytyped.org/" target="_blank" rel="external">DefinitelyTyped</a></p>
<ul>
<li>The repository for high quality TypeScript type definitions<br>也有一个用来管理 TypeScript 定义的 Node.js 流行模块，叫 Typings。</li>
</ul>
<blockquote>
<p>官方文档 <a href="http://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="external">introduction</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong> 三十分钟学会 TypeScript</strong>: <a href="http://web.jobbole.com/87535/" target="_blank" rel="external">http://web.jobbole.com/87535/</a><br><strong> 官方文档 </strong>: <a href="http://www.typescriptlang.org/docs/home.html" target="_blank" rel="external">http://www.typescriptlang.org/docs/home.html</a><br><strong> 中文文档 </strong>: <a href="https://www.tslang.cn/index.html" target="_blank" rel="external">https://www.tslang.cn/index.html</a></p>
]]></content>
    
    <summary type="html">
    
      TypeScript 入门
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="TypeScript" scheme="http://ldqblog.me/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Koa 入门</title>
    <link href="http://ldqblog.me/2017/08/10/Koa-%E5%85%A5%E9%97%A8/"/>
    <id>http://ldqblog.me/2017/08/10/Koa-入门/</id>
    <published>2017-08-10T05:56:00.000Z</published>
    <updated>2017-08-10T06:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Koa-入门"><a href="#Koa-入门" class="headerlink" title="Koa 入门"></a>Koa 入门</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><blockquote>
<p>Node 版本必须 7.6 以上</p>
</blockquote>
<p>克隆代码库</p>
<blockquote>
<p>git clone <a href="https://github.com/ruanyf/koa-demos.git" target="_blank" rel="external">https://github.com/ruanyf/koa-demos.git</a></p>
</blockquote>
<h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><h3 id="1-开启-HTTP-服务器"><a href="#1-开启-HTTP-服务器" class="headerlink" title="1 开启 HTTP 服务器"></a>1 开启 HTTP 服务器</h3><pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

app.listen(3000);
</code></pre><h3 id="2-Context-对象"><a href="#2-Context-对象" class="headerlink" title="2 Context 对象"></a>2 Context 对象</h3><p>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
    ctx.response.body = &#39;Hello World&#39;;
};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-32b69cd94b58aced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>ctx.response 代表 HTTP Response<br>ctx.request 代表 HTTP Request</p>
<h3 id="3-response-类型"><a href="#3-response-类型" class="headerlink" title="3 response 类型"></a>3 response 类型</h3><p>Koa 默认的返回类型是 text/plain</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-cec6dc9a5a3d7674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>ctx.request.accepts 用来判断客户端希望接受什么数据<br>ctx.response.type 指定返回类型</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

if (ctx.request.accepts(&#39;xml&#39;)) {

    ctx.response.type = &#39;xml&#39;;

    ctx.response.body = &#39;&lt;data&gt;Hello World&lt;/data&gt;&#39;;

} else if (ctx.request.accepts(&#39;json&#39;)) {

    ctx.response.type = &#39;json&#39;;

    ctx.response.body = { data: &#39;Hello World&#39; };

} else if (ctx.request.accepts(&#39;html&#39;)) {

    ctx.response.type = &#39;html&#39;;

    ctx.response.body = &#39;&lt;p&gt;Hello World&lt;/p&gt;&#39;;

} else {

    ctx.response.type = &#39;text&#39;;

    ctx.response.body = &#39;Hello World&#39;;

}

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-83caa8dd754ae06e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-df6ccc66b21c55da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-0d84b50c0498d5dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-读取模板文件"><a href="#4-读取模板文件" class="headerlink" title="4 读取模板文件"></a>4 读取模板文件</h3><pre><code>const fs = require(&#39;fs&#39;);
const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

ctx.response.type = &#39;html&#39;;

ctx.response.body = fs.createReadStream(&#39;./demos/template.html&#39;);

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-6cfaa24a42e6277d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="二、路由"><a href="#二、路由" class="headerlink" title="二、路由"></a>二、路由</h2><h3 id="1-原生路由"><a href="#1-原生路由" class="headerlink" title="1 原生路由"></a>1 原生路由</h3><p>ctx.request.path<br>可获取用户请求的路径</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

if (ctx.request.path !== &#39;/&#39;) {

ctx.response.type = &#39;html&#39;;

ctx.response.body = &#39;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&#39;;

} else {

        ctx.response.body = &#39;Hello World&#39;;

}

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-efda28165ef1c82e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-6e9b906b2762e116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-koa-router"><a href="#2-koa-router" class="headerlink" title="2 koa-router"></a>2 koa-router</h3><p>route.get(path, callback)<br>callback 指定 ctx.response.type 和 ctx,response.body</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const route = require(&#39;koa-route&#39;);
const app = new Koa();

const about = ctx =&gt; {

ctx.response.type = &#39;html&#39;;

ctx.response.body = &#39;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&#39;;

};

const main = ctx =&gt; {
        ctx.response.body = &#39;Hello World&#39;;
};

app.use(route.get(&#39;/&#39;, main));
app.use(route.get(&#39;/about&#39;, about));

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-6ba08211d1b585a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-ae9d621c3e1b02a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-6e274232aaba6562.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-52627f567dc12140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="3-静态资源"><a href="#3-静态资源" class="headerlink" title="3 静态资源"></a>3 静态资源</h3><p>koa-static 处理静态资源</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();
const path = require(&#39;path&#39;);
const serve = require(&#39;koa-static&#39;);

const main = serve(path.join(__dirname));

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-51fc1d1d22dd591b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-c10a8f130e9bef9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-32fb0ac20d841137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-302-重定向"><a href="#4-302-重定向" class="headerlink" title="4 302 重定向"></a>4 302 重定向</h3><p>ctx.response.redirect()</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const route = require(&#39;koa-route&#39;);
const app = new Koa();

const redirect = ctx =&gt; {
    ctx.response.redirect(&#39;/&#39;);
};

const main = ctx =&gt; {
    ctx.response.body = &#39;Hello World&#39;;
};

app.use(route.get(&#39;/&#39;, main));
app.use(route.get(&#39;/redirect&#39;, redirect));

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-d49041f899983618.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="三、-中间件"><a href="#三、-中间件" class="headerlink" title="三、 中间件"></a>三、 中间件</h2><h3 id="1-logger"><a href="#1-logger" class="headerlink" title="1 logger"></a>1 logger</h3><p>打印日志</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);

ctx.response.body = &#39;Hello World&#39;;

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-e3ba60c3e0d8d612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-中间件的概念"><a href="#2-中间件的概念" class="headerlink" title="2 中间件的概念"></a>2 中间件的概念</h3><p>logger 函数就叫做 “中间件”（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use() 用来加载中间件。</p>
<p>基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的 main 也是中间件。<br>参数 context 对象， next 函数 （将执行权限交给下一个中间件）</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const logger = (ctx, next) =&gt; {

console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);

next();

}

const main = ctx =&gt; {
ctx.response.body = &#39;Hello World&#39;;
};

app.use(logger);
app.use(main);
app.listen(3000);
</code></pre><h3 id="3-中间件栈"><a href="#3-中间件栈" class="headerlink" title="3 中间件栈"></a>3 中间件栈</h3><p>多个中间件会形成一个栈结构（middle stack），以 “先进后出”（first-in-last-out）的顺序执行。</p>
<blockquote>
<ol>
<li>最外层的中间件首先执行。</li>
<li>调用 next 函数，把执行权交给下一个中间件。    </li>
<li>…  </li>
<li>最内层的中间件最后执行。  </li>
<li>执行结束后，把执行权交回上一层的中间件。  </li>
<li>…  </li>
<li>最外层的中间件收回执行权之后，执行 next 函数后面的代码。  </li>
</ol>
</blockquote>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const one = (ctx, next) =&gt; {

console.log(&#39;&gt;&gt; one&#39;);

next();

console.log(&#39;&lt;&lt; one&#39;);

}

const two = (ctx, next) =&gt; {

console.log(&#39;&gt;&gt; two&#39;);

next();

console.log(&#39;&lt;&lt; two&#39;);

}

const three = (ctx, next) =&gt; {

console.log(&#39;&gt;&gt; three&#39;);

next();

console.log(&#39;&lt;&lt; three&#39;);

}

app.use(one);
app.use(two);
app.use(three);

app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-578836fa12375529.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果没有 next，中间件就不会往内层的中间件执行 而会返回外层中间件</p>
<p>把 two 的 next 注释掉</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-5f85230c6e1857aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-异步中间件"><a href="#4-异步中间件" class="headerlink" title="4 异步中间件"></a>4 异步中间件</h3><pre><code>const fs = require(&#39;fs.promised&#39;);
const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = async function (ctx, next) {
ctx.response.type = &#39;html&#39;;
ctx.response.body = await fs.readFile(&#39;./demos/template.html&#39;, &#39;utf8&#39;);
};

app.use(main);
app.listen(3000);
</code></pre><p>async await 处理异步</p>
<h3 id="5-中间件的合成"><a href="#5-中间件的合成" class="headerlink" title="5 中间件的合成"></a>5 中间件的合成</h3><p>koa-compose 将多个中间件合并成一个</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const compose = require(&#39;koa-compose&#39;);
const app = new Koa();

const logger = (ctx, next) =&gt; {

console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);

next();

}

const main = ctx =&gt; {
    ctx.response.body = &#39;Hello World&#39;;
};

const middlewares = compose([logger, main]);

app.use(middlewares);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-022a1b9a9ed7ab00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-a2cebd71f3c7e6ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="四、错误处理"><a href="#四、错误处理" class="headerlink" title="四、错误处理"></a>四、错误处理</h2><h3 id="500-错误"><a href="#500-错误" class="headerlink" title="500 错误"></a>500 错误</h3><p>500 状态码 —— 代码运行错误</p>
<p>ctx.throw 抛出错误</p>
<p>ctx.throw(500) 抛出 500 错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
  ctx.throw(500);
};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-a8b4b900929fc3d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-5735b99604f5fe9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-759028ee17851586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-20eff4f2acbc2499.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-404-错误"><a href="#2-404-错误" class="headerlink" title="2 404 错误"></a>2 404 错误</h3><p>ctx.response.status = 404 相当于 ctx.throw(404) 返回 404 错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
  ctx.response.status = 404;
  ctx.response.body = &#39;Page Not Found&#39;;
};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-efbe181b5321d060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-feb318b8207c51a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="3-处理错误的中间件"><a href="#3-处理错误的中间件" class="headerlink" title="3 处理错误的中间件"></a>3 处理错误的中间件</h3><p>让最外层中间件负责处理所有中间件的错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const handler = async (ctx, next) =&gt; {
  try {
    await next();
  } catch (err) {
    ctx.response.status = err.statusCode || err.status || 500;
    ctx.response.body = {
      message: err.message
    };
  }
};

const main = ctx =&gt; {
  ctx.throw(500);
};

app.use(handler);
app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-b6a9a47929347e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1e9ed4f3b201c457.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-error-事件的监听"><a href="#4-error-事件的监听" class="headerlink" title="4 error 事件的监听"></a>4 error 事件的监听</h3><p>监听 error 事件也可以处理错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
  ctx.throw(500);
};

app.on(&#39;error&#39;, (err, ctx) =&gt; {
  console.error(&#39;server error&#39;, err);
});

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-5a622ff8b674cb25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-f0dd9f99ad67697b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="5-释放-error-事件"><a href="#5-释放-error-事件" class="headerlink" title="5 释放 error 事件"></a>5 释放 error 事件</h3><p>被 try … catch 捕获的错误不会触发 error 事件</p>
<p>要调用 ctx.app.emit(), 手动释放 error 事件</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const handler = async (ctx, next) =&gt; {
  try {
    await next();
  } catch (err) {
    ctx.response.status = err.statusCode || err.status || 500;
    ctx.response.type = &#39;html&#39;;
    ctx.response.body = &#39;&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;&#39;;
    ctx.app.emit(&#39;error&#39;, err, ctx);
  }
};

const main = ctx =&gt; {
  ctx.throw(500);
};

app.on(&#39;error&#39;, function(err) {
  console.log(&#39;logging error&#39;, err.message);
  console.log(err);
});

app.use(handler);
app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-7d43b2ac6e8bbf7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-506388f40095a28d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-ace175d9f131f842.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="五、Web-App-的功能"><a href="#五、Web-App-的功能" class="headerlink" title="五、Web App 的功能"></a>五、Web App 的功能</h2><h3 id="1-Cookies"><a href="#1-Cookies" class="headerlink" title="1 Cookies"></a>1 Cookies</h3><p>ctx.cookies 读写 Cookie<br>ctx.cookies.get() 获得 Cookie<br>ctx.cookies.set() 设置 Cookie</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = function(ctx) {
  const n = Number(ctx.cookies.get(&#39;view&#39;) || 0) + 1;
  ctx.cookies.set(&#39;view&#39;, n);
  ctx.response.body = n + &#39;views&#39;;
}

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-36da76974f1f7466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1dd21f5fa547ce7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-6878538e8bc07385.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>每刷新一次就会跟增加一次</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-f291e8cb41e4a452.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-fbbf9a5527cfc00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1f41e0f27dbcf93f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-表单"><a href="#2-表单" class="headerlink" title="2 表单"></a>2 表单</h3><p>Web 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。</p>
<p>koa-body 用来从 POST 请求体中提取键值对</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const koaBody = require(&#39;koa-body&#39;);
const app = new Koa();

const main = async function(ctx) {
  const body = ctx.request.body;
  if (!body.name) ctx.throw(400, &#39;.name required&#39;);
  ctx.body = { name: body.name };
};

app.use(koaBody());
app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-b1b4ea7178e40045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-5a56b2cd0f4e2c0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>POST 方法向服务器发送一个键值对，会被正确解析。如果发送的数据不正确，就会收到错误提示。</p>
<p>打开新的命令行窗口</p>
<p>输入</p>
<p>curl -X POST –data “name=Jack” localhost:3000</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1f6bd2a2ae6af739.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>curl -X POST –data “name” localhost:3000</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-bdee1f7139fdeb35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="3-文件上传"><a href="#3-文件上传" class="headerlink" title="3 文件上传"></a>3 文件上传</h3><p>koa-body 处理文件上传</p>
<pre><code>const os = require(&#39;os&#39;);
const path = require(&#39;path&#39;);
const Koa = require(&#39;koa&#39;);
const fs = require(&#39;fs&#39;);
const koaBody = require(&#39;koa-body&#39;);

const app = new Koa();

const main = async function(ctx) {
  const tmpdir = os.tmpdir();
  const filePaths = [];
  const files = ctx.request.body.files || {};

  for (let key in files) {
    const file = files[key];
    const filePath = path.join(tmpdir, file.name);
    console.log(filePath)
    const reader = fs.createReadStream(file.path);
    const writer = fs.createWriteStream(filePath);
    reader.pipe(writer);
    filePaths.push(filePath);
  }

  ctx.body = filePaths;
};

app.use(koaBody({ multipart: true }));
app.use(main);
app.listen(3000);
</code></pre><p>在新的命令行窗口输入</p>
<p>curl –form upload=@/path/to/file <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a></p>
<p>/path/to/file 替换成真实路径</p>
<p>curl –form upload=@/D:/Nodejs/other/koa-demos/demos/21.js <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-7c57a9a9333dccf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">   </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Koa 框架教程 by 阮一峰 </strong>：<a href="http://www.ruanyifeng.com/blog/2017/08/koa.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2017/08/koa.html</a></p>
]]></content>
    
    <summary type="html">
    
      参考阮一峰老师的Koa入门教程
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="node" scheme="http://ldqblog.me/tags/node/"/>
    
      <category term="Koa" scheme="http://ldqblog.me/tags/Koa/"/>
    
      <category term="后端" scheme="http://ldqblog.me/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>music video test</title>
    <link href="http://ldqblog.me/2017/07/31/music-video-test/"/>
    <id>http://ldqblog.me/2017/07/31/music-video-test/</id>
    <published>2017-07-31T13:00:43.000Z</published>
    <updated>2017-07-31T18:02:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="歌曲"><a href="#歌曲" class="headerlink" title="歌曲"></a>歌曲</h3><div class="aplayer" data-id="31673404" data-server="netease" data-type="song"></div>

<h3 id="歌单"><a href="#歌单" class="headerlink" title="歌单"></a>歌单</h3><div class="aplayer" data-id="11100236" data-server="netease" data-type="playlist" data-mode="random"></div>

<h3 id="b-站视频"><a href="#b-站视频" class="headerlink" title="b 站视频"></a>b 站视频</h3><iframe class="bilibiliVideo" src="https://www.bilibili.com/html/html5player.html?cid=5090828&aid=3227348" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

]]></content>
    
    <summary type="html">
    
      测试音乐
    
    </summary>
    
    
      <category term="music" scheme="http://ldqblog.me/tags/music/"/>
    
      <category term="video" scheme="http://ldqblog.me/tags/video/"/>
    
      <category term="test" scheme="http://ldqblog.me/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Redux 简介</title>
    <link href="http://ldqblog.me/2017/07/23/Redux-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/07/23/Redux-简介/</id>
    <published>2017-07-22T16:29:31.000Z</published>
    <updated>2017-10-12T16:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code>
redux react-redux

const 文件
action 
aciton creator
reducer
store
state
dispatch
combineReducers

connect
mapStateToProps
mapDispatchToProps
middleware
</code></pre><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><pre><code>保存数据的一个单一状态树
</code></pre><p>要通过 createStore 方法生成    </p>
<pre><code>import {createStore} from &#39;redux&#39;
const store = createStore(fn)
</code></pre><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>  Action 是一个对象。其中的 type 属性是必须的，表示 Action 的名称。<br>  其他属性可以自由设置。</p>
<pre><code>  const action = {
    type: &#39;ADD_TODO&#39;,
    payload: &#39;Learn Redux&#39;
  }
</code></pre><h2 id="action-creator"><a href="#action-creator" class="headerlink" title="action creator"></a>action creator</h2><pre><code>每次手写 action 很麻烦，于是要定义一个函数来生成 action，该函数就是
action creator
</code></pre><pre><code>const chooseNav = (index) =&gt; {
    return {
        type: CHOOSE_NAV,
        index
    }
}

const action = chooseNav(1)
</code></pre><h2 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch"></a>store.dispatch</h2><p>  要触发 action，就要使用 store.dispatch</p>
<pre><code>import { createStore } from &#39;redux&#39;;
const store = createStore(fn)

store.dispatch({
  type: &#39;ADD_TODO&#39;,
  payload: &#39;Learn Redux&#39;
})
</code></pre><h2 id="const-文件"><a href="#const-文件" class="headerlink" title="const 文件"></a>const 文件</h2><p>  将 action.type 定义为常量<br>  reducer 通过 action.type 判断是哪个 action</p>
<h2 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h2><p>  更新数据， 返回新的 state</p>
<pre><code>const initState = {

}

const reducer = (state = initState, action) =&gt; {
    switch(action.type) {
        case xxx:
            xxx
            break
        case yyy:
            yyy
            break
        default 
           return state 

    }
}
</code></pre><h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><pre><code>合并多个 reducer
</code></pre><pre><code>import { combineReducers } from &#39;redux&#39;


const chatReducer = combineReducers({
  chatLog,
  statusMessage,
  userName
})

export default chatReducer
</code></pre><h2 id="创建-stroe"><a href="#创建-stroe" class="headerlink" title="创建 stroe"></a>创建 stroe</h2><pre><code>import chatReducer from &#39;./xxx&#39;


const store = createStore(
    chatReducer
)

export default store
</code></pre><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>   store 添加在 Provider 组件</p>
<pre><code>import store from &#39;./yyy&#39;
import {Provider} from &#39;react-redux&#39;



ReactDOM.render(
    &lt; Provider store={store} &gt;
       ...
    &lt; /Provider &gt;, 
document.getElementById(&#39;root&#39;))
</code></pre><h2 id="在组件中使用"><a href="#在组件中使用" class="headerlink" title="在组件中使用"></a>在组件中使用</h2><pre><code> mapStateToProps 传 props 给组件
 mapDispatchToProps 传 dispatch 方法 给组件
 通过 connect 传个组件 
</code></pre><p>例子</p>
<pre><code>import React, { Component } from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;
import CommentList from &#39;../components/CommentList.js&#39;
import { initComments, deleteComment} from &#39;../reducers/comments.js&#39;
import {connect} from &#39;react-redux&#39;



class CommentListContainer extends Component {
    static propTypes = {
        comments: PropTypes.array,
        initComments: PropTypes.func,
        deleteComment: PropTypes.func
    }

    componentWillMount() {
        this._loadComments()
    }

    _loadComments() {
        let comments = localStorage.getItem(&#39;comments&#39;)
        comments = comments ? JSON.parse(comments) : []
        this.props.initComments(comments)
    }

    handleDeleteComment(index) {
        const {comments} = this.props
        const newComments = [
            ...comments.slice(0, index),
            ...comments.slice(index + 1)
        ]
        localStorage.setItem(&#39;comments&#39;, JSON.stringify(newComments))
        if(this.props.onDeleteComment) {
            this.props.onDeleteComment(index)
        }
    }

    render() {
        return (
            &lt; CommentList 
                comments = {this.props.comments}
                onDeleteComment={this.handleDeleteComment.bind(this)}
            / &gt;
        )
    }
}

// 评论列表从 state.comments 中获取
const mapStateToProps = state =&gt; {
    return {
        comments: state.comments
    }
}

const mapDispatchToProps = dispatch =&gt; {
    return {
        // 提供给 CommentListContainer
        // 当从 LocalStorage 加载评论列表以后就会通过这个方法
        // 把评论列表初始化到 state 当中
        initComments: (comments) =&gt; {
            dispatch(initComments(comments))
        } ,
        // 删除评论
        onDeleteComment: (commentIndex) =&gt; {
            dispatch(deleteComment(commentIndex))
        }
    }
}


// 将 CommentListContainer connect 到 store
// 会把 comments、initComments、onDeleteComment 传给 CommentListContainer

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(CommentListContainer)
</code></pre><h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><p>   强化 redux 的功能</p>
<p>原理<br>   改写 store.dispatch </p>
<p>因为 reducer 是纯函数，只承担计算 State 的功能，不合适承担其他功能<br>View 与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。<br>Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</p>
<p>compose<br>  从右到左来组合多个函数。</p>
<p>这是函数式编程中的方法，为了方便，被放到了 Redux 里。<br>当需要把多个 store 增强器 依次执行的时候，需要用到它。</p>
<p>例子</p>
<pre><code>import {createStore, applyMiddleware, compose} from &#39;redux&#39;
import reducers from &#39;./reducers.js&#39;
import thunkMiddleware  from &#39;redux-thunk&#39;
import createLogger from &#39;redux-logger&#39;



export default () =&gt; {
    const middleware = [thunkMiddleware, createLogger]


    const composeEnhancers = 
        process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;
            typeof window === &#39;object&#39; &amp;&amp;
            window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ 
            ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
                // Specify extension’s options like name, actionsBlacklist, actionsCreators, serialize...
                }) 
            : compose

    const enhancers =  composeEnhancers(
        applyMiddleware(...middleware)
    )

    const store = createStore(
        reducers,
        enhancers
    )

    return store
}
</code></pre><h3 id="处理异步"><a href="#处理异步" class="headerlink" title="处理异步"></a>处理异步</h3><pre><code>

redux-think + async/await
    redux-think 让 dispatch 能接受 函数作为参数 （原来参数只能是对象）
    利用 async/await 的调用方式处理异步

redux-promise
    利用 promise 的调用方式处理异步


redux-promise-middleware
    优化 redux-promise


redux-saga (generator/yield)
     利用 generator/yield 的调用方式处理异步
     提供大量的 api


redux-observable (RxJS)
     利用 RxJS 的调用方式处理异步
     提供大量的 api


redux-loop
</code></pre><h3 id="其他中间件"><a href="#其他中间件" class="headerlink" title="其他中间件"></a>其他中间件</h3><pre><code>
redux-logger
</code></pre><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p><a href="https://github.com/sorrycc/blog/issues/1" target="_blank" rel="external">看看 dva 的前身 React + Redux 最佳实践，知道 dva 是怎么来的</a></p>
<h3 id="优秀的相关框架"><a href="#优秀的相关框架" class="headerlink" title="优秀的相关框架"></a>优秀的相关框架</h3><p><a href="https://github.com/dvajs/dva" target="_blank" rel="external">dva</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong> 理解 React</strong>: <a href="https://www.zhihu.com/question/41312576?sort=created" target="_blank" rel="external">https://www.zhihu.com/question/41312576?sort=created</a><br><strong>Redux 入门教程（一）—— 阮一峰 </strong>: <a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</a></p>
]]></content>
    
    <summary type="html">
    
      Redux 入门简单介绍
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://ldqblog.me/tags/React/"/>
    
      <category term="Redux" scheme="http://ldqblog.me/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>React-Router 简介</title>
    <link href="http://ldqblog.me/2017/07/15/React-Router-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/07/15/React-Router-简介/</id>
    <published>2017-07-14T16:27:53.000Z</published>
    <updated>2017-10-12T16:45:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Router"><a href="#React-Router" class="headerlink" title="React-Router"></a>React-Router</h1><p><a href="http://ldqblog.me/learn-react-router/build/">学习 React-Router 的例子</a></p>
<p><a href="https://github.com/LDQ-first/learn-react-router" target="_blank" rel="external">源码</a></p>
]]></content>
    
    <summary type="html">
    
      React-Router 入门简单介绍
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://ldqblog.me/tags/React/"/>
    
      <category term="React-Router" scheme="http://ldqblog.me/tags/React-Router/"/>
    
  </entry>
  
  <entry>
    <title>React 简介</title>
    <link href="http://ldqblog.me/2017/07/13/React-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/07/13/React-简介/</id>
    <published>2017-07-12T16:15:33.000Z</published>
    <updated>2017-10-14T01:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-简介"><a href="#React-简介" class="headerlink" title="React 简介"></a>React 简介</h1><blockquote>
<p>React.js 是一个 UI = f(states) 的框架，为了解决更新的问题，<br>React.js 使用了 virtual dom，virtual dom 通过 diff 修改 dom，来实现高效的 dom 更新。</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>一般写在 render 生命周期函数里</p>
<p>语法:</p>
<pre><code>return (
    写 HTML 

    注意 有些 属性要改写 
    如 ： class =》 className 

    标签要闭合 &lt; img src=&quot;&quot;&gt; =》 &lt; img src=&quot;&quot; /&gt; 

    可以添加 js
    但要用 {} 括起来 


)
</code></pre><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><pre><code>import React, { Component } from &#39;react&#39;

class NotFound extends Component {

    render () {

        return (


        )
    }
}
</code></pre><p>例子</p>
<pre><code>import React, { Component } from &#39;react&#39;


export default class NotFound extends Component {

    render() {

        return (
            &lt; Container className=&quot;noPadding&quot; &gt;
               &lt; NotFoundDiv &gt;
                   &lt; h1 className=&quot;title&quot; &gt;404&lt; /h1 &gt;
               &lt; /NotFoundDiv &gt;
            &lt; /Container &gt;
        )
    }
}
</code></pre><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>获取 dom 元素</p>
<pre><code>&lt; div className=&quot;contactContent&quot; 
    ref={contact =&gt; this._contact = contact} &gt;       
&lt; /div &gt;
</code></pre><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>数据</p>
<pre><code>constructor(props) {
    super(props) 
    this.state = {

    }
}
</code></pre><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>   更新 state </p>
<p>注意：</p>
<ol>
<li>setState 不会立刻改变 React 组件中 state 的值</li>
<li>函数式的 setState 用法</li>
</ol>
<p>看这篇文章<br>   <a href="https://zhuanlan.zhihu.com/p/25954470" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/25954470</a></p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>子组件接受父组件的数据</p>
<pre><code>const { _this } = this.props
</code></pre><h3 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h3><p>props 类型检查</p>
<pre><code>import PropTypes from &#39;prop-types&#39;


static get propTypes() {
    return {
        _this: PropTypes.object
    }
}
</code></pre><h4 id="classNames-第三方库"><a href="#classNames-第三方库" class="headerlink" title="classNames(第三方库)"></a>classNames(第三方库)</h4><p> 处理各类名</p>
<pre><code>import classNames from &#39;classnames&#39;

const { isSpread } = this.state

className={classNames(&#39;toggle&#39;, {active: isSpread})
</code></pre><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>事件<br>React 支持许多事件<br>官方文档有列出<br><a href="https://reactjs.org/docs/events.html#supported-events" target="_blank" rel="external">https://reactjs.org/docs/events.html#supported-events</a></p>
<pre><code>
&lt;a href=&quot;javascript:;&quot; className=&#39;toggle&#39;} 
onClick={() =&gt; { this._toggle() }}&gt;
    &lt;i className=&quot;bar&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
</code></pre><h3 id="lists-key-map"><a href="#lists-key-map" class="headerlink" title="lists key map"></a>lists key map</h3><p>循环</p>
<pre><code>
const { navArr} = this.state

const navs = navArr.map((item, index) =&gt; {
    return (
        &lt;li key={index} className=&#39;nav&#39;} &gt;
            {item.name}
        &lt;/li&gt;
    )
})

&lt;ul className=&#39;navs&#39;&gt;
    {navs ? navs : null}
&lt;/ul&gt;
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>npm install -g create-react-app

create-react-app my-app
cd my-app/
npm start
</code></pre><p>浏览器自动打开 <a href="http://localhost:3000/" target="_blank" rel="external">http://localhost:3000/</a></p>
<p>写完</p>
<p>npm run build 构建打包</p>
<p>生成的 build 文件夹就是要发布的文件</p>
<h4 id="文件夹结构"><a href="#文件夹结构" class="headerlink" title="文件夹结构"></a>文件夹结构</h4><pre><code>
my-app
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── public
│   └── favicon.ico
│   └── index.html
│   └── manifest.json
└── src
    └── App.css
    └── App.js
    └── App.test.js
    └── index.css
    └── index.js
    └── logo.svg
    └── registerServiceWorker.js
</code></pre><p>在 src 中编写代码</p>
<p>也可以自己搭建一个脚手架</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>React 文档 </strong>: <a href="https://reactjs.org/" target="_blank" rel="external">https://reactjs.org/</a></p>
]]></content>
    
    <summary type="html">
    
      React 入门简单介绍
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://ldqblog.me/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>vue 生命周期</title>
    <link href="http://ldqblog.me/2017/06/25/Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://ldqblog.me/2017/06/25/Vue-生命周期/</id>
    <published>2017-06-25T01:46:46.000Z</published>
    <updated>2017-10-14T01:51:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="生命周期钩子的函数"><a href="#生命周期钩子的函数" class="headerlink" title="生命周期钩子的函数"></a>生命周期钩子的函数</h3><p>实例化</p>
<p>beforeCreate<br>实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前</p>
<p>created<br>实例创建完成后</p>
<p>beforeMount<br>挂载前</p>
<p>mounted<br>挂载</p>
<p>beforeUpdate<br>数据更新前，发生在虚拟 DOM 重新渲染和打补丁之前</p>
<p>updated<br>数据更新，虚拟 DOM 重新渲染和打补丁后</p>
<p>activated<br>keep-alive 组件激活时</p>
<p>deactivated<br>keep-alive 组件停用时</p>
<p>beforeDestroy<br>实例销毁前</p>
<p>destroyed<br>实例销毁后</p>
<h3 id="实际场景应用"><a href="#实际场景应用" class="headerlink" title="实际场景应用"></a>实际场景应用</h3><p>beforeCreate<br>实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前</p>
<p>读取不到数据 (data) 和方法(methods)</p>
<p>created<br>实例创建完成后</p>
<p>在这一步，实例已完成以下的配置：数据观测 (data observer)，<br>属性和方法的运算，watch/event 事件回调。<br>然而，挂载阶段还没开始，$el 属性目前不可见。</p>
<p>可以调用实例的数据 和 方法</p>
<p>如：异步函数的调用, 初始化</p>
<p>异步数据获取后的 dom 操作可以用<br>vue.$nextTick 方法操作<br>可以对不同的异步数据做不同的 dom 操作<br>某个数据的某一次变化</p>
<p>对某个数据的变化做统一处理可以用 watch</p>
<p>beforeMount<br>挂载前</p>
<p>mounted<br>挂载</p>
<p>有初始数据的 dom 渲染, 可以获取 dom</p>
<p>beforeUpdate<br>数据更新前，发生在虚拟 DOM 重新渲染和打补丁之前</p>
<p>updated<br>数据更新，虚拟 DOM 重新渲染和打补丁后<br>数据更新后的操作</p>
<p>所有数据更新后做统一的操作</p>
<p>activated<br>keep-alive 组件激活时</p>
<p>deactivated<br>keep-alive 组件停用时</p>
<p>beforeDestroy<br>实例销毁前</p>
<p>destroyed<br>实例销毁后</p>
<p>vue.$destroyed 主动触发</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h2&gt;&lt;h3 id=&quot;生命周期钩子的函数&quot;&gt;&lt;a href=&quot;#生命周期钩子的函数&quot; class=&quot;headerlink&quot; title=
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://ldqblog.me/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vuex 简介</title>
    <link href="http://ldqblog.me/2017/06/24/Vuex-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/06/24/Vuex-简介/</id>
    <published>2017-06-24T15:57:24.000Z</published>
    <updated>2017-10-12T16:16:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>vue 组件通过 dispatch 来触发 actions [这步可省略， 一般用于处理异步]<br>actions 再通过 commit 触发 mutations , 改变 store 上的 state<br>最终改变 vue 组件 的 view </p>
<p>常与 computed 结合 </p>
<p>state 是唯一数据来源</p>
<p>vuex 是单一状态树</p>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>getters 派生出一些新的状态</p>
<p>Vuex 允许我们在 store 中定义 “getter”（可以认为是 store 的计算属性）。<br>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，<br>且只有当它的依赖值发生了改变才会被重新计算。</p>
<pre><code>const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: &#39;...&#39;, done: true },
      { id: 2, text: &#39;...&#39;, done: false }
    ]
  },
  getters: {
    doneTodos: state =&gt; {
      return state.todos.filter(todo =&gt; todo.done)
    }
  }
})
</code></pre><p>Getter 会暴露为 store.getters 对象：</p>
<p>store.getters.doneTodos // -&gt; [{ id: 1, text: ‘…’, done: true }]<br>Getter 也可以接受其他 getter 作为第二个参数：</p>
<pre><code>getters: {
  // ...
  doneTodosCount: (state, getters) =&gt; {
    return getters.doneTodos.length
  }
}
store.getters.doneTodosCount // -&gt; 1
</code></pre><p>我们可以很容易地在任何组件中使用它：</p>
<pre><code>computed: {
  doneTodosCount () {
    return this.$store.getters.doneTodosCount
  }
}
</code></pre><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p>
<pre><code>getters: {
  // ...
  getTodoById: (state, getters) =&gt; (id) =&gt; {
    return state.todos.find(todo =&gt; todo.id === id)
  }
}
store.getters.getTodoById(2) // -&gt; { id: 2, text: &#39;...&#39;, done: false }
</code></pre><p>mapGetters 辅助函数 类似 mapState</p>
<p>在 computed 中使用… 运算符获取 getters</p>
<h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>更改 vuex 的 store 中的状态的唯一方法是提交 mutations</p>
<p>action 通过 mutations 间接改变 store 的状态</p>
<p>acion 处理异步操作</p>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>将 store 状态分割成模块（modules）<br>便于管理</p>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><pre><code>store
  module 
    moduleHome.js
  mutations
    mutationsHome.js
  index.js




moduleHome.js

import mutations from &#39;../mutations/mutationsHome.js&#39;

export default {
    state: {
        isFullScreen: false
    },
    mutations: mutations()
}




mutationsHome.js

export default () =&gt; {
    return {
        FullScreen (state, isFullScreen) {
            state.isFullScreen = isFullScreen
        }
    }
}



index.js

import Vuex from &#39;vuex&#39;
import Vue from &#39;vue&#39;
Vue.use(Vuex)

import moduleHome from &#39;./module/moduleHome.js&#39;


export default new Vuex.Store({
    modules: {
        home: moduleHome
    }
})   





main.js

import Vue from &#39;vue&#39;
import App from &#39;./App&#39;
import store from &#39;./store/index.js&#39;

Vue.config.productionTip = false



new Vue({
  el: &#39;#app&#39;,
  store,
  render: h =&gt; h(App)
})
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>const Sidebar = resolve =&gt; require([&#39;../../components/Sidebar.vue&#39;], resolve)
const MainContent = resolve =&gt; require([&#39;../../components/MainContent.vue&#39;], resolve)
const Buttons = resolve =&gt; require([&#39;../../components/Button.vue&#39;], resolve)

import { mapState } from &#39;vuex&#39;

export default {
    name: &#39;Home&#39;,
    data () {
        return {

        } 
    },
    computed: {
        ...mapState({
            isFullScreen: state =&gt; state.home.isFullScreen
        })
        /*
            isFullScreen() {
                return this.$store.state.home.isFullScreen
            }
        */
    },
    components: {
        Buttons,
        Sidebar,
        MainContent
    },
    methods: {
        cancelFullScreen () {
            this.$store.commit(&#39;FullScreen&#39;, false)
        }
    }
}
</code></pre><h3 id="对比-redux"><a href="#对比-redux" class="headerlink" title="对比 redux"></a>对比 redux</h3><pre><code>
都是基于 Flux
吸取 redux 的优点
放弃强制的 immutability
api 更简洁
性能较好
与 vue 契合度更高
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-c893179ac3e708f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuex.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Vuex 文档 </strong>: <a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="external">https://vuex.vuejs.org/zh-cn/</a><br><strong> 尤大的答案 </strong>: <a href="https://www.zhihu.com/question/38546875/answer/76970954" target="_blank" rel="external">https://www.zhihu.com/question/38546875/answer/76970954</a></p>
]]></content>
    
    <summary type="html">
    
      Vuex 入门简单介绍
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://ldqblog.me/tags/Vue/"/>
    
      <category term="Vuex" scheme="http://ldqblog.me/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue 版 CNode 社区 (二)</title>
    <link href="http://ldqblog.me/2017/06/22/Vue%E7%89%88CNode%E7%A4%BE%E5%8C%BA-%E4%BA%8C/"/>
    <id>http://ldqblog.me/2017/06/22/Vue版CNode社区-二/</id>
    <published>2017-06-22T02:10:32.000Z</published>
    <updated>2017-10-13T05:35:17.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-版-CNode-社区技术详情"><a href="#Vue-版-CNode-社区技术详情" class="headerlink" title="Vue 版 CNode 社区技术详情"></a>Vue 版 CNode 社区技术详情</h1><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue 配合 Vue-Router，Vuex</p>
<p>实现路由跳转，路由过渡，状态管理</p>
<p>Vue-lazyload<br>头像图片懒加载</p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>实现 api 请求等的异步处理</p>
<h2 id="Moment-js"><a href="#Moment-js" class="headerlink" title="Moment.js"></a>Moment.js</h2><p>处理时间的显示</p>
<h2 id="Simplemde"><a href="#Simplemde" class="headerlink" title="Simplemde"></a>Simplemde</h2><p>用于实现 markdown 方式回复，发帖</p>
<h2 id="loaclStorge"><a href="#loaclStorge" class="headerlink" title="loaclStorge"></a>loaclStorge</h2><p>用于存储用户的登录信息<br>防止刷新或重开网页后登录失效</p>
<h2 id="滚动加载"><a href="#滚动加载" class="headerlink" title="滚动加载"></a>滚动加载</h2><p>通过监听 scroll 事件来实现</p>
<pre><code>
 scroll(e) {
            if(e.target.clientHeight  &gt; e.target.scrollTop) {
                const e = this.$refs.articles;
                bus.$emit(&#39;isShowTop&#39;, {isShow: false, e});
            }
            else {
                  const e = this.$refs.articles;
                bus.$emit(&#39;isShowTop&#39;, {isShow: true, e});
            }
            const pathArr = [&#39;/&#39;, &#39;/articleList/all&#39;, &#39;/articleList/good&#39;, &#39;/articleList/share&#39;, &#39;/articleList/ask&#39;, &#39;/articleList/job&#39;, &#39;/articleList/dev&#39;];
            if(pathArr.indexOf(this.$route.path) === -1) {
                return;
            }
            if(!this.over &amp;&amp; !this.isLoading) {
                let isOver = e.target.clientHeight + Math.ceil(e.target.scrollTop) &gt;= e.target.scrollHeight - 100;
                if(isOver) {
                    console.log(this.page)
                    this.page ++;
                    this.$store.commit(&#39;changeMore&#39;, true);
                    this.$store.commit(&#39;changeTab&#39;,{isLoading: true});
                    axios.get(`https://cnodejs.org/api/v1/topics?page=${this.page}&amp;tab=${this.tab}`)
                          .then(result =&gt;result.data.data)
                          .then(articleList =&gt; {
                              if(!articleList.length) {
                                  this.$store.commit(&#39;Over&#39;, true);
                                  this.$store.commit(&#39;changeMore&#39;, false);
                                  return ;
                              }
                              this.$store.commit(&#39;changeTab&#39;,
                               {articleList: this.articleList.concat(articleList), isLoading: false});
                          })
                          .then(() =&gt; this.$store.commit(&#39;changeMore&#39;, false));
                }
            }
        },
</code></pre><h2 id="Canvas-loading"><a href="#Canvas-loading" class="headerlink" title="Canvas loading"></a>Canvas loading</h2><p>利用  window.requestAnimationFrame  做动画</p>
<p>画个白色的圆  whiteCircle() </p>
<p>画文字 text()</p>
<p>画蓝色的圆形进度条 blueCircle()</p>
<pre><code>
    data() {
        return {
            canvas: {},
            context: {},
            centerX: 0,
            centerY: 0,
            radius: 80,
            rad: 0,
            speed: 0.1,
            timer: &#39;&#39;,
        }
    },
    mounted() {
        this.init();
    },
    methods: {
        init() {
            const canvas = this.$refs.canvasLoading;
            const context = canvas.getContext(&#39;2d&#39;);

            this.canvas = canvas;
            this.context = context;
            this.centerX = canvas.width/2;
            this.centerY = canvas.height/2;
            this.rad = 2*Math.PI/100;
            this.speed = 0.2;

             window.requestAnimFrame = (function(){
            return  window.requestAnimationFrame       ||
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame    ||
                    window.oRequestAnimationFrame      || 
                    window.msRequestAnimationFrame     || 
                   function ( callback ){
                        window.setTimeout(callback, 1000 / 60);
                    };
            })();

             window.cancelAnimationFrame = (function(){
            return  window.cancelAnimationFrame       ||
                    window.webkitCancelAnimationFrame ||
                    window.mozCancelAnimationFrame    ||
                    window.oCancelAnimationFrame      || 
                    window.msCancelAnimationFrame     || 
                    function(){
                        window.clearTimeout(this.timer);
                    };
            })();
            this.loading();
        },  
        loading() {
            this.timer = requestAnimationFrame(this.loading, this.canvas);
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.whiteCircle();
            this.text();
            this.blueCircle();
            if(this.speed &gt; 100) {
                this.speed = 0;
                cancelAnimationFrame(this.timer);                
            this.$emit(&#39;BeginLoading&#39;);
            }
            else {
                this.speed += 0.4;
            }
        },
        whiteCircle() {
            this.context.save();
            this.context.beginPath();
            this.context.strokeStyle = &#39;#FFF&#39;;
            this.context.arc(this.centerX, this.centerY, this.radius, 0, Math.PI * 2, false );
            this.context.stroke();
            this.context.closePath();
            this.context.restore();
        },
        text() {
            this.context.save();
            this.context.strokeStyle = &#39;#FFF&#39;;
            this.context.font = &#39;30px Arial&#39;;
            const text = this.speed.toFixed(0) + &#39;%&#39;;
            const textWidth = this.context.measureText(text).width;
            const translateWidth = (textWidth/2).toFixed(0);
             this.context.strokeText(text, 
                this.centerX - translateWidth + 5, this.centerY + 10);

            this.context.stroke();
            this.context.restore();
        },
        blueCircle() {
            this.context.save();
            this.context.strokeStyle = &#39;rgba(3,169,244,1)&#39;;
            this.context.lineWidth = 10;
            this.context.beginPath();
            this.context.arc(this.centerX, this.centerY, this.radius,
             -Math.PI/2, -Math.PI/2 + this.speed * this.rad, false );
            this.context.stroke();
            this.context.closePath();
            this.context.restore();
        },

    }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Vue-版-CNode-社区技术详情&quot;&gt;&lt;a href=&quot;#Vue-版-CNode-社区技术详情&quot; class=&quot;headerlink&quot; title=&quot;Vue 版 CNode 社区技术详情&quot;&gt;&lt;/a&gt;Vue 版 CNode 社区技术详情&lt;/h1&gt;&lt;h2 id=&quot;V
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="SPA" scheme="http://ldqblog.me/tags/SPA/"/>
    
      <category term="Vue" scheme="http://ldqblog.me/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue 版 CNode 社区 (一)</title>
    <link href="http://ldqblog.me/2017/06/20/Vue%E7%89%88CNode%E7%A4%BE%E5%8C%BA-%E4%B8%80/"/>
    <id>http://ldqblog.me/2017/06/20/Vue版CNode社区-一/</id>
    <published>2017-06-20T01:43:59.000Z</published>
    <updated>2017-10-13T05:36:30.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-版-CNode-社区介绍"><a href="#Vue-版-CNode-社区介绍" class="headerlink" title="Vue 版 CNode 社区介绍"></a>Vue 版 CNode 社区介绍</h1><h2 id="预览地址"><a href="#预览地址" class="headerlink" title="预览地址"></a>预览地址</h2><p><a href="http://ldqblog.me/vue-CNode/dist/#/">预览地址</a></p>
<h2 id="手机可访问二维码"><a href="#手机可访问二维码" class="headerlink" title="手机可访问二维码"></a>手机可访问二维码</h2><p><img src="http://ldqblog.me/vue-CNode/static/img/mobile.png" alt="Vue 版 CNode">  </p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/LDQ-first/vue-CNode" target="_blank" rel="external">GitHub</a></p>
<hr>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>做 Vue 版 CNode 社区的原因：</p>
<pre><code>1. 学习 Vue 全家桶构建项目
2. CNode 社区提供了 API
3. 做一个属于自己的 CNode 社区，当然仅限于前端
</code></pre><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li><strong>Vue2.2</strong>: [ 前端框架 ]</li>
<li><strong>Vuex</strong>: [ 状态管理, 组件通信 ] </li>
<li><strong>Vue-router</strong>: [ 配置路由，组件切换 ]</li>
<li><strong>Vue-lazyload</strong>: [ 图片懒加载 ]</li>
<li><strong>ES6/7</strong>: [ JS 版本 ]</li>
<li><strong>Webpack</strong>: [ 模块化处理，编译打包 ]</li>
<li><strong>Express</strong>: [ 服务器 ]</li>
<li><strong>Axios</strong>: [ 基于 Promise 处理 HTTP 请求 ]</li>
<li><strong>SASS</strong>(<strong>SCSS</strong>): [ css 预处理器 ]</li>
<li><strong>Normalize.css</strong>: [ 处理浏览器默认样式 ]</li>
<li><strong>Font-awesome</strong>: [ 字体图标 ]</li>
<li><strong>Moment.js</strong>: [ 处理时间显示 ]</li>
<li><strong>Simplemde</strong>: [ markdown 编辑器 ]</li>
<li><strong>Highlight.js</strong>: [ 语法高亮 ]</li>
<li><strong>Flex</strong>: [ 弹性布局 ]</li>
<li><strong>Canvas</strong>: [ 首页 loading 效果，按钮的波纹效果 ]</li>
<li><strong>loaclStorge</strong>: [ 本地存储用户信息 ]</li>
</ul>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="http://ldqblog.me/vue-CNode/static/img / 项目结构. jpg" alt="项目结构思维导图"></p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://ldqblog.me/vue-CNode/static/result/001.jpg" alt="001">  </p>
<p><img src="http://ldqblog.me/vue-CNode/static/result/002.jpg" alt="002">  </p>
<p><img src="http://ldqblog.me/vue-CNode/static/result/003.jpg" alt="003">  </p>
<p><img src="http://ldqblog.me/vue-CNode/static/result/004.jpg" alt="004">  </p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>实现了<br>登录 (使用官方提供的 access token 方法登录)，<br>回复，发帖，（支持 Markdown）<br>滚动加载更多，（监听 scroll 事件）<br>收藏，点赞，<br>查看消息，（支持已读消息和未读消息）<br>更换主题色，(利用 Vuex，四种主题色可更换)<br>退出登录<br>查看个人信息</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>没有下拉刷新</li>
<li>图片点击查看大图不支持手指缩放，<br>导致移动端看大图体验差</li>
<li>利用 Vuex 实现的更换主题色方法比较繁琐，<br>考虑是否有其他更优的方法</li>
<li>项目结构有待改善，<br>纯组件和视图组件应分开，<br>sass 文件单独出来，没有利用到 scoped<br>vuex 没有分模块</li>
</ul>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>改善问题<br>优化代码</p>
<hr>
<h2 id="下一篇"><a href="#下一篇" class="headerlink" title="下一篇"></a>下一篇</h2><p><a href="http://ldqblog.me/2017/06/22/Vue%E7%89%88CNode%E7%A4%BE%E5%8C%BA-%E4%BA%8C/">Vue 版 CNode 社区 (二)</a></p>
<p><strong> 感谢 CNode 社区提供 API 供人学习 </strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Vue 文档 </strong>: <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="external">https://cn.vuejs.org/v2/guide/</a><br><strong>CNode API</strong>: <a href="https://cnodejs.org/api" target="_blank" rel="external">https://cnodejs.org/api</a></p>
]]></content>
    
    <summary type="html">
    
      Vue版CNode社区总结
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="SPA" scheme="http://ldqblog.me/tags/SPA/"/>
    
      <category term="Vue" scheme="http://ldqblog.me/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Router 简介</title>
    <link href="http://ldqblog.me/2017/06/18/Vue-Router-%E7%AE%80%E4%BB%8B/"/>
    <id>http://ldqblog.me/2017/06/18/Vue-Router-简介/</id>
    <published>2017-06-18T15:29:31.000Z</published>
    <updated>2017-10-12T16:04:46.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-Router-简介"><a href="#Vue-Router-简介" class="headerlink" title="Vue-Router 简介"></a>Vue-Router 简介</h1><h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><blockquote>
<p>指根据不同的 url 展示不同的内容或页面</p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>用户体验好，
不需要每次从服务器全部获取
展示更加快速
</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>不利于 SEO
使用浏览器的前进后退功能时，会重新发请求，
不能有效利用缓存

单页面无法记住之前滚动的位置，
无法在前进后退的时候记住之前的位置
</code></pre><h2 id="Vue-路由-——-Vue-Router"><a href="#Vue-路由-——-Vue-Router" class="headerlink" title="Vue 路由 —— Vue-Router"></a>Vue 路由 —— Vue-Router</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><pre><code>
/user/:username
/user/:username/goodlist/:goodlist_id


username，goodlist_id 是变化的

$router.params
</code></pre><h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><p>路由有子路由</p>
<pre><code>export default new Router({
  routes: [
    {
      path: &#39;/goods&#39;,
      name: &#39;GoodList&#39;,
      component: GoodList,
      children:[
        {
          path: &#39;title&#39;,
          name: &#39;title&#39;,
          component: Title
        },
        {
          path: &#39;img&#39;,
          name: &#39;img&#39;,
          component: Image
        }
      ]
    }
  ]
})
</code></pre><h4 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h4><p>不通过 <router-link>&lt; /router-link &gt; 来跳转，而通过<br>事件触发，调用 $router.push() API 来跳转</router-link></p>
<pre><code>$router.push(&quot;name&quot;)
$router.push({path:&quot;name&quot;})
$router.push({path:&quot;name?a=123&quot;})
$router.push({path:&quot;name&quot;, query: {a:&quot;123&quot;}})
$router.go(1)  // 前进 1 页  相当于 history.go(1)


&lt; button @click=&quot;jump&quot; &gt;跳转到购物车页面&lt; /button &gt;

 methods:{
    jump() {
        //this.$router.push(&quot;cart&quot;)
        this.$router.push({path:&#39;cart?goodsId=123&#39;})
    }
}
</code></pre><h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><p>给路由不同的名字，根据名字来进行匹配</p>
<pre><code>import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
import GoodList from &#39;../views/GoodList&#39;
import Title from &#39;@/views/Title&#39;
import Image from &#39;@/views/Image&#39;
import Cart from &#39;@/views/Cart&#39;

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: &#39;/goods&#39;,
      name: &#39;GoodList&#39;,
      component: GoodList,
      children:[
        {
          path: &#39;title&#39;,
          name: &#39;title&#39;,
          component: Title
        },
        {
          path: &#39;img&#39;,
          name: &#39;img&#39;,
          component: Image
        }
      ]
    },
    {
        path: &#39;/cart/:cartId&#39;,
        name: &#39;cart&#39;,
        component: Cart
    }
  ]
})


&lt; router-link :to=&quot;{name:&#39;cart&#39;,params:{cartId: 123}}&quot; &gt;跳转到购物车页面&lt; /router-link &gt;
</code></pre><h4 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h4><p>给不同的 router-view 定义名字，通过名字进行对应组件的渲染</p>
<pre><code>import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
import GoodList from &#39;../views/GoodList&#39;
import Title from &#39;@/views/Title&#39;
import Image from &#39;@/views/Image&#39;
import Cart from &#39;@/views/Cart&#39;

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: &#39;/&#39;,
      name: &#39;GoodList&#39;,
      components: {
        default: GoodList,
        title: Title,
        img: Image 
      },
      children:[
        {
          path: &#39;title&#39;,
          name: &#39;title&#39;,
          component: Title
        },
        {
          path: &#39;img&#39;,
          name: &#39;img&#39;,
          component: Image
        }
      ]
    },
    {
        path: &#39;/cart/:cartId&#39;,
        name: &#39;cart&#39;,
        component: Cart
    }
  ]
})




&lt; router-view class=&quot;main&quot; &gt;&lt; /router-view&gt;
&lt; router-view name=&quot;title&quot; class=&quot;left&quot; &gt;&lt; /router-view&gt;
&lt; router-view name=&quot;img&quot; class=&quot;right&quot; &gt;&lt; /router-view&gt;
</code></pre><h4 id="路由过渡"><a href="#路由过渡" class="headerlink" title="路由过渡"></a>路由过渡</h4><p>切换路由时有动画效果</p>
<pre><code>&lt; transition name=&quot;show&quot; &gt;
    &lt; router-view name=&quot;login&quot; &gt;&lt; /router-view &gt;
&lt; /transition&gt;


.show-enter-active {
  transition: all .3s ease;
}

.show-leave-active {
  transition: all .2s ease-in;
}


.show-enter, .show-leave-active {
  transform: translateX(200px);
  opacity: 0;
}





api，组件

&lt; router-link &gt;&lt; /router-link &gt;
this.$router.push({path: &#39;&#39;})
&lt; router-view &gt;&lt; /router-view &gt;
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>
router 
    index.js

import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
const GoodList = resolve =&gt; require([&#39;../views/GoodList.vue&#39;], resolve)

Vue.use(Router)


Vue.use(Router)

const routes = [
    {
      path: &#39;/goods/:goodsId/user/:name&#39;,
      name: &#39;GoodList&#39;,
      component: GoodList
    }
]


const router =  new Router({
  routes
})

export default router

export {
    router,
    routes
}



main.js

    import Vue from &#39;vue&#39;
    import App from &#39;./App&#39;
    import router from &#39;./router&#39;

new Vue({
    el: &#39;#app&#39;,
    router,
    render: h =&gt; h(App)
})
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Vue-Router 文档 </strong>: <a href="https://router.vuejs.org/zh-cn/index.html" target="_blank" rel="external">https://router.vuejs.org/zh-cn/index.html</a></p>
]]></content>
    
    <summary type="html">
    
      vue-router 入门简单介绍
    
    </summary>
    
      <category term="技术" scheme="http://ldqblog.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://ldqblog.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://ldqblog.me/tags/Vue/"/>
    
      <category term="Vue-Router" scheme="http://ldqblog.me/tags/Vue-Router/"/>
    
  </entry>
  
</feed>
