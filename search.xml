<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[GitHub Flow]]></title>
      <url>http://ldqblog.me/2017/10/27/GitHub-Flow/</url>
      <!-- <content type="html"><![CDATA[<h2 id="Git-FLow"><a href="#Git-FLow" class="headerlink" title="Git FLow"></a>Git FLow</h2><p>五条分支</p>
<p>两条长期分支</p>
<ul>
<li>主分支 master</li>
<li>开发分支 develop</li>
</ul>
<p>三条短期分支</p>
<ul>
<li>功能分支 feature </li>
<li>补丁分支 hotfix</li>
<li>预发分支 release</li>
</ul>
<blockquote>
<p>一旦完成开发，它们就会被合并进 develop 或 master，然后被删除</p>
</blockquote>
<p>相对复杂，需要经常切换分支<br>不便于持续发布</p>
<h2 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h2><p>Git Flow 简化版</p>
<p>一条长期分支</p>
<ul>
<li>master</li>
</ul>
<ol>
<li>开发时，从项目中 Fork 出一条新分支</li>
<li>修改后向 master 分支提交一个 pull request（PR）</li>
<li>经过审查后决定是否合并提交的 pull request</li>
<li>合并 master 后重新部署，删除分支</li>
</ol>
<p>合并 master 分支后不代表可以立刻发布，需要审核<br>于是线上版本和 master 分支版本会有不一致<br>所以又需要一个 production 分支</p>
]]></content> -->
      <content type="html"><![CDATA[Git FLow五条分支 两条长期分支 主分支 master 开发分支 develop 三条短期分支 功能分支 feature 补丁分支 hotfix 预发分支 release 一旦完成开发，它们就会被合并进 develop 或 master，然后被删除 相对复杂，需要经常切换分支不便于持续发布 Github FlowGit Flow 简化版 一条长期分支 master 开发时，从项目中 Fork 出一条新分支 修改后向 master 分支提交一个 pull request（PR） 经过审查后决定是否合并提交的 pull request 合并 master 后重新部署，删除分支 合并 master 分支后不代表可以立刻发布，需要审核于是线上版本和 master 分支版本会有不一致所以又需要一个 production 分支]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP 请求报文和响应报文]]></title>
      <url>http://ldqblog.me/2017/10/27/HTTP-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87/</url>
      <!-- <content type="html"><![CDATA[<p>HTTP 请求报文 </p>
<p>请求方法 路径 协议 / 版本<br>请求头</p>
<p>请求体 (参数)</p>
<p>HTTP 响应报文 </p>
<p>协议 / 版本 状态码 原因短语<br>响应头</p>
<p>响应体 (json 数据)</p>
]]></content> -->
      <content type="html"><![CDATA[HTTP 请求报文 请求方法 路径 协议 / 版本请求头 请求体 (参数) HTTP 响应报文 协议 / 版本 状态码 原因短语响应头 响应体 (json 数据)]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP 状态码]]></title>
      <url>http://ldqblog.me/2017/10/27/HTTP-%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      <!-- <content type="html"><![CDATA[<h2 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h2><p>100-199 : 指定客户端做某些操作<br>200-299 : 表示请求成功<br>300-399 : 关于资源的位置信息<br>400-499 : 客户端错误<br>500-599 : 服务端错误  </p>
<p>100(继续): 客户端请求是否可以在后续的请求中发送附件，服务端允许<br>101(转换协议): 根据头信息变为一个不同的协议</p>
<p>200 OK / 正常</p>
<p>301 永久重定向<br>302 重定向<br>304 缓存 </p>
<p>404 找不到资源<br>403 请求被拒绝</p>
<p>502 网关错误<br>504 网关超时</p>
]]></content> -->
      <content type="html"><![CDATA[状态码分类100-199 : 指定客户端做某些操作200-299 : 表示请求成功300-399 : 关于资源的位置信息400-499 : 客户端错误500-599 : 服务端错误 100(继续): 客户端请求是否可以在后续的请求中发送附件，服务端允许101(转换协议): 根据头信息变为一个不同的协议 200 OK / 正常 301 永久重定向302 重定向304 缓存 404 找不到资源403 请求被拒绝 502 网关错误504 网关超时]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP 缓存]]></title>
      <url>http://ldqblog.me/2017/10/27/HTTP%E7%BC%93%E5%AD%98/</url>
      <!-- <content type="html"><![CDATA[<p>HTTP 通过一些请求和响应头来设置缓存</p>
<p>常见的有 Expires / Cache-Control / Last-Modified / Etag</p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>不会向服务器发起请求</p>
<blockquote>
<p>Expires / Cache-Control </p>
</blockquote>
<p>Expires HTTP/1.0 版本的标准<br>值为过期时间</p>
<p>Cache-Control HTTP/1.1 版本的标准</p>
<p>max-age: 相对时间的秒数<br>smax-age: 相对时间的秒数, 但仅适用于共享缓存，在私有缓存中被忽略<br>public: 响应可以被任何对象 (客户端，代理服务器) 缓存<br>private: 响应只能被单个用户缓存, 是非共享的，不能被代理服务器缓存<br>no-cache: 强制所有用户在请求时，向服务器发起请求<br>no-store: 禁止缓存，每次请求都要向服务器重新获取数据</p>
<p>Cache-Control 优先级高于 Expires</p>
<p>相对时间比绝对时间准</p>
<p>不经常改变的文件:</p>
<p>给 max-age 设置一个较大的值，一般设置 max-age=31536000</p>
<p>标准中规定 max-age 的值最大不超过一年，所以设成 max-age=31536000。<br>至于过期内容，缓存区会将一段时间没有使用的文件删除掉。</p>
<p>可能经常需要变动的文件:</p>
<p>Cache-Control: no-cache / max-age=0</p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>会向服务器发起请求</p>
<blockquote>
<p>Last-Modified / if-Modified-Since</p>
</blockquote>
<p>响应头：Last-Modified GMT 时间</p>
<p>请求头：if-Modified-Since GMT 时间</p>
<p>两个的值相同</p>
<p>请求时服务端会将 if-Modified-Since 的时间和资源最后修改时间做比较</p>
<p>如果响应头中有 Last-Modified , 没有 Expires 或 Cache-Control 时，<br>浏览器会有自己的算法来推算出缓存时间，不同浏览器不同，所以 Last-Modified 要配合<br>Expires / Cache-Control 使用</p>
<blockquote>
<p>ETag / if-None-Match</p>
</blockquote>
<p>响应头：ETag MD5</p>
<p>请求头：if-None-Match MD5</p>
<p>两个的值相同</p>
<p>Last-Modified 只能精准到秒<br>ETag 通过 MD5 来验证，能精准到字节级别，优先级高</p>
<h2 id="设置某个日期过期"><a href="#设置某个日期过期" class="headerlink" title="设置某个日期过期"></a>设置某个日期过期</h2><p>响应头</p>
<p>Expires 过期时间的 GMT 时间</p>
<p>Cache-Control  max-age = 从现在起距离过期时间的秒数</p>
<p>Last-Modified 服务器资源最后修改的 GMT 时间</p>
<p>ETag  文件 MD5</p>
<p>请求头</p>
<p>if-Modified-Since 服务器资源最后修改的 GMT 时间</p>
<p>if-None-Match 文件 MD5</p>
<p>GMT 时间</p>
<pre><code>new Date(&#39;2017-10-27 20:46:02&#39;)
Fri Oct 27 2017 20:46:02 GMT+0800 (中国标准时间)
</code></pre>]]></content> -->
      <content type="html"><![CDATA[HTTP 通过一些请求和响应头来设置缓存 常见的有 Expires / Cache-Control / Last-Modified / Etag 强缓存不会向服务器发起请求 Expires / Cache-Control Expires HTTP/1.0 版本的标准值为过期时间 Cache-Control HTTP/1.1 版本的标准 max-age: 相对时间的秒数smax-age: 相对时间的秒数, 但仅适用于共享缓存，在私有缓存中被忽略public: 响应可以被任何对象 (客户端，代理服务器) 缓存private: 响应只能被单个用户缓存, 是非共享的，不能被代理服务器缓存no-cache: 强制所有用户在请求时，向服务器发起请求no-store: 禁止缓存，每次请求都要向服务器重新获取数据 Cache-Control 优先级高于 Expires 相对时间比绝对时间准 不经常改变的文件: 给 max-age 设置一个较大的值，一般设置 max-age=31536000 标准中规定 max-age 的值最大不超过一年，所以设成 max-age=31536000。至于过期内容，缓存区会将一段时间没有使用的文件删除掉。 可能经常需要变动的文件: Cache-Control: no-cache / max-age=0 协商缓存会向服务器发起请求 Last-Modified / if-Modified-Since 响应头：Last-Modified GMT 时间 请求头：if-Modified-Since GMT 时间 两个的值相同 请求时服务端会将 if-Modified-Since 的时间和资源最后修改时间做比较 如果响应头中有 Last-Modified , 没有 Expires 或 Cache-Control 时，浏览器会有自己的算法来推算出缓存时间，不同浏览器不同，所以 Last-Modified 要配合Expires / Cache-Control 使用 ETag / if-None-Match 响应头：ETag MD5 请求头：if-None-Match MD5 两个的值相同 Last-Modified 只能精准到秒ETag 通过 MD5 来验证，能精准到字节级别，优先级高 设置某个日期过期响应头 Expires 过期时间的 GMT 时间 Cache-Control max-age = 从现在起距离过期时间的秒数 Last-Modified 服务器资源最后修改的 GMT 时间 ETag 文件 MD5 请求头 if-Modified-Since 服务器资源最后修改的 GMT 时间 if-None-Match 文件 MD5 GMT 时间 new Date(&#39;2017-10-27 20:46:02&#39;) Fri Oct 27 2017 20:46:02 GMT+0800 (中国标准时间)]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[react 生命周期]]></title>
      <url>http://ldqblog.me/2017/09/26/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <!-- <content type="html"><![CDATA[<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li>每个生命周期钩子的调用例子讲解的比较详细</li>
</ul>
<p><a href="https://github.com/LDQ-first/react-lifecycle" target="_blank" rel="external">一个 react 生命周期例子</a></p>
<p><a href="https://github.com/LDQ-first/react-lifecycle" target="_blank" rel="external">源码</a></p>
<p>生命周期钩子的函数</p>
<p>React 的生命周期包括三个阶段：mount（挂载）、update（更新）和 unmount（移除）</p>
<p>mount 阶段</p>
<pre><code> constructor()   - 初始化 props 和 state
 componentWillMount() - 将要挂载了!
 render()             - 将 return 里的内容挂载到页面中
 componentDidMount()  - 挂在完了要干点什么?
</code></pre><p>update 阶段</p>
<pre><code>componentWillReceiveProps(nextProps) - 我要读取 props 啦！
shouldComponentUpdate(nextProps, nextState) - 请问要不要更新组件？true / false
componentWillUpdate() - 我要更新组件啦！
render() - 更新！
componentDidUpdate() - 更新完毕啦！
</code></pre><p>unmount 阶段</p>
<pre><code>componentWillUnmount() - 我要死啦！
</code></pre><p>setState 应该放在哪？</p>
<p>一般，我们只在这几个钩子里 setState：</p>
<pre><code>componentWillMount  -  一个组件只执行一次
componentDidMount   -  一个组件只执行一次
componentWillReceiveProps  - 每次数据更新时执行一次
</code></pre><p>因为在 componentWillUpdate 和 componentDidUpdate 里 setState 后<br>又会触发这两个钩子，最终会导致 call stack 溢出</p>
]]></content> -->
      <content type="html"><![CDATA[生命周期 每个生命周期钩子的调用例子讲解的比较详细 一个 react 生命周期例子 源码 生命周期钩子的函数 React 的生命周期包括三个阶段：mount（挂载）、update（更新）和 unmount（移除） mount 阶段 constructor() - 初始化 props 和 state componentWillMount() - 将要挂载了! render() - 将 return 里的内容挂载到页面中 componentDidMount() - 挂在完了要干点什么? update 阶段 componentWillReceiveProps(nextProps) - 我要读取 props 啦！ shouldComponentUpdate(nextProps, nextState) - 请问要不要更新组件？true / false componentWillUpdate() - 我要更新组件啦！ render() - 更新！ componentDidUpdate() - 更新完毕啦！ unmount 阶段 componentWillUnmount() - 我要死啦！ setState 应该放在哪？ 一般，我们只在这几个钩子里 setState： componentWillMount - 一个组件只执行一次 componentDidMount - 一个组件只执行一次 componentWillReceiveProps - 每次数据更新时执行一次 因为在 componentWillUpdate 和 componentDidUpdate 里 setState 后又会触发这两个钩子，最终会导致 call stack 溢出]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React 版开眼 (二)]]></title>
      <url>http://ldqblog.me/2017/09/25/React%E7%89%88%E5%BC%80%E7%9C%BC-%E4%BA%8C/</url>
      <!-- <content type="html"><![CDATA[<h1 id="React-版开眼技术详情"><a href="#React-版开眼技术详情" class="headerlink" title="React 版开眼技术详情"></a>React 版开眼技术详情</h1><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>配合 React-Router 4 , Redux, Immutable, Reselect 使用</p>
<p>React 层面分为路由组件（views 文件夹中）<br>和非路由组件（components 文件夹中）</p>
<p>利用 Redux 进行路由组件的状态管理，<br>利用 Redux-think（让 dispatch 接受函数做参数），<br> async/await（处理异步）<br>与 componentWillMount 等生命周期实现 api 请求</p>
<p>利用 Prop 进行路由组件和非路由组件的通信,<br>propTypes 作为 Prop 的类型检查</p>
<pre><code> static get propTypes() { 
        return { 
            location: PropTypes.obj.isRequired,
            history: PropTypes.obj.isRequired,
            match: PropTypes.obj.isRequired,
            IndexData: PropTypes.object,
            getIndexData: PropTypes.func,
            getSearchData: PropTypes.func,
        }
    }
</code></pre><p>利用 Bundle 组件实现路由异步加载（官网有示例）</p>
<p>利用 Immutable(不可变的数据结构), Reselect(避免不必要的 stroe 更新) 优化 Redux</p>
<h2 id="第三方-UI-框架"><a href="#第三方-UI-框架" class="headerlink" title="第三方 UI 框架"></a>第三方 UI 框架</h2><p>使用 Material-UI 框架中的组件<br>配合 Styled-components 使用<br>提高开发效率</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>利用 <a href="https://bird.ioliu.cn" target="_blank" rel="external">https://bird.ioliu.cn</a> 跨域</p>
<p>理由<br>    开眼 api 不支持 jsonp 跨域，<br>    第三方 API 实现 CORS 跨域，需要使用服务端<br>     <a href="https://bird.ioliu.cn" target="_blank" rel="external">https://bird.ioliu.cn</a> 简单易用</p>
<h2 id="Immutable-不可变的数据结构"><a href="#Immutable-不可变的数据结构" class="headerlink" title="Immutable(不可变的数据结构)"></a>Immutable(不可变的数据结构)</h2><p><a href="http://facebook.github.io/immutable-js/docs/#/" target="_blank" rel="external">文档</a></p>
<blockquote>
<p>Immutable.js 是一个完全独立的库，并非 React 一家独有，无论基于什么框架都可以用它。<br>弥补了 Javascript 没有不可变数据结构的问题<br>Immutable Data 是指一旦被创造后，就不可以被改变的数据<br>Immutable.js 提供了 7 种不可变的数据结构：List, Stack, Map, OrderedMap, Set, OrderedSet, Record </p>
</blockquote>
<p>在 JS 中，由于引用类型会指向同一个地址, 所以更新一个会影响其他的<br>在复杂开发中会影响性能</p>
<pre><code>a = { a: 1 }
b = a 
b.a = 10
a.a =&gt; 10
</code></pre><p>解决方法有利用浅拷贝和深拷贝的</p>
<pre><code>var  defaultObj = { /* 默认值 */}
var Obj = $.extend({}, defaultObj, initObj) // jQuery 用法。initObj 是自定义值
var Obj = $.extend(true, {}, defaultObj, initObj) // 如果对象是多层的，就用到深拷贝了
</code></pre><p>Object.assign 和 Object.freeze 是浅拷贝</p>
<p>利用 ImmutableJS</p>
<pre><code>var defaultObj = Immutable.fromJS({/* 默认值 */})
var Obj = defaultObj.merge(initObj) //defaultObj 不会改变，返回新值给 Obj
var Obj = defaultObj.mergeDeep(initObj) // 深 merge
</code></pre><p>ImmutableJS 的性能在于通过通过 structural sharing, 改变父子节点关系来更新数据<br>修改数据的时候就检查差异，不变返回原引用，有变化则直接返回一个新的引用<br>深拷贝需要递归遍历整个对象</p>
<h3 id="为什么要在-React-js-中使用-Immutable-js"><a href="#为什么要在-React-js-中使用-Immutable-js" class="headerlink" title="为什么要在 React.js 中使用 Immutable.js"></a>为什么要在 React.js 中使用 Immutable.js</h3><p>React.js 是一个 UI = f(states) 的框架，为了解决更新的问题，<br>React.js 使用了 virtual dom，virtual dom 通过 diff 修改 dom，来实现高效的 dom 更新。<br>但是当 state 更新时，如果数据没变，也会去做 virtual dom 的 diff，这就产生了浪费。</p>
<p>可以利用 PureRenderMixin，但 PureRenderMixin 只是简单的浅比较，不使用于多层比较</p>
<p>所以使用 Immutable.js 实现 Immutable Data</p>
<p><img src="http://ldqblog.me/img/Immutable/000.gif" alt="000"></p>
<h2 id="Reselect-避免不必要的-stroe-更新"><a href="#Reselect-避免不必要的-stroe-更新" class="headerlink" title="Reselect(避免不必要的 stroe 更新)"></a>Reselect(避免不必要的 stroe 更新)</h2><p>mapStateToProps 也被叫做 selector，在 store 发生变化的时候就会被调用，<br>而不管是不是 selector 关心的数据发生改变它都会被调用，<br>所以如果 selector 计算量非常大，每次更新都重新计算可能会带来性能问题。</p>
<p>Reselect 能帮你省去这些没必要的重新计算。<br>Reselect 提供 createSelector 函数来创建可记忆的 selector。</p>
<p>createSelector 接收一个 input-selectors 数组和一个转换函数作为参数。</p>
<p>如果 state tree 的改变会引起 input-selector 值变化，那么 selector 会调用转换函数，<br>传入 input-selectors 作为参数，并返回结果。</p>
<p>如果 input-selectors 的值和前一次的一样，<br>它将会直接返回前一次计算的数据，而不会再调用一次转换函数。<br>这样就可以避免不必要的计算，为性能带来提升。</p>
<pre><code>export const eyeSelector = createSelector(
    selectGolbal,
    appState =&gt; appState.get(&#39;eye&#39;)
)

export const IndexDataSelector = createSelector(
    eyeSelector,
    eyeState =&gt; {
        if(!eyeState) return
        return eyeState.get(&#39;IndexData&#39;)
    }
)


const mapStateToProps = (state) =&gt; ({
    IndexData: IndexDataSelector(state)
})


static get propTypes() { 
    return { 
        IndexData: PropTypes.object
    }
}
</code></pre><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>用于搭建 React 脚手架</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><strong>immutable.js 文档 </strong>: <a href="http://facebook.github.io/immutable-js/docs/#/" target="_blank" rel="external">http://facebook.github.io/immutable-js/docs/#/</a><br><strong>immutable.js 在 React、Redux 中的实践以及常用 API 简介 </strong>: <a href="https://yq.aliyun.com/articles/69516" target="_blank" rel="external">https://yq.aliyun.com/articles/69516</a></p>
]]></content> -->
      <content type="html"><![CDATA[React 版开眼技术详情React配合 React-Router 4 , Redux, Immutable, Reselect 使用 React 层面分为路由组件（views 文件夹中）和非路由组件（components 文件夹中） 利用 Redux 进行路由组件的状态管理，利用 Redux-think（让 dispatch 接受函数做参数）， async/await（处理异步）与 componentWillMount 等生命周期实现 api 请求 利用 Prop 进行路由组件和非路由组件的通信,propTypes 作为 Prop 的类型检查 static get propTypes() { return { location: PropTypes.obj.isRequired, history: PropTypes.obj.isRequired, match: PropTypes.obj.isRequired, IndexData: PropTypes.object, getIndexData: PropTypes.func, getSearchData: PropTypes.func, } } 利用 Bundle 组件实现路由异步加载（官网有示例） 利用 Immutable(不可变的数据结构), Reselect(避免不必要的 stroe 更新) 优化 Redux 第三方 UI 框架使用 Material-UI 框架中的组件配合 Styled-components 使用提高开发效率 跨域利用 https://bird.ioliu.cn 跨域 理由 开眼 api 不支持 jsonp 跨域， 第三方 API 实现 CORS 跨域，需要使用服务端 https://bird.ioliu.cn 简单易用 Immutable(不可变的数据结构)文档 Immutable.js 是一个完全独立的库，并非 React 一家独有，无论基于什么框架都可以用它。弥补了 Javascript 没有不可变数据结构的问题Immutable Data 是指一旦被创造后，就不可以被改变的数据Immutable.js 提供了 7 种不可变的数据结构：List, Stack, Map, OrderedMap, Set, OrderedSet, Record 在 JS 中，由于引用类型会指向同一个地址, 所以更新一个会影响其他的在复杂开发中会影响性能 a = { a: 1 } b = a b.a = 10 a.a =&gt; 10 解决方法有利用浅拷贝和深拷贝的 var defaultObj = { /* 默认值 */} var Obj = $.extend({}, defaultObj, initObj) // jQuery 用法。initObj 是自定义值 var Obj = $.extend(true, {}, defaultObj, initObj) // 如果对象是多层的，就用到深拷贝了 Object.assign 和 Object.freeze 是浅拷贝 利用 ImmutableJS var defaultObj = Immutable.fromJS({/* 默认值 */}) var Obj = defaultObj.merge(initObj) //defaultObj 不会改变，返回新值给 Obj var Obj = defaultObj.mergeDeep(initObj) // 深 merge ImmutableJS 的性能在于通过通过 structural sharing, 改变父子节点关系来更新数据修改数据的时候就检查差异，不变返回原引用，有变化则直接返回一个新的引用深拷贝需要递归遍历整个对象 为什么要在 React.js 中使用 Immutable.jsReact.js 是一个 UI = f(states) 的框架，为了解决更新的问题，React.js 使用了 virtual dom，virtual dom 通过 diff 修改 dom，来实现高效的 dom 更新。但是当 state 更新时，如果数据没变，也会去做 virtual dom 的 diff，这就产生了浪费。 可以利用 PureRenderMixin，但 PureRenderMixin 只是简单的浅比较，不使用于多层比较 所以使用 Immutable.js 实现 Immutable Data Reselect(避免不必要的 stroe 更新)mapStateToProps 也被叫做 selector，在 store 发生变化的时候就会被调用，而不管是不是 selector 关心的数据发生改变它都会被调用，所以如果 selector 计算量非常大，每次更新都重新计算可能会带来性能问题。 Reselect 能帮你省去这些没必要的重新计算。Reselect 提供 createSelector 函数来创建可记忆的 selector。 createSelector 接收一个 input-selectors 数组和一个转换函数作为参数。 如果 state tree 的改变会引起 input-selector 值变化，那么 selector 会调用转换函数，传入 input-selectors 作为参数，并返回结果。 如果 input-selectors 的值和前一次的一样，它将会直接返回前一次计算的数据，而不会再调用一次转换函数。这样就可以避免不必要的计算，为性能带来提升。 export const eyeSelector = createSelector( selectGolbal, appState =&gt; appState.get(&#39;eye&#39;) ) export const IndexDataSelector = createSelector( eyeSelector, eyeState =&gt; { if(!eyeState) return return eyeState.get(&#39;IndexData&#39;) } ) const mapStateToProps = (state) =&gt; ({ IndexData: IndexDataSelector(state) }) static get propTypes() { return { IndexData: PropTypes.object } } Webpack用于搭建 React 脚手架 参考immutable.js 文档 : http://facebook.github.io/immutable-js/docs/#/immutable.js 在 React、Redux 中的实践以及常用 API 简介 : https://yq.aliyun.com/articles/69516]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React 版开眼 (一)]]></title>
      <url>http://ldqblog.me/2017/09/23/React%E7%89%88%E5%BC%80%E7%9C%BC-%E4%B8%80/</url>
      <!-- <content type="html"><![CDATA[<h1 id="React-版开眼介绍"><a href="#React-版开眼介绍" class="headerlink" title="React 版开眼介绍"></a>React 版开眼介绍</h1><h2 id="预览地址"><a href="#预览地址" class="headerlink" title="预览地址"></a>预览地址</h2><p><a href="http://ldqblog.me/react-eyepetizer/dist/#/">预览地址</a></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/LDQ-first/react-eyepetizer" target="_blank" rel="external">GitHub</a></p>
<h2 id="手机可访问二维码"><a href="#手机可访问二维码" class="headerlink" title="手机可访问二维码"></a>手机可访问二维码</h2><p><img src="http://ldqblog.me/react-eyepetizer/static/img/QR/mobile.png" alt="React 版开眼"></p>
<hr>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>做 React 版开眼的原因：</p>
<pre><code>1. 学习 React 全家桶
2. 实现开眼的网页版
</code></pre><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li><strong>React 15.6</strong>: [ 前端框架 ]</li>
<li><strong>Redux 3.7</strong>: [ 状态管理, 组件通信 ] </li>
<li><strong>React-router 4.2</strong>: [ 配置路由，组件切换, 按需加载 ]</li>
<li><strong>ES6/7</strong>: [ JS 版本 ]</li>
<li><strong>Webpack</strong>: [ 模块化处理，编译打包 ]</li>
<li><strong>material-ui</strong>: [ UI 框架 ]</li>
<li><strong>Axios</strong>: [ 基于 Promise 处理 HTTP 请求 ]</li>
<li><strong>Classnames</strong>: [ 处理类名 ]</li>
<li><strong>Moment</strong>: [ 处理时间显示 ]</li>
<li><strong>Prop-types</strong>: [ 组件的 props 中的变量进行类型检测 ]</li>
<li><strong>Immutable</strong>: [ Immutable 数据化 ]</li>
<li><strong>Reselect</strong>: [ 使用缓存机制优化 state ]</li>
<li><strong>Styled-components</strong>: [ CSS in JS ]</li>
<li><strong>Redux-thunk&amp;async/await</strong>: [ redux 中间件，处理异步事件 ]</li>
<li><strong>LoaclStorge</strong>: [ 本地存储相关数据 ]</li>
</ul>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>实现了首页，发现，关注，<br>搜索，热门，分类，作者，排行榜，<br>往期精选，播放视频详情，<br>查看评论, 查看作者详情等功能</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>后端 json 数据的过滤比较繁琐，<br>考虑是否有优化方法</li>
</ul>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><a href="http://ldqblog.me/react-eyepetizer/static/result/index.gif">index</a></p>
<p><img src="http://ldqblog.me/react-eyepetizer/static/result/shortcut/index.jpg" alt="index"></p>
<p><a href="http://ldqblog.me/react-eyepetizer/static/result/hot.gif">hot</a></p>
<p><img src="http://ldqblog.me/react-eyepetizer/static/result/shortcut/hot.jpg" alt="hot"></p>
<p><a href="http://ldqblog.me/react-eyepetizer/static/result/search.gif">search</a></p>
<p><img src="http://ldqblog.me/react-eyepetizer/static/result/shortcut/search.jpg" alt="search"></p>
<p><a href="http://ldqblog.me/react-eyepetizer/static/result/detail.gif">detail</a></p>
<p><img src="http://ldqblog.me/react-eyepetizer/static/result/shortcut/detail.jpg" alt="detail"></p>
<blockquote>
<p><a href="https://github.com/LDQ-first/react-eyepetizer/tree/master/static/result" target="_blank" rel="external">更多效果图</a></p>
</blockquote>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><pre><code class="javascript">
│  index.js
├─api
├─components
│  ├─App
│  │      
│  ├─AuthorCarousel
│  │      
│  ├─AuthorHorizontal
│  │      
│  ├─AuthorInfo
│  │      
│  ├─AuthorLeftInfo
│  │      
│  ├─AuthorSingle
│  │      
│  ├─AuthorVideoInfo
│  │      
│  ├─Carousel
│  │      
│  ├─Categorys
│  │      
│  ├─DatePicker
│  │      
│  ├─DetailFooter
│  │      
│  ├─Download
│  │      
│  ├─Footer
│  │      
│  ├─GoToFeed
│  │      
│  ├─GoToTop
│  │      
│  ├─Header
│  │      
│  ├─Hot
│  │      
│  ├─Loading
│  │      
│  ├─Navigation
│  │      
│  ├─Pgcas
│  │      
│  ├─RelatedVideo
│  │      
│  ├─ReplyLists
│  │      
│  ├─ReturnIndex
│  │      
│  ├─Search
│  │      
│  ├─showQRCode
│  │      
│  ├─Tabs
│  │      
│  ├─Tags
│  │      
│  ├─TopScreen
│  │      
│  ├─Video
│  │      
│  ├─VideoArea
│  │      
│  ├─VideoHorizontal
│  │      
│  ├─VideoImg
│  │      
│  ├─VideoInfo
│  │      
│  └─VideoLists
│          
├─redux
│  │  reducers.js
│  │  store.js
│  │  
│  ├─actions
│  │      
│  ├─const
│  │      
│  └─reducer
│          
├─router
│      
├─selector
│      
├─styled
│      
├─utils
│      
└─views
    ├─Author
    │      
    ├─Detail
    │      
    ├─Feed
    │      
    ├─Find
    │      
    ├─Follow
    │      
    ├─Home
    │      
    ├─NotFound
    │      
    ├─Ranklist
    │      
    └─SearchArea
</code></pre>
]]></content> -->
      <content type="html"><![CDATA[React 版开眼介绍预览地址预览地址 源码GitHub 手机可访问二维码 起因做 React 版开眼的原因： 1. 学习 React 全家桶 2. 实现开眼的网页版 技术栈 React 15.6: [ 前端框架 ] Redux 3.7: [ 状态管理, 组件通信 ] React-router 4.2: [ 配置路由，组件切换, 按需加载 ] ES6/7: [ JS 版本 ] Webpack: [ 模块化处理，编译打包 ] material-ui: [ UI 框架 ] Axios: [ 基于 Promise 处理 HTTP 请求 ] Classnames: [ 处理类名 ] Moment: [ 处理时间显示 ] Prop-types: [ 组件的 props 中的变量进行类型检测 ] Immutable: [ Immutable 数据化 ] Reselect: [ 使用缓存机制优化 state ] Styled-components: [ CSS in JS ] Redux-thunk&amp;async/await: [ redux 中间件，处理异步事件 ] LoaclStorge: [ 本地存储相关数据 ] 成果实现了首页，发现，关注，搜索，热门，分类，作者，排行榜，往期精选，播放视频详情，查看评论, 查看作者详情等功能 问题 后端 json 数据的过滤比较繁琐，考虑是否有优化方法 效果图index hot search detail 更多效果图 项目结构 │ index.js ├─api ├─components │ ├─App │ │ │ ├─AuthorCarousel │ │ │ ├─AuthorHorizontal │ │ │ ├─AuthorInfo │ │ │ ├─AuthorLeftInfo │ │ │ ├─AuthorSingle │ │ │ ├─AuthorVideoInfo │ │ │ ├─Carousel │ │ │ ├─Categorys │ │ │ ├─DatePicker │ │ │ ├─DetailFooter │ │ │ ├─Download │ │ │ ├─Footer │ │ │ ├─GoToFeed │ │ │ ├─GoToTop │ │ │ ├─Header │ │ │ ├─Hot │ │ │ ├─Loading │ │ │ ├─Navigation │ │ │ ├─Pgcas │ │ │ ├─RelatedVideo │ │ │ ├─ReplyLists │ │ │ ├─ReturnIndex │ │ │ ├─Search │ │ │ ├─showQRCode │ │ │ ├─Tabs │ │ │ ├─Tags │ │ │ ├─TopScreen │ │ │ ├─Video │ │ │ ├─VideoArea │ │ │ ├─VideoHorizontal │ │ │ ├─VideoImg │ │ │ ├─VideoInfo │ │ │ └─VideoLists │ ├─redux │ │ reducers.js │ │ store.js │ │ │ ├─actions │ │ │ ├─const │ │ │ └─reducer │ ├─router │ ├─selector │ ├─styled │ ├─utils │ └─views ├─Author │ ├─Detail │ ├─Feed │ ├─Find │ ├─Follow │ ├─Home │ ├─NotFound │ ├─Ranklist │ └─SearchArea]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Webpack 简介]]></title>
      <url>http://ldqblog.me/2017/09/02/Webpack-%E7%AE%80%E4%BB%8B/</url>
      <!-- <content type="html"><![CDATA[<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>一切皆模块的思想<br>将前端的资源通过各种 loader 处理成浏览器可使用的资源</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>npm install --save-dev webpack
npm install --save-dev webpack@&lt;version&gt;
npm install --save-dev webpack-dev-server //webpack 基于 express 的服务器 可以不要

&quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack --config webpack.config.js&quot;
}
</code></pre><p>主要工作就是编写 webpack.config.js<br>和下载 loader，plugin</p>
<p>plugin 分 webpack 自带的和第三方的</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre><code>
const webpack = require(&#39;webpack&#39;)
const path = require(&#39;path&#39;)
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)
const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;)
const CopyWebpackPlugin = require(&#39;copy-webpack-plugin&#39;)


// 分离 css 文件
const extractCSS = new ExtractTextPlugin({
    filename: &#39;static/css/main.[name].[contenthash:8].css&#39;
})
const extractSASS = new ExtractTextPlugin({
    filename: &#39;static/css/sass.[name].[contenthash:8].css&#39;
})


module.exports = {
    devtool: &#39;cheap-module-eval-source-map&#39;, //source-map 用于 debugger 时能否看到源码
    entry: {  // 入口文件
        app: [
            path.join(__dirname, &#39;../src/index.js&#39;) 
        ],
    }, 
    output: {  // 出口文件
        path: path.join(__dirname, &#39;../dist&#39;),
        filename: &#39;static/js/[name].[chunkhash:8].js&#39;,
        chunkFilename: &#39;static/js/[name].[chunkhash:8].js&#39;,
        publicPath: &#39;/&#39;          // 静态资源路径前要添加的路径                 
    },
    resolve: { // 扩展名，别名
        extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.json&#39;],
        alias: {
        // ================================
        // 自定义路径别名
        // ================================
        &#39;@&#39;: path.join(__dirname, &#39;../src&#39;)
        }
    },
     module: {
        rules: [{  //loader 配置
            test: /\.(js|jsx)$/,
            use: [{
                loader: &#39;babel-loader?cacheDirectory=true&#39;,
                options: {
                    plugins: [&#39;syntax-dynamic-import&#39;]                         
                }
            }, &#39;eslint-loader&#39;],
            include: path.join(__dirname, &#39;../src&#39;),
            exclude: /node_modules/
        }, {
                test: /\.css$/,
                exclude: &#39;/node_modules/&#39;,
                use: extractCSS.extract({
                    fallback: &#39;style-loader&#39;,
                    use: [{
                        loader: &#39;css-loader&#39;,
                        options: {
                            modules: false                         
                        }
                    }]
                })
            },
            {
                test: /\.scss$/,
                exclude: /node_modules/,
                use: extractSASS.extract({
                    fallback: &#39;style-loader&#39;,
                    use: [{
                        loader: &#39;css-loader&#39;,
                        options: {
                            modules: false
                        }
                    },
                    {
                        loader: &#39;sass-loader&#39;
                    }]
                })
            },
            {
                test: /\.(png|svg|jpe?g|gif|ico)$/,
                use: [
                    {
                        loader: &#39;url-loader&#39;,
                        options: {
                            limit: 10240, // 10KB 以下使用 base64
                            name: &#39;img/[name].[sha512:hash:base64:7].[ext]&#39;
                        }
                    }
                ]
            },
            {
                test: /\.(woff2?|eot|ttf|otf|svg)((-|\?)?.*)?$/,
                exclude: /static\/img/,
                loader: &#39;url-loader&#39;,
                options: {
                    name: &#39;css/fonts/[name].[hash:8].[ext]&#39;
                }
            },{
                test: /\.json$/,
                exclude: &#39;/node_modules/&#39;,
                loader: &#39;json-loader&#39;
            }]
    },
    plugins: [  // 插件
        new webpack.BannerPlugin(&quot;author by ldq-first&quot;),
        extractCSS,
        extractSASS,
        new webpack.LoaderOptionsPlugin({
            options: {
                postcss: require(&#39;autoprefixer&#39;)
            }
        }),
        new HtmlWebpackPlugin({
            template:  path.join(__dirname, &#39;../index.html&#39;)
        }),
        new CopyWebpackPlugin([
            {
                from: path.join(__dirname, &#39;../static&#39;),
                to: path.join(__dirname, &#39;../dist/static/&#39;),
              //  ignore: [&#39;.*&#39;]
            }
        ]),
        new webpack.HashedModuleIdsPlugin(),
        // 这个 plugin 是用于引入 dll 里生成的 json 的。
        new webpack.DllReferencePlugin({  
            context: __dirname,
            manifest: require(&#39;../static/public/js/vendor-mainfest.json&#39;)  // 指向这个 json
        })
    ],
    devServer: {  //webpack-dev-server
        historyApiFallback: true,
        host: &#39;0.0.0.0&#39;,  // 手机局域网访问 如：http://10.30.4.227:5050
        hot: true,
        port: 5050
    }
}
</code></pre><h3 id="常用-loader"><a href="#常用-loader" class="headerlink" title="常用 loader"></a>常用 loader</h3><p><a href="https://webpack.js.org/loaders/" target="_blank" rel="external">loader</a></p>
<pre><code>
babel-loader
style-loader
css-loader
sass-loader
url-loader
json-loader
less-loader
html-loader
postcss-loader
eslint-loader
</code></pre><h3 id="常用-plugin"><a href="#常用-plugin" class="headerlink" title="常用 plugin"></a>常用 plugin</h3><p><a href="https://webpack.js.org/plugins/" target="_blank" rel="external">插件列表</a></p>
<pre><code>
html-webpack-plugin
extract-text-webpack-plugin
copy-webpack-plugin
copy-webpack-plugin

webpack.BannerPlugin
webpack.LoaderOptionsPlugin
webpack.HashedModuleIdsPlugin
webpack.DllReferencePlugin
webpack.DefinePlugin
webpack.optimize.OccurrenceOrderPlugin
webpack.optimize.UglifyJsPlugin
</code></pre><h3 id="webpack-DllReferencePlugin"><a href="#webpack-DllReferencePlugin" class="headerlink" title="webpack.DllReferencePlugin"></a>webpack.DllReferencePlugin</h3><p>提取不变的第三方代码，提高打包速度，减少打包文件大小，<br>防止首屏加载的单个 js 文件太大，影响用户体验，还能利用缓存</p>
<p>编写配置文件<br>webpack.dll.config.js</p>
<pre><code>在 webpack.config.js 的 plugin 中添加

// 这个 plugin 是用于引入 dll 里生成的 json 的。
new webpack.DllReferencePlugin({  
    context: __dirname,
    manifest: require(&#39;../static/public/js/vendor-mainfest.json&#39;)  // 指向这个 json
})
</code></pre><p>运行命令</p>
<pre><code>webpack --config ./build/webpack.dll.config.js

在 index.html 中引入最终的 js 文件
&lt; script src=&quot;./static/public/js/vendor.dll.js&quot; &gt;&lt; /script &gt;
</code></pre><p>例子</p>
<pre><code>const webpack = require(&#39;webpack&#39;)
const path = require(&#39;path&#39;)


module.exports = {
    entry: {
        vendor: [&#39;react&#39;, &#39;react-router-dom&#39;, &#39;redux&#39;, &#39;react-dom&#39;, &#39;react-redux&#39;,
         &#39;react-router-redux&#39;, &#39;prop-types&#39;, &#39;history&#39;, &#39;styled-components&#39;, 
         &#39;redux-thunk&#39;]
    },
    output: {
        path: path.join(__dirname , &#39;../static/public/js&#39;),
        filename: &#39;[name].dll.js&#39;, // 输出的文件，将会根据 entry 命名为 vendor.dll.js
        library: &#39;[name]_library&#39; // 暴露出的全局变量名
    },
    plugins: [
        new webpack.DllPlugin({
             //path 是 manifest.json 文件的输出路径，这个文件会用于后续的业务代码打包
            path: path.join(__dirname, &#39;../static/public/js/&#39;, &#39;[name]-mainfest.json&#39;),
            // 是 dll 暴露的对象名，要跟 output.library 保持一致
            name: &#39;[name]_library&#39;, 
            //context 是解析包路径的上下文，这个要跟接下来配置的 webpack.config.js 一致
            context: __dirname
        }),
        new webpack.DefinePlugin({
            &#39;process.env&#39;:{
                &#39;NODE_ENV&#39;: JSON.stringify(&#39;production&#39;)
            }
        }),
        new webpack.optimize.UglifyJsPlugin({
             compress: {
                warnings: false
            }
        })
    ]
}
</code></pre><h3 id="Happypack"><a href="#Happypack" class="headerlink" title="Happypack"></a>Happypack</h3><p>它可以建立线程，加速我们的 rebuild，并很好的利用缓存。首次 build 时速度甚至会变慢，<br>这是由于 happypack 在进行分析和配置，当进入开发阶段，<br>改动代码后的 rebuild 会快到让你吓一跳。</p>
<p>未来可尝试一下</p>
<h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>Webpack 支持两种按需拆分，切入点分别是 import() 和 require.ensure()，<br>首选前者，它是 ECMAScript 的建议，import 也是 es6 的关键词；后者是 webpack 所特有的。</p>
<p>动态导入 import</p>
<p>Webpack 把 import() 作为拆分点，把导入的模块放在单独的 chunk 中。<br>import() 接收模块名作为参数并返回 Promise：import(name) -&gt; Promise。</p>
<p>用于演示的目录结构：</p>
<pre><code>demo
├── index.html
├── index.js
└── webpack.config.js
</code></pre><p>index.js</p>
<pre><code>function test(){
  import(/* webpackChunkName: &quot;my-chunk-name&quot; */&#39;moment&#39;).then(function(moment){
    console.log(moment().format(&#39;MMMM Do YYYY, h:mm:ss a&#39;));
  }).catch(function(err){
    console.log(err);
  }); 
}
test();




webpack.config.js

module.exports = { 
  entry: &#39;./index.js&#39;,
  output: {
      filename: &#39;dist.js&#39;,
  },  
  module: {
    rules: [{
      test: /\.js$/,
      use: [{
        loader: &#39;babel-loader&#39;,
        options: {
          presets: &#39;es2015&#39;,
          plugins: [&#39;syntax-dynamic-import&#39;]
        }
      }]  
    }]  
  }
}
</code></pre><p>index.html</p>
<pre><code>&lt;!doctype html&gt;
&lt; script src=&quot;0.dist.js&quot; &gt;&lt; /script &gt;
&lt; script src=&quot;dist.js&quot; &gt;&lt; /script &gt;
</code></pre><p>由于使用动态的导入，因此需要使用插件 syntax-dynamic-import</p>
<pre><code>npm install --save-dev babel-core babel-loader babel-plugin-syntax-dynamic-import babel-preset-es2015 webpack
npm install --save moment
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><strong>webpack 文档 </strong>: <a href="https://webpack.js.org/guides/installation/" target="_blank" rel="external">https://webpack.js.org/guides/installation/</a></p>
]]></content> -->
      <content type="html"><![CDATA[Webpack简介 一切皆模块的思想将前端的资源通过各种 loader 处理成浏览器可使用的资源 使用npm install --save-dev webpack npm install --save-dev webpack@&lt;version&gt; npm install --save-dev webpack-dev-server //webpack 基于 express 的服务器 可以不要 &quot;scripts&quot;: { &quot;start&quot;: &quot;webpack --config webpack.config.js&quot; } 主要工作就是编写 webpack.config.js和下载 loader，plugin plugin 分 webpack 自带的和第三方的 例子 const webpack = require(&#39;webpack&#39;) const path = require(&#39;path&#39;) const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;) const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;) const CopyWebpackPlugin = require(&#39;copy-webpack-plugin&#39;) // 分离 css 文件 const extractCSS = new ExtractTextPlugin({ filename: &#39;static/css/main.[name].[contenthash:8].css&#39; }) const extractSASS = new ExtractTextPlugin({ filename: &#39;static/css/sass.[name].[contenthash:8].css&#39; }) module.exports = { devtool: &#39;cheap-module-eval-source-map&#39;, //source-map 用于 debugger 时能否看到源码 entry: { // 入口文件 app: [ path.join(__dirname, &#39;../src/index.js&#39;) ], }, output: { // 出口文件 path: path.join(__dirname, &#39;../dist&#39;), filename: &#39;static/js/[name].[chunkhash:8].js&#39;, chunkFilename: &#39;static/js/[name].[chunkhash:8].js&#39;, publicPath: &#39;/&#39; // 静态资源路径前要添加的路径 }, resolve: { // 扩展名，别名 extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.json&#39;], alias: { // ================================ // 自定义路径别名 // ================================ &#39;@&#39;: path.join(__dirname, &#39;../src&#39;) } }, module: { rules: [{ //loader 配置 test: /\.(js|jsx)$/, use: [{ loader: &#39;babel-loader?cacheDirectory=true&#39;, options: { plugins: [&#39;syntax-dynamic-import&#39;] } }, &#39;eslint-loader&#39;], include: path.join(__dirname, &#39;../src&#39;), exclude: /node_modules/ }, { test: /\.css$/, exclude: &#39;/node_modules/&#39;, use: extractCSS.extract({ fallback: &#39;style-loader&#39;, use: [{ loader: &#39;css-loader&#39;, options: { modules: false } }] }) }, { test: /\.scss$/, exclude: /node_modules/, use: extractSASS.extract({ fallback: &#39;style-loader&#39;, use: [{ loader: &#39;css-loader&#39;, options: { modules: false } }, { loader: &#39;sass-loader&#39; }] }) }, { test: /\.(png|svg|jpe?g|gif|ico)$/, use: [ { loader: &#39;url-loader&#39;, options: { limit: 10240, // 10KB 以下使用 base64 name: &#39;img/[name].[sha512:hash:base64:7].[ext]&#39; } } ] }, { test: /\.(woff2?|eot|ttf|otf|svg)((-|\?)?.*)?$/, exclude: /static\/img/, loader: &#39;url-loader&#39;, options: { name: &#39;css/fonts/[name].[hash:8].[ext]&#39; } },{ test: /\.json$/, exclude: &#39;/node_modules/&#39;, loader: &#39;json-loader&#39; }] }, plugins: [ // 插件 new webpack.BannerPlugin(&quot;author by ldq-first&quot;), extractCSS, extractSASS, new webpack.LoaderOptionsPlugin({ options: { postcss: require(&#39;autoprefixer&#39;) } }), new HtmlWebpackPlugin({ template: path.join(__dirname, &#39;../index.html&#39;) }), new CopyWebpackPlugin([ { from: path.join(__dirname, &#39;../static&#39;), to: path.join(__dirname, &#39;../dist/static/&#39;), // ignore: [&#39;.*&#39;] } ]), new webpack.HashedModuleIdsPlugin(), // 这个 plugin 是用于引入 dll 里生成的 json 的。 new webpack.DllReferencePlugin({ context: __dirname, manifest: require(&#39;../static/public/js/vendor-mainfest.json&#39;) // 指向这个 json }) ], devServer: { //webpack-dev-server historyApiFallback: true, host: &#39;0.0.0.0&#39;, // 手机局域网访问 如：http://10.30.4.227:5050 hot: true, port: 5050 } } 常用 loaderloader babel-loader style-loader css-loader sass-loader url-loader json-loader less-loader html-loader postcss-loader eslint-loader 常用 plugin插件列表 html-webpack-plugin extract-text-webpack-plugin copy-webpack-plugin copy-webpack-plugin webpack.BannerPlugin webpack.LoaderOptionsPlugin webpack.HashedModuleIdsPlugin webpack.DllReferencePlugin webpack.DefinePlugin webpack.optimize.OccurrenceOrderPlugin webpack.optimize.UglifyJsPlugin webpack.DllReferencePlugin提取不变的第三方代码，提高打包速度，减少打包文件大小，防止首屏加载的单个 js 文件太大，影响用户体验，还能利用缓存 编写配置文件webpack.dll.config.js 在 webpack.config.js 的 plugin 中添加 // 这个 plugin 是用于引入 dll 里生成的 json 的。 new webpack.DllReferencePlugin({ context: __dirname, manifest: require(&#39;../static/public/js/vendor-mainfest.json&#39;) // 指向这个 json }) 运行命令 webpack --config ./build/webpack.dll.config.js 在 index.html 中引入最终的 js 文件 &lt; script src=&quot;./static/public/js/vendor.dll.js&quot; &gt;&lt; /script &gt; 例子 const webpack = require(&#39;webpack&#39;) const path = require(&#39;path&#39;) module.exports = { entry: { vendor: [&#39;react&#39;, &#39;react-router-dom&#39;, &#39;redux&#39;, &#39;react-dom&#39;, &#39;react-redux&#39;, &#39;react-router-redux&#39;, &#39;prop-types&#39;, &#39;history&#39;, &#39;styled-components&#39;, &#39;redux-thunk&#39;] }, output: { path: path.join(__dirname , &#39;../static/public/js&#39;), filename: &#39;[name].dll.js&#39;, // 输出的文件，将会根据 entry 命名为 vendor.dll.js library: &#39;[name]_library&#39; // 暴露出的全局变量名 }, plugins: [ new webpack.DllPlugin({ //path 是 manifest.json 文件的输出路径，这个文件会用于后续的业务代码打包 path: path.join(__dirname, &#39;../static/public/js/&#39;, &#39;[name]-mainfest.json&#39;), // 是 dll 暴露的对象名，要跟 output.library 保持一致 name: &#39;[name]_library&#39;, //context 是解析包路径的上下文，这个要跟接下来配置的 webpack.config.js 一致 context: __dirname }), new webpack.DefinePlugin({ &#39;process.env&#39;:{ &#39;NODE_ENV&#39;: JSON.stringify(&#39;production&#39;) } }), new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false } }) ] } Happypack它可以建立线程，加速我们的 rebuild，并很好的利用缓存。首次 build 时速度甚至会变慢，这是由于 happypack 在进行分析和配置，当进入开发阶段，改动代码后的 rebuild 会快到让你吓一跳。 未来可尝试一下 代码分割Webpack 支持两种按需拆分，切入点分别是 import() 和 require.ensure()，首选前者，它是 ECMAScript 的建议，import 也是 es6 的关键词；后者是 webpack 所特有的。 动态导入 import Webpack 把 import() 作为拆分点，把导入的模块放在单独的 chunk 中。import() 接收模块名作为参数并返回 Promise：import(name) -&gt; Promise。 用于演示的目录结构： demo ├── index.html ├── index.js └── webpack.config.js index.js function test(){ import(/* webpackChunkName: &quot;my-chunk-name&quot; */&#39;moment&#39;).then(function(moment){ console.log(moment().format(&#39;MMMM Do YYYY, h:mm:ss a&#39;)); }).catch(function(err){ console.log(err); }); } test(); webpack.config.js module.exports = { entry: &#39;./index.js&#39;, output: { filename: &#39;dist.js&#39;, }, module: { rules: [{ test: /\.js$/, use: [{ loader: &#39;babel-loader&#39;, options: { presets: &#39;es2015&#39;, plugins: [&#39;syntax-dynamic-import&#39;] } }] }] } } index.html &lt;!doctype html&gt; &lt; script src=&quot;0.dist.js&quot; &gt;&lt; /script &gt; &lt; script src=&quot;dist.js&quot; &gt;&lt; /script &gt; 由于使用动态的导入，因此需要使用插件 syntax-dynamic-import npm install --save-dev babel-core babel-loader babel-plugin-syntax-dynamic-import babel-preset-es2015 webpack npm install --save moment 参考webpack 文档 : https://webpack.js.org/guides/installation/]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[glup 简介]]></title>
      <url>http://ldqblog.me/2017/09/01/glup-%E7%AE%80%E4%BB%8B/</url>
      <!-- <content type="html"><![CDATA[<h2 id="glup"><a href="#glup" class="headerlink" title="glup"></a>glup</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><pre><code>
打造前端工作流
打包，压缩，合并，git，远程操作


本质：将命令行转变成 js 代码来执行


思想
   数据流
   流水线

   操作过的文件，不输出
   下次再操作时，操作流水线
   最后才输出
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>    npm install gulp-cli -g

    npm install gulp -D

    touch gulpfile.js

    gulp --help
</code></pre><p>编写 glupfile.js 文件</p>
<pre><code>var gulp = require(&#39;gulp&#39;);
var pug = require(&#39;gulp-pug&#39;);
var less = require(&#39;gulp-less&#39;);
var minifyCSS = require(&#39;gulp-csso&#39;);



gulp.task(&#39;html&#39;, function(){
  return gulp.src(&#39;client/templates/*.pug&#39;)
    .pipe(pug())
    .pipe(gulp.dest(&#39;build/html&#39;))
});

gulp.task(&#39;css&#39;, function(){
  return gulp.src(&#39;client/templates/*.less&#39;)
    .pipe(less())
    .pipe(minifyCSS())
    .pipe(gulp.dest(&#39;build/css&#39;))
});

gulp.task(&#39;default&#39;, [ &#39;html&#39;, &#39;css&#39; ]);
</code></pre><p>常用 API</p>
<pre><code>task
src
pipe
dest
</code></pre><p>gulp.src(globs[, options])</p>
<p>globs 字符串 / 数组<br>数据流</p>
<p>pipe<br>传数据流</p>
<p>task(name, deps, callback)<br>创建任务<br>deps 并行执行</p>
<p>watch 监听文件改动</p>
<p>常用插件</p>
<pre><code>
gulp-htmlmin
gulp plugin to minify HTML.


gulp-cssnano
Minify CSS with cssnano.

gulp-clean-css
gulp plugin to minify CSS, using clean-css

gulp-less
gulp-sass
gulp-requirejs-optimize


gulp-concat
合并数据流


gulp-uglify
Minify JavaScript with UglifyJS2.

gulp-imagemin 
Minify PNG, JPEG, GIF and SVG images with imagemin

gulp-rename
gulp-rename is a gulp plugin to rename files easily.

gulp-clean
Removes files and folders.


gulp-eslint
A gulp plugin for ESLint.


gulp-jslint
It&#39;s JSLint for Gulp.js.

gulp-postcss
PostCSS gulp plugin to pipe CSS through several plugins, but parse CSS only once.

glob-stream 
A Readable Stream interface over node-glob.

gulp-typescript 
A gulp plugin for handling TypeScript compilation workflow. 
The plugin exposes TypeScript&#39;s compiler options to gulp using TypeScript API.


gulp-filter 
Filter files in a Vinyl stream

Enables you to work on a subset of the original files
 by filtering them using glob patterns. 
 When you&#39;re done and want all the original files back 
 you just use the restore stream.


gulp-sourcemaps
Write inline source maps
Inline source maps are embedded in the source file.


gulp-if
A ternary gulp plugin: conditionally control the flow of vinyl objects.

Note: Badly behaved plugins can often get worse when used with gulp-if.
 Typically the fix is not in gulp-if.

Note: Works great with lazypipe, see below


gulp-autoprefixer
Prefix CSS with Autoprefixer


gulp-babel
Use next generation JavaScript, today, with Babel

gulp-rev
添加版本号

gulp-rev-replace
版本号替换

gulp-useref
解析 html 资源定位
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><strong>glup 文档 </strong>: <a href="https://gulpjs.com/" target="_blank" rel="external">https://gulpjs.com/</a></p>
]]></content> -->
      <content type="html"><![CDATA[glup简介 打造前端工作流 打包，压缩，合并，git，远程操作 本质：将命令行转变成 js 代码来执行 思想 数据流 流水线 操作过的文件，不输出 下次再操作时，操作流水线 最后才输出 使用 npm install gulp-cli -g npm install gulp -D touch gulpfile.js gulp --help 编写 glupfile.js 文件 var gulp = require(&#39;gulp&#39;); var pug = require(&#39;gulp-pug&#39;); var less = require(&#39;gulp-less&#39;); var minifyCSS = require(&#39;gulp-csso&#39;); gulp.task(&#39;html&#39;, function(){ return gulp.src(&#39;client/templates/*.pug&#39;) .pipe(pug()) .pipe(gulp.dest(&#39;build/html&#39;)) }); gulp.task(&#39;css&#39;, function(){ return gulp.src(&#39;client/templates/*.less&#39;) .pipe(less()) .pipe(minifyCSS()) .pipe(gulp.dest(&#39;build/css&#39;)) }); gulp.task(&#39;default&#39;, [ &#39;html&#39;, &#39;css&#39; ]); 常用 API task src pipe dest gulp.src(globs[, options]) globs 字符串 / 数组数据流 pipe传数据流 task(name, deps, callback)创建任务deps 并行执行 watch 监听文件改动 常用插件 gulp-htmlmin gulp plugin to minify HTML. gulp-cssnano Minify CSS with cssnano. gulp-clean-css gulp plugin to minify CSS, using clean-css gulp-less gulp-sass gulp-requirejs-optimize gulp-concat 合并数据流 gulp-uglify Minify JavaScript with UglifyJS2. gulp-imagemin Minify PNG, JPEG, GIF and SVG images with imagemin gulp-rename gulp-rename is a gulp plugin to rename files easily. gulp-clean Removes files and folders. gulp-eslint A gulp plugin for ESLint. gulp-jslint It&#39;s JSLint for Gulp.js. gulp-postcss PostCSS gulp plugin to pipe CSS through several plugins, but parse CSS only once. glob-stream A Readable Stream interface over node-glob. gulp-typescript A gulp plugin for handling TypeScript compilation workflow. The plugin exposes TypeScript&#39;s compiler options to gulp using TypeScript API. gulp-filter Filter files in a Vinyl stream Enables you to work on a subset of the original files by filtering them using glob patterns. When you&#39;re done and want all the original files back you just use the restore stream. gulp-sourcemaps Write inline source maps Inline source maps are embedded in the source file. gulp-if A ternary gulp plugin: conditionally control the flow of vinyl objects. Note: Badly behaved plugins can often get worse when used with gulp-if. Typically the fix is not in gulp-if. Note: Works great with lazypipe, see below gulp-autoprefixer Prefix CSS with Autoprefixer gulp-babel Use next generation JavaScript, today, with Babel gulp-rev 添加版本号 gulp-rev-replace 版本号替换 gulp-useref 解析 html 资源定位 参考glup 文档 : https://gulpjs.com/]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React 版动态简历]]></title>
      <url>http://ldqblog.me/2017/08/23/React%E7%89%88%E5%8A%A8%E6%80%81%E7%AE%80%E5%8E%86/</url>
      <!-- <content type="html"><![CDATA[<p><strong><a href="http://ldqblog.me/react-animating-resume/build/">预览地址</a></strong></p>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul>
<li>React  前端框架</li>
<li>ES6/7 采用最新 JS 语法</li>
<li>Async/Await Promise 用于处理异步事件流</li>
<li>Marked 识别 markdown 语法</li>
<li>Prismjs/react-prism 实现语法高亮</li>
<li>styled-components 在 JS 中写 CSS</li>
<li>classnames 处理 className</li>
<li>Express create-react-app 自带服务器</li>
<li>icomoom.css 字体图标</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>利用 Async/Await Promise 实现按步骤绘制动态简历<br>实现了加速、播放、暂停、跳过、重来、下载 PDF 等功能<br>用于 FireFox 显示 pdf 排版有错，所以遇到 Firefox 时，点击下载 PDF 后没有预览而采用直接下载</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>定时的在页面添加字符串</p>
<p>用一定的方法解析字符串</p>
<p>如字符串内容为 CSS 就添加到 style 标签中</p>
<p>如字符串内容为 HTML 和 markdown 就用 marked 模块解析</p>
]]></content> -->
      <content type="html"><![CDATA[预览地址 技术 React 前端框架 ES6/7 采用最新 JS 语法 Async/Await Promise 用于处理异步事件流 Marked 识别 markdown 语法 Prismjs/react-prism 实现语法高亮 styled-components 在 JS 中写 CSS classnames 处理 className Express create-react-app 自带服务器 icomoom.css 字体图标 总结 利用 Async/Await Promise 实现按步骤绘制动态简历实现了加速、播放、暂停、跳过、重来、下载 PDF 等功能用于 FireFox 显示 pdf 排版有错，所以遇到 Firefox 时，点击下载 PDF 后没有预览而采用直接下载 原理定时的在页面添加字符串 用一定的方法解析字符串 如字符串内容为 CSS 就添加到 style 标签中 如字符串内容为 HTML 和 markdown 就用 marked 模块解析]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue 版动态简历]]></title>
      <url>http://ldqblog.me/2017/08/20/Vue%E7%89%88%E5%8A%A8%E6%80%81%E7%AE%80%E5%8E%86/</url>
      <!-- <content type="html"><![CDATA[<p><strong><a href="http://ldqblog.me/vue-animating-resume/dist/">预览地址</a></strong></p>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li>Vue  前端框架</li>
<li>ES6/7 采用最新 JS 语法</li>
<li>Async/Await Promise 用于处理异步事件流</li>
<li>Marked 识别 markdown 语法</li>
<li>Prismjs 实现语法高亮</li>
<li>Express vue-cli 自带服务器</li>
<li>svg 字体图标</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>利用 Async/Await Promise 实现按步骤绘制动态简历<br>实现了加速、播放、暂停、跳过、重来、下载 PDF 等功能<br>开启 webpack 和 babel-loader 缓存提高构建速度<br>用于 FireFox 显示 pdf 排版有错，所以遇到 Firefox 时，点击下载 PDF 后没有预览而采用直接下载</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>定时的在页面添加字符串</p>
<p>用一定的方法解析字符串</p>
<p>如字符串内容为 CSS 就添加到 style 标签中</p>
<p>如字符串内容为 HTML 和 markdown 就用 marked 模块解析</p>
]]></content> -->
      <content type="html"><![CDATA[预览地址 技术栈 Vue 前端框架 ES6/7 采用最新 JS 语法 Async/Await Promise 用于处理异步事件流 Marked 识别 markdown 语法 Prismjs 实现语法高亮 Express vue-cli 自带服务器 svg 字体图标 总结 利用 Async/Await Promise 实现按步骤绘制动态简历实现了加速、播放、暂停、跳过、重来、下载 PDF 等功能开启 webpack 和 babel-loader 缓存提高构建速度用于 FireFox 显示 pdf 排版有错，所以遇到 Firefox 时，点击下载 PDF 后没有预览而采用直接下载 原理定时的在页面添加字符串 用一定的方法解析字符串 如字符串内容为 CSS 就添加到 style 标签中 如字符串内容为 HTML 和 markdown 就用 marked 模块解析]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue 版商城 (二)]]></title>
      <url>http://ldqblog.me/2017/08/18/Vue%E7%89%88%E5%95%86%E5%9F%8E-%E4%BA%8C/</url>
      <!-- <content type="html"><![CDATA[<h1 id="Vue-版商城技术详情"><a href="#Vue-版商城技术详情" class="headerlink" title="Vue 版商城技术详情"></a>Vue 版商城技术详情</h1><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue 配合 Vue-Router，Vuex</p>
<p>实现路由跳转，路由过渡，状态管理</p>
<p>Vue-lazyload<br>头像图片懒加载</p>
<p>Vue-infinite-scroll<br>滚动加载</p>
<p>Vue-pull-to-refresh<br>自己开发的下拉刷新（实现插件）</p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>实现 api 请求等的异步处理</p>
<h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>后端服务器</p>
<p>获取数据 get 请求<br>操作数据 post 请求</p>
<p>利用中间件，路由实现后端逻辑</p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>数据库</p>
<p>MongoDB 是一个基于文档的数据库，所有数据是从磁盘上进行读写的。<br>MongoDB 善长的是对无模式 JSON 数据的查询。<br>MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值 (key=&gt;value) 对组成。<br>MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<h3 id="Robomongo"><a href="#Robomongo" class="headerlink" title="Robomongo"></a>Robomongo</h3><p>可视化 MongeDB 工具</p>
<h2 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h2><p>连接数据库和 Express</p>
<p>使用 promise 的调用方式</p>
<pre><code>
const mongoose = require(&#39;mongoose&#39;)
const Schema =  mongoose.Schema
mongoose.Promise = global.Promise

const productSchema = new Schema({
    &quot;productId&quot;: String,
    &quot;productName&quot;: String,
    &quot;salePrice&quot;: Number,
    &quot;productImage&quot;: String,
    &quot;checked&quot;: Number,
    &quot;productNum&quot;: Number
})


module.exports = mongoose.model(&#39;Good&#39;, productSchema)
</code></pre><h3 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h3><pre><code>    插入数据
    save

    更新数据
    update

    查找
    find

    查找并更新
    findByIdAndUpdate

    移除
    remove

    数量查询
    count

    根据_id 查询
    findById
</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code>　 $or　　　　或关系

　　$nor　　　 或关系取反

　　$gt　　　　大于

　　$gte　　　 大于等于

　　$lt　　　　 小于

　　$lte　　　  小于等于

　　$ne            不等于

　　$in             在多个值范围内

　　$nin           不在多个值范围内

　　$all            匹配数组中多个值

　　$regex　　正则，用于模糊查询

　　$size　　　匹配数组大小

　　$maxDistance　　范围查询，距离（基于 LBS）

　　$mod　　   取模运算

　　$near　　　邻域查询，查询附近的位置（基于 LBS）

　　$exists　　  字段是否存在

　　$elemMatch　　匹配内数组内的元素

　　$within　　范围查询（基于 LBS）

　　$box　　　 范围查询，矩形范围（基于 LBS）

　　$center       范围醒询，圆形范围（基于 LBS）

　　$centerSphere　　范围查询，球形范围（基于 LBS）

　　$slice　　　　查询字段集合中的元素（比如从第几个之后，第 N 到第 M 个元素）
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>const Goods = require(&#39;../models/goods.js&#39;)
mongoose.Promise = global.Promise

var env = process.env.NODE_ENV || &#39;development&#39;
if(env === &#39;development&#39;) {
    console.log(&#39;NODE_ENV:&#39;, env)
    mongoose.connect(&#39;mongodb://IP:port/shopdb&#39;)
}
else {
  console.log(&#39;NODE_ENV:&#39;, env)
  mongoose.connect(&#39;mongodb:// 用户. 数据库: password@IP:port/shopdb&#39;)
}



router.get(&#39;/list&#39;, (req, res, next) =&gt; {
   const sort = req.query.sort
   const page = req.query.page
   const pageSize = req.query.pageSize
   const priceChecked = req.query.priceChecked
   let params = {}
   let priceGt = &#39;&#39;, priceLte =&#39;&#39;
   if(priceChecked !== &#39;all&#39;) {
       switch(priceChecked) {
            case &#39;0&#39;: priceGt = 0; priceLte=500; break;
            case &#39;1&#39;: priceGt = 500; priceLte=1000; break;
            case &#39;2&#39;: priceGt = 1000; priceLte=2000; break;
            case &#39;3&#39;: priceGt = 2000; priceLte=4000; break;
        }
        params = {
            salePrice: {
                $gt: priceGt,
                $lte: priceLte
            }
        }
        console.log(params)
   }

   const skip = (page - 1) * pageSize;
   const goodsModel = Goods.find(params).skip(skip).limit(parseInt(pageSize))

   goodsModel.sort({&#39;salePrice&#39;: sort})

   goodsModel.exec((err, doc) =&gt; {
       if(err) {
           res.json({
               status: &#39;404&#39;,
               msg: err.message
           })
       }
       else {
           res.json({
               status: &#39;200&#39;,
               msg: &#39;OK&#39;,
               result: {
                   count: doc.length,
                   list: doc
               }
           })
       }
   })
})
</code></pre><h3 id="根据环境连接数据库"><a href="#根据环境连接数据库" class="headerlink" title="根据环境连接数据库"></a>根据环境连接数据库</h3><pre><code>var env = process.env.NODE_ENV || &#39;development&#39;
var sessionUrl = &#39;&#39;if(env ===&#39;development&#39;) {
    console.log(&#39;app.NODE_ENV:&#39;, env)
    sessionUrl = &#39;mongodb://IP:port/shopdb&#39;
}
else {
  console.log(&#39;app.NODE_ENV:&#39;, env)
  sessionUrl = &#39;mongodb:// 用户. 数据库: password@IP:port/shopdb&#39;
}
</code></pre><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="代理转发"><a href="#代理转发" class="headerlink" title="代理转发"></a>代理转发</h3><pre><code>upstream vue {
    server 本地 IP:port;
}

server {
    listen port;
    # server_name *. 主域名;
    server_name  外部 IP;
    location / {
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forward-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
        proxy_set_header X-Nginx-Proxy true;
        proxy_pass http://vue;
        proxy_redirect off;
    }
    location /goods/ {
        proxy_pass http:// 本地 IP:port/goods/;
    }

    location /users/ {
        proxy_pass http:// 本地 IP:port/users/;
    }
    location /vueshop/ {
        alias 路径;
    }
    location ~* ^.+\.(jpg|jpeg|gif|png|svg|ico|webp|css|js|map|pdf|txt)$ {
        root 路径;
    }
}
</code></pre><h3 id="开启-gzip-压缩"><a href="#开启-gzip-压缩" class="headerlink" title="开启 gzip 压缩"></a>开启 gzip 压缩</h3><p>sudo vi /etc/nginx/nginx.conf</p>
<pre><code>##
# Gzip Settings
##

gzip on;
gzip_disable &quot;msie6&quot;;
# 启用 gzip 压缩的最小文件，小于设置值的文件将不会压缩
gzip_min_length 1k;
# 是否在 http header 中添加 Vary: Accept-Encoding，建议开启
    gzip_vary on;
# gzip_proxied any;
# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用 CPU 时间
    gzip_comp_level 4;
    gzip_buffers 16 8k;
# gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
</code></pre><h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p>做守护进程, 发布更新项目</p>
<p>使用 ecosystem.json </p>
<p> pm2 deploy ecosystem.json start</p>
<p> 可以配置服务器 ip，指定 github 仓库<br> 实现代码更新后快速部署到服务器中</p>
<pre><code>{
    &quot;apps&quot;:[
        {
            &quot;name&quot;:&quot;vueshop&quot;,
            &quot;script&quot;:&quot;入口脚本&quot;,           
            &quot;env&quot;: {              // 传进去的变量
                &quot;COMMON_VARIABLE&quot;: &quot;true&quot;
            },
            &quot;env_production&quot;: {
                &quot;NODE_ENV&quot;: &quot;production&quot;
            }
        }
    ],
    &quot;deploy&quot;: { // 部署任务
        &quot;start&quot;: { // 任务名
            &quot;user&quot;: &quot;&quot;,// 服务器上用来发布应用的 user&quot;host&quot;: [&quot;IP&quot;],&quot;port&quot;:&quot;port&quot;,&quot;ref&quot;:&quot;origin/master&quot;,&quot;repo&quot;:&quot;git 仓库 &quot;,&quot;path&quot;:&quot;&quot;, // 服务器项目位置
            &quot;ssh_options&quot;: &quot;StrictHostKeyChecking=no&quot;, // 取消 key 校验
            &quot;post-deploy&quot;: &quot;执行的命令行 &amp;&amp; pm2 startOrRestart ../ecosystem.json --env production&quot;,
            &quot;env&quot;: {
                &quot;NODE_ENV&quot;: &quot;production&quot;
            }
        }
    }
}
</code></pre><h2 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h2><p>数据可视化显示</p>
<p>显示价格趋势，数据来自数据库（自己编的）</p>
<p>显示订单详情</p>
<h2 id="Svg-captcha"><a href="#Svg-captcha" class="headerlink" title="Svg-captcha"></a>Svg-captcha</h2><p>验证码</p>
<p>在考虑要使用验证码时, 发现许多相关的 npm 模块都要<br>安装其它支持库（C 或 C++ 编写，而且平台兼容性极差）</p>
<p>最终在 CNode 社区发现了以 svg 为基础的 Svg-captcha</p>
<blockquote>
<p>内部使用 opentype.js ， 把字符转换为 svg 路径，然后生成验证码</p>
</blockquote>
<p>简单易用</p>
<pre><code>
const svgCaptcha = require(&#39;svg-captcha&#39;)

router.get(&#39;/captcha&#39;, (req, res, next) =&gt; {
  const captcha = svgCaptcha.create({
    background: &quot;#3E96D6&quot;
  })
  req.session.captcha = captcha.text

  res.set(&#39;Content-Type&#39;, &#39;image/svg+xml&#39;)
  res.json({
    status: &#39;200&#39;,
    msg: &#39;OK&#39;,
    result: captcha
  })
})


router.get(&#39;/isCaptchaTrue&#39;, (req, res, next) =&gt; {
  const captcha = req.query.captcha.toLowerCase()
  if (req.session.captcha.toLowerCase() !== captcha) {
    res.json({
      status: &#39;500&#39;,
      msg: &#39;验证码有错&#39;,
      result: &#39;&#39;
    })
    return
  } else {
    res.json({
      status: &#39;200&#39;,
      msg: &#39;验证码正确&#39;,
      result: &#39;&#39;
    })
  }
})
</code></pre><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>express 在 4.x 版本之后，session 管理和 cookies 等许多模块都不再直接包含在 express 中，<br>而是需要单独添加相应模块。</p>
<p>express4 中操作 cookie 使用 cookie-parser 模块<br>express4 中操作 session 使用 express-session 模块</p>
<p>session 的运作通过一个 session_id 来进行。session_id 通常是存放在客户端的 cookie 中，<br>比如在 express 中，默认是 connect.sid 这个字段，当请求到来时，<br>服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，<br>进行数据的保存和修改。</p>
<p>这意思就是说，当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，<br>然后存在你 cookie 中的 connect.sid 字段中。<br>当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然<br>后从服务器的存储中取出上次记录在你身上的数据。<br>由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。<br>伪造成功的概率比坐在家里编程时被邻居家的狗突然闯入并咬死的几率还低。</p>
<p>session 可以存放在 1）内存、2）cookie 本身、3）redis 或 memcached 等缓存中，或者 4）数据库中。</p>
<p>使用 session 验证用户<br>session 存储在数据库中</p>
<p>app.js</p>
<pre><code>
配置
const session = require(&#39;express-session&#39;)
const mongoStore = require(&#39;connect-mongo&#39;)(session)



app.use(session({
  secret: &#39;recommand 128 bytes random string&#39;, // 建议使用 128 个字符的随机字符串  
 // 作为服务器端生成 session  cookie 的签名 ，防止篡改 ,
  // 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改。
 name: &#39;user&#39;,         
 // cookie 的名字 保存 session 的字段名称, 返回客户端的 key 的名称，默认为 connect.sid, 也可以自己设置。
 resave:  false,
 // 强制保存 session 即使它并没有变化 （默认： true）
 //saveUninitialized:
 // 初始化 session 时是否保存到存储。默认为 true， 但是 (后续版本) 有可能默认失效，所以最好手动添加。
cookie:  { maxAge: 60 * 1000 * 60 * 24 * 7 },
//session cookie 设置 设置返回到前端 key 的属性，默认值为{ path: ‘/’, httpOnly: true, secure: false, maxAge: null }。
//genid - 生成新 session ID 的函数 （默认使用 uid2 库）
 //rolling: false,
 // 在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false）
//proxy: true,
// 当设置了 secure cookies（通过”x-forwarded-proto” header ）时信任反向代理。当设定为 true 时，
//”x-forwarded-proto” header 将被使用。
// 当设定为 false 时，所有 headers 将被忽略。当该属性没有被设定时，将使用 Express 的 trust proxy。
saveUninitialized: false,
// 强制将未初始化的 session 存储。当新建了一个 session 且未设定属性或值时，它就处于
// 未初始化状态。在设定一个 cookie 前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。（默认：true）
// unset
// 控制 req.session 是否取消（例如通过 delete，或者将它的值设置为 null）。这可以使 session 保持存储
// 状态但忽略修改或删除的请求（默认：keep）
//session 存储实例
  store: new mongoStore({
  //  db: &#39;VueShop&#39;,
    url: sessionUrl,
    collection: &#39;sessions&#39;
  })
}))
</code></pre><p>使用</p>
<p>routes<br>    user.js</p>
<pre><code>

// 登录
router.post(&#39;/login&#39;, (req, res, next) =&gt; {
  const captcha = req.body.captcha.toLowerCase()
  console.log(captcha)
  console.log(req.session.captcha.toLowerCase())
  if (req.session.captcha.toLowerCase() !== captcha) {
    res.json({
      status: &#39;500&#39;,
      msg: &#39;验证码有错&#39;,
      result: &#39;&#39;
    })
    return
  }
  console.log(&#39;param&#39;)
  const param = {
    userName: req.body.userName,
    userPwd: req.body.userPwd
  }

  User.findOne(param)
    .then(doc =&gt; {
      if (doc) {
        res.cookie(&quot;userId&quot;, doc.userId, {
          path: &#39;/&#39;,
          maxAge: 1000 * 60 * 60 * 24 * 7
        })
        res.cookie(&quot;userName&quot;, doc.userName, {
          path: &#39;/&#39;,
          maxAge: 1000 * 60 * 60 * 24 * 7
        })

        req.session.user = {
          userName: doc.userName,
          userId: doc.userId
        }
        res.json({
          status: &#39;200&#39;,
          msg: &#39;OK&#39;,
          result: {
            userName: doc.userName
          }
        })
      } else {
        res.json({
          status: &#39;400&#39;,
          msg: &#39;用户名或者密码错误&#39;,
          result: &#39;&#39;
        })
      }
    })
    .catch(err =&gt; {
      res.json({
        status: &#39;404&#39;,
        msg: err.message,
        result: &#39;&#39;
      })
    })

})
</code></pre>]]></content> -->
      <content type="html"><![CDATA[Vue 版商城技术详情VueVue 配合 Vue-Router，Vuex 实现路由跳转，路由过渡，状态管理 Vue-lazyload头像图片懒加载 Vue-infinite-scroll滚动加载 Vue-pull-to-refresh自己开发的下拉刷新（实现插件） Axios实现 api 请求等的异步处理 Express后端服务器 获取数据 get 请求操作数据 post 请求 利用中间件，路由实现后端逻辑 MongoDB数据库 MongoDB 是一个基于文档的数据库，所有数据是从磁盘上进行读写的。MongoDB 善长的是对无模式 JSON 数据的查询。MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值 (key=&gt;value) 对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 Robomongo可视化 MongeDB 工具 Mongoose连接数据库和 Express 使用 promise 的调用方式 const mongoose = require(&#39;mongoose&#39;) const Schema = mongoose.Schema mongoose.Promise = global.Promise const productSchema = new Schema({ &quot;productId&quot;: String, &quot;productName&quot;: String, &quot;salePrice&quot;: Number, &quot;productImage&quot;: String, &quot;checked&quot;: Number, &quot;productNum&quot;: Number }) module.exports = mongoose.model(&#39;Good&#39;, productSchema) Api 插入数据 save 更新数据 update 查找 find 查找并更新 findByIdAndUpdate 移除 remove 数量查询 count 根据_id 查询 findById 变量 $or 或关系 $nor 或关系取反 $gt 大于 $gte 大于等于 $lt 小于 $lte 小于等于 $ne 不等于 $in 在多个值范围内 $nin 不在多个值范围内 $all 匹配数组中多个值 $regex 正则，用于模糊查询 $size 匹配数组大小 $maxDistance 范围查询，距离（基于 LBS） $mod 取模运算 $near 邻域查询，查询附近的位置（基于 LBS） $exists 字段是否存在 $elemMatch 匹配内数组内的元素 $within 范围查询（基于 LBS） $box 范围查询，矩形范围（基于 LBS） $center 范围醒询，圆形范围（基于 LBS） $centerSphere 范围查询，球形范围（基于 LBS） $slice 查询字段集合中的元素（比如从第几个之后，第 N 到第 M 个元素） 使用const Goods = require(&#39;../models/goods.js&#39;) mongoose.Promise = global.Promise var env = process.env.NODE_ENV || &#39;development&#39; if(env === &#39;development&#39;) { console.log(&#39;NODE_ENV:&#39;, env) mongoose.connect(&#39;mongodb://IP:port/shopdb&#39;) } else { console.log(&#39;NODE_ENV:&#39;, env) mongoose.connect(&#39;mongodb:// 用户. 数据库: password@IP:port/shopdb&#39;) } router.get(&#39;/list&#39;, (req, res, next) =&gt; { const sort = req.query.sort const page = req.query.page const pageSize = req.query.pageSize const priceChecked = req.query.priceChecked let params = {} let priceGt = &#39;&#39;, priceLte =&#39;&#39; if(priceChecked !== &#39;all&#39;) { switch(priceChecked) { case &#39;0&#39;: priceGt = 0; priceLte=500; break; case &#39;1&#39;: priceGt = 500; priceLte=1000; break; case &#39;2&#39;: priceGt = 1000; priceLte=2000; break; case &#39;3&#39;: priceGt = 2000; priceLte=4000; break; } params = { salePrice: { $gt: priceGt, $lte: priceLte } } console.log(params) } const skip = (page - 1) * pageSize; const goodsModel = Goods.find(params).skip(skip).limit(parseInt(pageSize)) goodsModel.sort({&#39;salePrice&#39;: sort}) goodsModel.exec((err, doc) =&gt; { if(err) { res.json({ status: &#39;404&#39;, msg: err.message }) } else { res.json({ status: &#39;200&#39;, msg: &#39;OK&#39;, result: { count: doc.length, list: doc } }) } }) }) 根据环境连接数据库var env = process.env.NODE_ENV || &#39;development&#39; var sessionUrl = &#39;&#39;if(env ===&#39;development&#39;) { console.log(&#39;app.NODE_ENV:&#39;, env) sessionUrl = &#39;mongodb://IP:port/shopdb&#39; } else { console.log(&#39;app.NODE_ENV:&#39;, env) sessionUrl = &#39;mongodb:// 用户. 数据库: password@IP:port/shopdb&#39; } Nginx代理转发upstream vue { server 本地 IP:port; } server { listen port; # server_name *. 主域名; server_name 外部 IP; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_pass http://vue; proxy_redirect off; } location /goods/ { proxy_pass http:// 本地 IP:port/goods/; } location /users/ { proxy_pass http:// 本地 IP:port/users/; } location /vueshop/ { alias 路径; } location ~* ^.+\.(jpg|jpeg|gif|png|svg|ico|webp|css|js|map|pdf|txt)$ { root 路径; } } 开启 gzip 压缩sudo vi /etc/nginx/nginx.conf ## # Gzip Settings ## gzip on; gzip_disable &quot;msie6&quot;; # 启用 gzip 压缩的最小文件，小于设置值的文件将不会压缩 gzip_min_length 1k; # 是否在 http header 中添加 Vary: Accept-Encoding，建议开启 gzip_vary on; # gzip_proxied any; # gzip 压缩级别，1-10，数字越大压缩的越好，也越占用 CPU 时间 gzip_comp_level 4; gzip_buffers 16 8k; # gzip_http_version 1.1; gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; PM2做守护进程, 发布更新项目 使用 ecosystem.json pm2 deploy ecosystem.json start 可以配置服务器 ip，指定 github 仓库 实现代码更新后快速部署到服务器中 { &quot;apps&quot;:[ { &quot;name&quot;:&quot;vueshop&quot;, &quot;script&quot;:&quot;入口脚本&quot;, &quot;env&quot;: { // 传进去的变量 &quot;COMMON_VARIABLE&quot;: &quot;true&quot; }, &quot;env_production&quot;: { &quot;NODE_ENV&quot;: &quot;production&quot; } } ], &quot;deploy&quot;: { // 部署任务 &quot;start&quot;: { // 任务名 &quot;user&quot;: &quot;&quot;,// 服务器上用来发布应用的 user&quot;host&quot;: [&quot;IP&quot;],&quot;port&quot;:&quot;port&quot;,&quot;ref&quot;:&quot;origin/master&quot;,&quot;repo&quot;:&quot;git 仓库 &quot;,&quot;path&quot;:&quot;&quot;, // 服务器项目位置 &quot;ssh_options&quot;: &quot;StrictHostKeyChecking=no&quot;, // 取消 key 校验 &quot;post-deploy&quot;: &quot;执行的命令行 &amp;&amp; pm2 startOrRestart ../ecosystem.json --env production&quot;, &quot;env&quot;: { &quot;NODE_ENV&quot;: &quot;production&quot; } } } } Echarts数据可视化显示 显示价格趋势，数据来自数据库（自己编的） 显示订单详情 Svg-captcha验证码 在考虑要使用验证码时, 发现许多相关的 npm 模块都要安装其它支持库（C 或 C++ 编写，而且平台兼容性极差） 最终在 CNode 社区发现了以 svg 为基础的 Svg-captcha 内部使用 opentype.js ， 把字符转换为 svg 路径，然后生成验证码 简单易用 const svgCaptcha = require(&#39;svg-captcha&#39;) router.get(&#39;/captcha&#39;, (req, res, next) =&gt; { const captcha = svgCaptcha.create({ background: &quot;#3E96D6&quot; }) req.session.captcha = captcha.text res.set(&#39;Content-Type&#39;, &#39;image/svg+xml&#39;) res.json({ status: &#39;200&#39;, msg: &#39;OK&#39;, result: captcha }) }) router.get(&#39;/isCaptchaTrue&#39;, (req, res, next) =&gt; { const captcha = req.query.captcha.toLowerCase() if (req.session.captcha.toLowerCase() !== captcha) { res.json({ status: &#39;500&#39;, msg: &#39;验证码有错&#39;, result: &#39;&#39; }) return } else { res.json({ status: &#39;200&#39;, msg: &#39;验证码正确&#39;, result: &#39;&#39; }) } }) sessionexpress 在 4.x 版本之后，session 管理和 cookies 等许多模块都不再直接包含在 express 中，而是需要单独添加相应模块。 express4 中操作 cookie 使用 cookie-parser 模块express4 中操作 session 使用 express-session 模块 session 的运作通过一个 session_id 来进行。session_id 通常是存放在客户端的 cookie 中，比如在 express 中，默认是 connect.sid 这个字段，当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改。 这意思就是说，当你浏览一个网页时，服务端随机产生一个 1024 比特长的字符串，然后存在你 cookie 中的 connect.sid 字段中。当你下次访问时，cookie 会带有这个字符串，然后浏览器就知道你是上次访问过的某某某，然后从服务器的存储中取出上次记录在你身上的数据。由于字符串是随机产生的，而且位数足够多，所以也不担心有人能够伪造。伪造成功的概率比坐在家里编程时被邻居家的狗突然闯入并咬死的几率还低。 session 可以存放在 1）内存、2）cookie 本身、3）redis 或 memcached 等缓存中，或者 4）数据库中。 使用 session 验证用户session 存储在数据库中 app.js 配置 const session = require(&#39;express-session&#39;) const mongoStore = require(&#39;connect-mongo&#39;)(session) app.use(session({ secret: &#39;recommand 128 bytes random string&#39;, // 建议使用 128 个字符的随机字符串 // 作为服务器端生成 session cookie 的签名 ，防止篡改 , // 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改。 name: &#39;user&#39;, // cookie 的名字 保存 session 的字段名称, 返回客户端的 key 的名称，默认为 connect.sid, 也可以自己设置。 resave: false, // 强制保存 session 即使它并没有变化 （默认： true） //saveUninitialized: // 初始化 session 时是否保存到存储。默认为 true， 但是 (后续版本) 有可能默认失效，所以最好手动添加。 cookie: { maxAge: 60 * 1000 * 60 * 24 * 7 }, //session cookie 设置 设置返回到前端 key 的属性，默认值为{ path: ‘/’, httpOnly: true, secure: false, maxAge: null }。 //genid - 生成新 session ID 的函数 （默认使用 uid2 库） //rolling: false, // 在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false） //proxy: true, // 当设置了 secure cookies（通过”x-forwarded-proto” header ）时信任反向代理。当设定为 true 时， //”x-forwarded-proto” header 将被使用。 // 当设定为 false 时，所有 headers 将被忽略。当该属性没有被设定时，将使用 Express 的 trust proxy。 saveUninitialized: false, // 强制将未初始化的 session 存储。当新建了一个 session 且未设定属性或值时，它就处于 // 未初始化状态。在设定一个 cookie 前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。（默认：true） // unset // 控制 req.session 是否取消（例如通过 delete，或者将它的值设置为 null）。这可以使 session 保持存储 // 状态但忽略修改或删除的请求（默认：keep） //session 存储实例 store: new mongoStore({ // db: &#39;VueShop&#39;, url: sessionUrl, collection: &#39;sessions&#39; }) })) 使用 routes user.js // 登录 router.post(&#39;/login&#39;, (req, res, next) =&gt; { const captcha = req.body.captcha.toLowerCase() console.log(captcha) console.log(req.session.captcha.toLowerCase()) if (req.session.captcha.toLowerCase() !== captcha) { res.json({ status: &#39;500&#39;, msg: &#39;验证码有错&#39;, result: &#39;&#39; }) return } console.log(&#39;param&#39;) const param = { userName: req.body.userName, userPwd: req.body.userPwd } User.findOne(param) .then(doc =&gt; { if (doc) { res.cookie(&quot;userId&quot;, doc.userId, { path: &#39;/&#39;, maxAge: 1000 * 60 * 60 * 24 * 7 }) res.cookie(&quot;userName&quot;, doc.userName, { path: &#39;/&#39;, maxAge: 1000 * 60 * 60 * 24 * 7 }) req.session.user = { userName: doc.userName, userId: doc.userId } res.json({ status: &#39;200&#39;, msg: &#39;OK&#39;, result: { userName: doc.userName } }) } else { res.json({ status: &#39;400&#39;, msg: &#39;用户名或者密码错误&#39;, result: &#39;&#39; }) } }) .catch(err =&gt; { res.json({ status: &#39;404&#39;, msg: err.message, result: &#39;&#39; }) }) })]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue 版商城 (一)]]></title>
      <url>http://ldqblog.me/2017/08/15/Vue%E7%89%88%E5%95%86%E5%9F%8E-%E4%B8%80/</url>
      <!-- <content type="html"><![CDATA[<h1 id="Vue-版商城介绍"><a href="#Vue-版商城介绍" class="headerlink" title="Vue 版商城介绍"></a>Vue 版商城介绍</h1><h2 id="预览地址"><a href="#预览地址" class="headerlink" title="预览地址"></a>预览地址</h2><p><a href="http://39.108.141.131/vueshop/#/" target="_blank" rel="external">预览地址</a></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><blockquote>
<p>部署在阿里云<br>采用 Nginx 进行代理转发<br>PM2 做守护进程</p>
</blockquote>
<p><img src="http://ldqblog.me/Vue-shop/static/font/%E6%B3%A8%E6%84%8F.svg" alt="注意"></p>
<p></p><h2 style="font-size: 26px; color: red;"> 注意存在的问题 </h2><p></p>
<p style="font-size: 24px; line-height: 1.5; font-weight: bold;"><br>    由于域名没有备案，所以用 ip 访问，防止被阿里云封 &lt; br&gt;<br>    由于没有使用 Https[国内的免费证书都要备案域名]<br><br>    Chrome，Firefox 等遇到 &lt;input type=”password”&gt; 会报不安全 &lt; br&gt;<br>    并非代码本身有问题 &lt; br&gt;<br></p>



<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/LDQ-first/Vue-shop" target="_blank" rel="external">GitHub</a></p>
<hr>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>做 Vue 版商城的原因：</p>
<pre><code>1. 了解前后端通信
2. 了解服务器部署
3. 了解 MongoDB
4. 了解 Nginx
</code></pre><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li><strong>Vue2.3</strong>: [ 前端框架 ]</li>
<li><strong>Vuex</strong>: [ 状态管理, 组件通信 ] </li>
<li><strong>Vue-router</strong>: [ 配置路由，组件切换 ]</li>
<li><strong>Vue-lazyload</strong>: [ 图片懒加载 ]</li>
<li><strong>Vue-infinite-scroll</strong>: [ 滚动加载 ]</li>
<li><strong>Vue-pull-to-refresh</strong>: [ 自己开发的下拉刷新 ]</li>
<li><strong>ES6/7</strong>: [ JS 版本 ]</li>
<li><strong>Webpack</strong>: [ 模块化处理，编译打包 ]</li>
<li><strong>Express</strong>: [ 服务器 ]</li>
<li><strong>Mongoose</strong>: [ 连接 MongoDB 数据库 ]</li>
<li><strong>Nginx</strong>: [ 代理转发，gzip 压缩等 ]</li>
<li><strong>PM2</strong>: [ 做守护进程, 发布更新项目 ]</li>
<li><strong>Axios</strong>: [ 基于 Promise 处理 HTTP 请求 ]</li>
<li><strong>SASS</strong>(<strong>SCSS</strong>): [ css 预处理器 ]</li>
<li><strong>Flex</strong>: [ 弹性布局 ]</li>
<li><strong>loaclStorge</strong>: [ 本地存储用户信息 ]</li>
<li><strong>Echarts</strong>: [ 数据可视化显示 ]</li>
<li><strong>Svg-captcha</strong>: [ 验证码 ]</li>
</ul>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://ldqblog.me/img/VShop/01.jpg" alt="01"> </p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>实现登录，注册，<br>添加删除购物车，添加删除地址，<br>完成订单，查看订单详情，<br>下拉刷新</p>
<p>阿里云部署</p>
<ol>
<li>创建新用户</li>
<li>更换端口，禁止 root 登录</li>
<li>安装配置 iptables， fail2ban，nginx，mongodb，nodejs</li>
<li>利用公私钥实现 ssh 无密码登录</li>
<li>利用 git，github，pm2 实现高效的部署代码</li>
<li>利用 nginx 开启 gizp</li>
</ol>
<p>注意<br>阿里云安全组本身就有做端口访问限制</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>没有备案, 没有使用 HTTPS，导致 chrome 提示不安全<br>没有实现 RESTful API</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>解决问题<br>优化代码<br>优化服务器配置</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Vue 文档 </strong>: <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="external">https://cn.vuejs.org/v2/guide/</a><br><strong>Mongoose 文档 </strong>: <a href="http://mongoosejs.com/" target="_blank" rel="external">http://mongoosejs.com/</a><br><strong>Mongodb 文档 </strong>: <a href="https://docs.mongodb.com/" target="_blank" rel="external">https://docs.mongodb.com/</a></p>
]]></content> -->
      <content type="html"><![CDATA[Vue 版商城介绍预览地址预览地址 部署 部署在阿里云采用 Nginx 进行代理转发PM2 做守护进程 注意存在的问题 由于域名没有备案，所以用 ip 访问，防止被阿里云封 &lt; br&gt; 由于没有使用 Https[国内的免费证书都要备案域名] Chrome，Firefox 等遇到 &lt;input type=”password”&gt; 会报不安全 &lt; br&gt; 并非代码本身有问题 &lt; br&gt; 源码GitHub 起因做 Vue 版商城的原因： 1. 了解前后端通信 2. 了解服务器部署 3. 了解 MongoDB 4. 了解 Nginx 技术栈 Vue2.3: [ 前端框架 ] Vuex: [ 状态管理, 组件通信 ] Vue-router: [ 配置路由，组件切换 ] Vue-lazyload: [ 图片懒加载 ] Vue-infinite-scroll: [ 滚动加载 ] Vue-pull-to-refresh: [ 自己开发的下拉刷新 ] ES6/7: [ JS 版本 ] Webpack: [ 模块化处理，编译打包 ] Express: [ 服务器 ] Mongoose: [ 连接 MongoDB 数据库 ] Nginx: [ 代理转发，gzip 压缩等 ] PM2: [ 做守护进程, 发布更新项目 ] Axios: [ 基于 Promise 处理 HTTP 请求 ] SASS(SCSS): [ css 预处理器 ] Flex: [ 弹性布局 ] loaclStorge: [ 本地存储用户信息 ] Echarts: [ 数据可视化显示 ] Svg-captcha: [ 验证码 ] 效果图 成果实现登录，注册，添加删除购物车，添加删除地址，完成订单，查看订单详情，下拉刷新 阿里云部署 创建新用户 更换端口，禁止 root 登录 安装配置 iptables， fail2ban，nginx，mongodb，nodejs 利用公私钥实现 ssh 无密码登录 利用 git，github，pm2 实现高效的部署代码 利用 nginx 开启 gizp 注意阿里云安全组本身就有做端口访问限制 问题没有备案, 没有使用 HTTPS，导致 chrome 提示不安全没有实现 RESTful API 未来解决问题优化代码优化服务器配置 参考资料Vue 文档 : https://cn.vuejs.org/v2/guide/Mongoose 文档 : http://mongoosejs.com/Mongodb 文档 : https://docs.mongodb.com/]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TypeScript 入门]]></title>
      <url>http://ldqblog.me/2017/08/12/TypeScript-%E5%85%A5%E9%97%A8/</url>
      <!-- <content type="html"><![CDATA[<h1 id="TypeScript-入门"><a href="#TypeScript-入门" class="headerlink" title="TypeScript 入门"></a>TypeScript 入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 是一门弱类型语言，没有类型检测，这让 JavaScript 很灵活，但也更容易出错</p>
<blockquote>
<p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。  </p>
</blockquote>
<h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><blockquote>
<p>官网<br><a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript</a><br>中文文档<br><a href="https://www.tslang.cn/index.html" target="_blank" rel="external">tslang</a><br>查看编译后的结果<br><a href="http://www.typescriptlang.org/play/index.html" target="_blank" rel="external">typescriptlang</a></p>
</blockquote>
<h2 id="很多项目开始使用-TypeScript"><a href="#很多项目开始使用-TypeScript" class="headerlink" title="很多项目开始使用 TypeScript"></a>很多项目开始使用 TypeScript</h2><blockquote>
<p>Angular</p>
<div class="github-widget" data-repo="angular/angular"></div>

<p>VSCode</p>
<div class="github-widget" data-repo="Microsoft/vscode"></div>

<p>RxJS</p>
<div class="github-widget" data-repo="Reactive-Extensions/RxJS"></div>

</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install -g typescript
</code></pre><h3 id="安装完后运行-tsc-v-查看是否正确安装"><a href="#安装完后运行-tsc-v-查看是否正确安装" class="headerlink" title="安装完后运行 tsc -v 查看是否正确安装"></a>安装完后运行 tsc -v 查看是否正确安装</h3><pre><code>tsc -v
Version 2.4.2
</code></pre><h3 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h3><p>tsc -h 或 tsc –help 查看帮助</p>
<pre><code>$ tsc -h
Version 2.4.2
Syntax:  tsc [options] [file ...]

Examples: tsc hello.ts
          tsc --outFile file.js file.ts
          tsc @args.txt
Options:
...
</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>生成默认的配置文件 tsconfig.json</p>
<pre><code>tsc init
</code></pre><ul>
<li>配置 es6</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-084ac9734f4aceab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="支持-TypeScript-的文本编辑器和-IDE"><a href="#支持-TypeScript-的文本编辑器和-IDE" class="headerlink" title="支持 TypeScript 的文本编辑器和 IDE"></a>支持 TypeScript 的文本编辑器和 IDE</h3><p>通过本身或插件支持 TypeScript 的语法、智能提示、纠错等</p>
<ul>
<li>VSCode 微软开发的轻量级编辑器，内置支持 TypeScript</li>
<li>Sublime Text 有相关插件</li>
<li>WebStorm 新版内置支持 TypeScript</li>
<li>其他包括 Vim，Atom，Emacs 等</li>
</ul>
<h3 id="将-TypeScrip-编译成-JavaScript"><a href="#将-TypeScrip-编译成-JavaScript" class="headerlink" title="将 TypeScrip 编译成 JavaScript"></a>将 TypeScrip 编译成 JavaScript</h3><p>TypeScript 的文件类型是. ts 文件或 JSX 中的. tsx 文件，不能直接运行在浏览器中，需要编译成. js 文件</p>
<p>方法：</p>
<ol>
<li><p>用命令行工具进行编译</p>
<pre><code>
Syntax:  tsc [options] [file ...]

Examples: tsc hello.ts

        tsc --outFile file.js file.ts

        tsc @args.txt
</code></pre><p>最后一个的作用是从一个文件中插入命令行选项和文件</p>
<pre><code>
@&lt;file&gt;    Insert command line options and files from a file.
</code></pre></li>
<li><p>在 VSCode 或其他文本编辑器和 IDE 上操作</p>
</li>
<li><p>使用自动化构建工具，如 gulp， webpack 等</p>
</li>
</ol>
<h3 id="介绍一下第一种方法"><a href="#介绍一下第一种方法" class="headerlink" title="介绍一下第一种方法"></a>介绍一下第一种方法</h3><p>下面的命令行把 TypeScript 文件 main.ts 编译为 JavaScript 版本的 main.js。如果 main.js 已经存在的话会被覆盖。</p>
<pre><code>    tsc main.ts
</code></pre><p>可以同时编译多个文件</p>
<pre><code>tsc main.ts other.ts

tsc *.ts
</code></pre><p>还可以通过 –watch 或 - w 来自动编译 (修改后能自动转成. js 文件)</p>
<pre><code>tsc main.ts --watch
</code></pre><h3 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h3><p>TypeScript 可以声明变量类型，这样编译器就可以确保赋值时不会产生类型错误<br>如果省略了类型声明，TypeScript 将会从代码中自动推测出正确的类型。</p>
<p>在变量，函数声明时可以定义自己的类型</p>
<pre><code>var burger: string = &#39;hamburger&#39;,    // String 
    calories: number = 300,          // Numeric
    tasty: boolean = true;            // Boolean

function speak(food: string, energy: number): void {
  console.log(&quot;Our&quot; + food + &quot;has&quot; + energy + &quot;calories.&quot;);
}

speak(burger, calories);
</code></pre><p>编译后变量声明都会被移除</p>
<pre><code>var burger = &#39;hamburger&#39;,
    calories = 300, 
    tasty = true; 

function speak(food, energy) {
    console.log(&quot;Our&quot; + food + &quot;has&quot; + energy + &quot;calories.&quot;);
}

speak(burger, calories);
</code></pre><p>如果输入的类型有错，TypeScript 会有代码警告<br>但还是会转成 js 文件</p>
<p>ts 文件</p>
<pre><code>var carNum: Number = &#39;10&#39;
</code></pre><pre><code>$ tsc err.ts --watch
err.ts(1,5): error TS2322: Type &#39;&quot;10&quot;&#39; is not assignable to type &#39;Number&#39;.
10:36:46 - Compilation complete. Watching for file changes.
</code></pre><p>js 文件</p>
<pre><code>var carNum = &#39;10&#39;;
</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>Number ( 数值 ) - 包括整型，浮点型等</li>
</ul>
<pre><code>let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
</code></pre><ul>
<li>String （字符串）- 包括单双引号的字符串</li>
</ul>
<pre><code>let color: string = &quot;blue&quot;;
color = &#39;red&#39;;
let sentence: string = `Hello, my name is ${ fullName }.
I&#39;ll be ${ age + 1 } years old next month.`;
</code></pre><ul>
<li>Boolean （布尔）- true ,false, 不可用其他类型如数字, 空字符串，否则会报错 </li>
</ul>
<pre><code>let isDone: boolean = false
</code></pre><ul>
<li>Array （数组）- 有两种语法：my_arr: number[ ] 或者 my_arr: Array<number></number></li>
</ul>
<pre><code>let list: number[] = [1, 2, 3]

let list: Array&lt;number&gt; = [1, 2, 3]
</code></pre><ul>
<li>Tuple ( 元组 ) - 数组中包含不同的类型，有顺序</li>
</ul>
<pre><code>let x: [string, number];
x = [&quot;hello&quot;, 10]; // OK
x = [10, &quot;hello&quot;]; // Error
</code></pre><p>使用不是该数据类型的方法会报错</p>
<pre><code>console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, &#39;number&#39; does not have &#39;substr&#39;
</code></pre><p>新赋值的类型必须是定义时规定的类型</p>
<pre><code>x[3] = &quot;world&quot;; // OK, &#39;string&#39; can be assigned to &#39;string | number&#39;

console.log(x[5].toString()); // OK, &#39;string&#39; and &#39;number&#39; both have &#39;toString&#39;

x[6] = true; // Error, &#39;boolean&#39; isn&#39;t&#39;string | number&#39;
</code></pre><ul>
<li>Enum （枚举类型）- 它用于声明一组命名的常数，当一个变量有几种可能的取值时，可以将它定义为枚举类型。</li>
</ul>
<p>让代码更有语义化, 可读性</p>
<pre><code>enum Color {Red, Green, Blue}
let c: Color = Color.Green;
</code></pre><p>枚举类型的数字默认从 0 开始，可以自己设置</p>
<pre><code>enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;

enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;
</code></pre><p>当不知道 enum 类型的第 N 项是什么名称时，可以用 N 来代替</p>
<pre><code>enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

alert(colorName);
</code></pre><pre><code>var Color;
(function (Color) {
    Color[Color[&quot;Red&quot;] = 1] = &quot;Red&quot;;
    Color[Color[&quot;Green&quot;] = 2] = &quot;Green&quot;;
    Color[Color[&quot;Blue&quot;] = 3] = &quot;Blue&quot;;
})(Color || (Color = {}));
var colorName = Color[2];
alert(colorName);
</code></pre><ul>
<li>Any （任意）- 任何类型都可以（Never 类型除外）</li>
</ul>
<p>关闭类型检查</p>
<pre><code>let notSure: any = 4;
notSure = &quot;maybe a string instead&quot;;
notSure = false; // okay, definitely a boolean
</code></pre><pre><code>let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn&#39;t check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property &#39;toFixed&#39; doesn&#39;t exist on type&#39;Object&#39;.
</code></pre><pre><code>let list: any[] = [1, true, &quot;free&quot;];

list[1] = 100;
</code></pre><ul>
<li>Void （空）- 用在不返回任何值的函数中</li>
</ul>
<pre><code>function warnUser(): void {
    alert(&quot;This is my warning message&quot;);
}
</code></pre><p>可以用来标识 undefined 和 null</p>
<pre><code>let unusable: void = undefined;
</code></pre><ul>
<li>Null and Undefined</li>
</ul>
<pre><code>let u: undefined = undefined;
let n: null = null;
</code></pre><p>默认为其他类型的亚类型，就是可以匹配其他类型<br>使用 –strictNullChecks 标识，就只匹配 null 、undefined、void<br>可以使用 string | null | undefined 类型来只匹配 string 、 null 、 undefined 三种类型</p>
<blockquote>
<p>官方鼓励使用 –strictNullChecks</p>
</blockquote>
<ul>
<li>Never - 表示值从未发生</li>
</ul>
<p>Any 类型不能匹配 Never</p>
<pre><code>// Function returning never must have unreachable end point
function error(message: string): never {
    throw new Error(message);
}

// Inferred return type is never
function fail() {
    return error(&quot;Something failed&quot;);
}

// Function returning never must have unreachable end point
function infiniteLoop(): never {
    while (true) {
    }
}
</code></pre><ul>
<li>Type assertions</li>
</ul>
<p>“angle-bracket” syntax</p>
<pre><code>let someValue: any = &quot;this is a string&quot;;

let strLength: number = (&lt;string&gt;someValue).length;
</code></pre><p>as -syntax</p>
<pre><code>let someValue: any = &quot;this is a string&quot;;

let strLength: number = (someValue as string).length;
</code></pre><p>一般情况下，两种写法等价，但在 JSX 中，只能用 as -style</p>
<blockquote>
<p>官方文档中关于数据类型的介绍 <a href="http://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="external">Basic Types</a></p>
</blockquote>
<h3 id="Interfaces-接口"><a href="#Interfaces-接口" class="headerlink" title="Interfaces 接口"></a>Interfaces 接口</h3><p>接口会根据一个对象是否符合某种特定的数据结构来进行类型检查</p>
<p>只在开发是有效，编译后删除</p>
<pre><code>interface Food {
    name: string;
    calories: number;
}

function speak(food: Food): void{
  console.log(&quot;Our&quot; + food.name + &quot;has&quot; + food.calories + &quot;calories.&quot;);
}

var ice_cream = {
  name: &quot;ice cream&quot;, 
  calories: 200
}

speak(ice_cream);
</code></pre><p>属性的顺序并不重要。我们只需必要的属性存在并且是正确的类型。如果哪里有遗漏，类型错误，或者命名不同的话，编译器都会报警告信息。</p>
<pre><code>interface Food {
    name: string;
    calories: number;
}

function speak(food: Food): void{
  console.log(&quot;Our&quot; + food.name + &quot;has&quot; + food.calories + &quot;grams.&quot;);
}

// 将 name 改为 nmae
var ice_cream = {
  nmae: &quot;ice cream&quot;, 
  calories: 200
}

speak(ice_cream);
</code></pre><pre><code>main.ts(16,7): error TS2345: Argument of type &#39;{ nmae: string; calories: number; } 
is not assignable to parameter of type &#39;Food&#39;. 
Property &#39;name&#39; is missing in type &#39;{ nmae: string; calories: number; }&#39;.
</code></pre><p>接口可以在属性后面添加？表示可选<br>可以添加 [propName:  类型] : any 表示可以添加任何某种类型的属性</p>
<pre><code>interface Person {    name: string;
    age?: number;
    [propName: string]: any;
}

const preson: Person = { name: &#39;Tom&#39;, age: 20}
const student: Person = { name: &#39;Tom&#39;}
</code></pre><ul>
<li>类实现接口</li>
</ul>
<p>关键字 implements</p>
<pre><code>interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
</code></pre><pre><code>interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
</code></pre><blockquote>
<p>官方文档有更详细的介绍 <a href="http://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="external">interfaces</a></p>
</blockquote>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>包括了构造器、继承，抽象类，接口，构造函数、setters、getters、public、private、protected、readonly、static 等</p>
<p>ES6 中也有实现</p>
<ul>
<li>属性<br>默认为 public<br>private 只有自己可以用<br>protected 自己和子类可用<br>readonly 只读 (原理 object.freeze)</li>
<li>抽象类 不能实例化</li>
</ul>
<p>实现继承</p>
<pre><code>class Menu {
  // Our properties:
  // By default they are public, but can also be private or protected.
  items: Array&lt;string&gt;;  // The items in the menu, an array of strings.
  pages: number;        // How many pages will the menu be, a number.

  constructor(item_list: Array&lt;string&gt;, total_pages: number) {
    // The this keyword is mandatory.
    this.items = item_list;    
    this.pages = total_pages;
  }

  // Methods
  list(): void {
    console.log(&quot;Our menu for today:&quot;);
    for(var i=0; i&lt;this.items.length; i++) {
      console.log(this.items[i]);
    }
  }

} 

// Create a new instance of the Menu class.
var sundayMenu = new Menu([&quot;pancakes&quot;,&quot;waffles&quot;,&quot;orange juice&quot;], 1);

// Call the list method.
sundayMenu.list();
</code></pre><pre><code>class HappyMeal extends Menu {
  // Properties are inherited

  // A new constructor has to be defined.
  constructor(item_list: Array&lt;string&gt;, total_pages: number) {
    // In this case we want the exact same constructor as the parent class (Menu), 
    // To automatically copy it we can call super() - a reference to the parent&#39;s constructor.
    super(item_list, total_pages);
  }

  // Just like the properties, methods are inherited from the parent.
  // However, we want to override the list() function so we redefine it.
  list(): void{
    console.log(&quot;Our special menu for children:&quot;);
    for(var i=0; i&lt;this.items.length; i++) {
      console.log(this.items[i]);
    }

  }
}

// Create a new instance of the HappyMeal class.
var menu_for_children = new HappyMeal([&quot;candy&quot;,&quot;drink&quot;,&quot;toy&quot;], 1);

// This time the log message will begin with the special introduction.
menu_for_children.list();
</code></pre><blockquote>
<p>阅读官方文档，获得更多信息 <a href="http://www.typescriptlang.org/docs/handbook/classes.html" target="_blank" rel="external">classes</a></p>
</blockquote>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p>
<pre><code>function genericFunc&lt;T&gt;(argument: T): T[] {    
  var arrayOfT: T[] = [];    // Create empty array of type T.
  arrayOfT.push(argument);  // Push, now arrayOfT = [argument].
  return arrayOfT;
}

var arrayFromString = genericFunc&lt;string&gt;(&quot;beep&quot;);
console.log(arrayFromString[0]);        // &quot;beep&quot;
console.log(typeof arrayFromString[0])  // String

var arrayFromNumber = genericFunc(42);
console.log(arrayFromNumber[0]);        // 42
console.log(typeof arrayFromNumber[0])  // number
</code></pre><ul>
<li>带泛型的函数类型</li>
</ul>
<pre><code>let f: () =&gt; any = function() {}

let f: &lt;T&gt;(arg: T) =&gt; T = function() {}
</code></pre><ul>
<li>带泛型的接口</li>
</ul>
<pre><code>interface Gen&lt;T&gt; {    (arg: T) : T
}

function fn&lt;T&gt;(arg: T): T {
    return arg;
}

let id: Gen&lt;number&gt; = fn;

Gen(2)
</code></pre><ul>
<li>带泛型的类 </li>
</ul>
<pre><code>class Gen&lt;T&gt; {    value: T
    add: (x: T, y: T) =&gt; T
}

let myGenNum = new Gen&lt;number&gt;()

myGenNum.value = 0
myGenNum.add = (x, y) =&gt; x + y

myGenNum.add(2,3)
</code></pre><ul>
<li>泛型约束</li>
</ul>
<pre><code>interface Length {    
    length: number
}

function fn&lt;T extends Length&gt;(arg: T): T {
    console.log(arg.length)
    return arg
}

fn&lt;string&gt;(&quot;hello&quot;)
</code></pre><blockquote>
<p>官方文档介绍了更多关于泛型类，泛型类与接口绑定等例子<br><a href="http://www.typescriptlang.org/docs/handbook/generics.html" target="_blank" rel="external">generics</a></p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code>function add(x: number, y: number): number {
    return x + y;
}

let myAdd = function(x: number, y: number): number { return x+y; };
</code></pre><ul>
<li>箭头函数</li>
</ul>
<pre><code>// myAdd has the full function type
let myAdd = function(x: number, y: number): number { return  x + y; };

// The parameters &#39;x&#39; and &#39;y&#39; have the type number
let myAdd: (baseValue:number, increment:number) =&gt; number =
    function(x, y) { return x + y; };
</code></pre><p>参数可选</p>
<pre><code>function buildName(firstName: string, lastName?: string) {
    // ...
}
</code></pre><p>剩余参数</p>
<pre><code>function buildName(firstName: string, ...restOfName: string[]) {
    return firstName + &quot;&quot; + restOfName.join(&quot; &quot;);
}

let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;);
</code></pre><blockquote>
<p>官方文档 <a href="http://www.typescriptlang.org/docs/handbook/functions.html" target="_blank" rel="external">functions</a></p>
</blockquote>
<h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><ul>
<li>联合</li>
</ul>
<pre><code>function padLeft(value: string, padding: string | number) {
    // ...
}

let indentedString = padLeft(&quot;Hello world&quot;, true); // errors during compilation
</code></pre><blockquote>
<p>官方文档 <a href="http://www.typescriptlang.org/docs/handbook/advanced-types.html" target="_blank" rel="external">Advanced Types</a></p>
</blockquote>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>如：require.js （AMD 规范）</p>
<p>exporter.ts</p>
<pre><code>var sayHi = function(): void {
    console.log(&quot;Hello!&quot;);
}

export = sayHi;
</code></pre><p>importer.ts</p>
<pre><code>import sayHi = require(&#39;./exporter&#39;);
sayHi();
</code></pre><p>引入 require.js，查看官方文档 <a href="http://requirejs.org/docs/start.html#add" target="_blank" rel="external">requirejs</a></p>
<pre><code>tsc --module amd *.ts
</code></pre><blockquote>
<p>更多模块化的内容，可查看官方文档 <a href="http://www.typescriptlang.org/docs/handbook/modules.html" target="_blank" rel="external">modules</a></p>
</blockquote>
<h3 id="第三方声明文件"><a href="#第三方声明文件" class="headerlink" title="第三方声明文件"></a>第三方声明文件</h3><p>声明文件用来是说明第三方 JavaScript 库是否和 TypeScript 兼容<br>一个声明文件包含. d.ts 扩展名和关于该库的多种信息，还有 API</p>
<p>声明文件通常是手写的，但也可以用其他人写好的<br><a href="http://definitelytyped.org/" target="_blank" rel="external">DefinitelyTyped</a></p>
<ul>
<li>The repository for high quality TypeScript type definitions<br>也有一个用来管理 TypeScript 定义的 Node.js 流行模块，叫 Typings。</li>
</ul>
<blockquote>
<p>官方文档 <a href="http://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="external">introduction</a></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong> 三十分钟学会 TypeScript</strong>: <a href="http://web.jobbole.com/87535/" target="_blank" rel="external">http://web.jobbole.com/87535/</a><br><strong> 官方文档 </strong>: <a href="http://www.typescriptlang.org/docs/home.html" target="_blank" rel="external">http://www.typescriptlang.org/docs/home.html</a><br><strong> 中文文档 </strong>: <a href="https://www.tslang.cn/index.html" target="_blank" rel="external">https://www.tslang.cn/index.html</a></p>
]]></content> -->
      <content type="html"><![CDATA[TypeScript 入门简介JavaScript 是一门弱类型语言，没有类型检测，这让 JavaScript 很灵活，但也更容易出错 TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。 网站 官网TypeScript中文文档tslang查看编译后的结果typescriptlang 很多项目开始使用 TypeScript Angular VSCode RxJS 安装npm install -g typescript 安装完后运行 tsc -v 查看是否正确安装tsc -v Version 2.4.2 查看帮助tsc -h 或 tsc –help 查看帮助 $ tsc -h Version 2.4.2 Syntax: tsc [options] [file ...] Examples: tsc hello.ts tsc --outFile file.js file.ts tsc @args.txt Options: ... 配置文件生成默认的配置文件 tsconfig.json tsc init 配置 es6 支持 TypeScript 的文本编辑器和 IDE通过本身或插件支持 TypeScript 的语法、智能提示、纠错等 VSCode 微软开发的轻量级编辑器，内置支持 TypeScript Sublime Text 有相关插件 WebStorm 新版内置支持 TypeScript 其他包括 Vim，Atom，Emacs 等 将 TypeScrip 编译成 JavaScriptTypeScript 的文件类型是. ts 文件或 JSX 中的. tsx 文件，不能直接运行在浏览器中，需要编译成. js 文件 方法： 用命令行工具进行编译 Syntax: tsc [options] [file ...] Examples: tsc hello.ts tsc --outFile file.js file.ts tsc @args.txt 最后一个的作用是从一个文件中插入命令行选项和文件 @&lt;file&gt; Insert command line options and files from a file. 在 VSCode 或其他文本编辑器和 IDE 上操作 使用自动化构建工具，如 gulp， webpack 等 介绍一下第一种方法下面的命令行把 TypeScript 文件 main.ts 编译为 JavaScript 版本的 main.js。如果 main.js 已经存在的话会被覆盖。 tsc main.ts 可以同时编译多个文件 tsc main.ts other.ts tsc *.ts 还可以通过 –watch 或 - w 来自动编译 (修改后能自动转成. js 文件) tsc main.ts --watch 静态类型TypeScript 可以声明变量类型，这样编译器就可以确保赋值时不会产生类型错误如果省略了类型声明，TypeScript 将会从代码中自动推测出正确的类型。 在变量，函数声明时可以定义自己的类型 var burger: string = &#39;hamburger&#39;, // String calories: number = 300, // Numeric tasty: boolean = true; // Boolean function speak(food: string, energy: number): void { console.log(&quot;Our&quot; + food + &quot;has&quot; + energy + &quot;calories.&quot;); } speak(burger, calories); 编译后变量声明都会被移除 var burger = &#39;hamburger&#39;, calories = 300, tasty = true; function speak(food, energy) { console.log(&quot;Our&quot; + food + &quot;has&quot; + energy + &quot;calories.&quot;); } speak(burger, calories); 如果输入的类型有错，TypeScript 会有代码警告但还是会转成 js 文件 ts 文件 var carNum: Number = &#39;10&#39; $ tsc err.ts --watch err.ts(1,5): error TS2322: Type &#39;&quot;10&quot;&#39; is not assignable to type &#39;Number&#39;. 10:36:46 - Compilation complete. Watching for file changes. js 文件 var carNum = &#39;10&#39;; 数据类型 Number ( 数值 ) - 包括整型，浮点型等 let decimal: number = 6; let hex: number = 0xf00d; let binary: number = 0b1010; let octal: number = 0o744; String （字符串）- 包括单双引号的字符串 let color: string = &quot;blue&quot;; color = &#39;red&#39;; let sentence: string = `Hello, my name is ${ fullName }. I&#39;ll be ${ age + 1 } years old next month.`; Boolean （布尔）- true ,false, 不可用其他类型如数字, 空字符串，否则会报错 let isDone: boolean = false Array （数组）- 有两种语法：my_arr: number[ ] 或者 my_arr: Array let list: number[] = [1, 2, 3] let list: Array&lt;number&gt; = [1, 2, 3] Tuple ( 元组 ) - 数组中包含不同的类型，有顺序 let x: [string, number]; x = [&quot;hello&quot;, 10]; // OK x = [10, &quot;hello&quot;]; // Error 使用不是该数据类型的方法会报错 console.log(x[0].substr(1)); // OK console.log(x[1].substr(1)); // Error, &#39;number&#39; does not have &#39;substr&#39; 新赋值的类型必须是定义时规定的类型 x[3] = &quot;world&quot;; // OK, &#39;string&#39; can be assigned to &#39;string | number&#39; console.log(x[5].toString()); // OK, &#39;string&#39; and &#39;number&#39; both have &#39;toString&#39; x[6] = true; // Error, &#39;boolean&#39; isn&#39;t&#39;string | number&#39; Enum （枚举类型）- 它用于声明一组命名的常数，当一个变量有几种可能的取值时，可以将它定义为枚举类型。 让代码更有语义化, 可读性 enum Color {Red, Green, Blue} let c: Color = Color.Green; 枚举类型的数字默认从 0 开始，可以自己设置 enum Color {Red = 1, Green, Blue} let c: Color = Color.Green; enum Color {Red = 1, Green = 2, Blue = 4} let c: Color = Color.Green; 当不知道 enum 类型的第 N 项是什么名称时，可以用 N 来代替 enum Color {Red = 1, Green, Blue} let colorName: string = Color[2]; alert(colorName); var Color; (function (Color) { Color[Color[&quot;Red&quot;] = 1] = &quot;Red&quot;; Color[Color[&quot;Green&quot;] = 2] = &quot;Green&quot;; Color[Color[&quot;Blue&quot;] = 3] = &quot;Blue&quot;; })(Color || (Color = {})); var colorName = Color[2]; alert(colorName); Any （任意）- 任何类型都可以（Never 类型除外） 关闭类型检查 let notSure: any = 4; notSure = &quot;maybe a string instead&quot;; notSure = false; // okay, definitely a boolean let notSure: any = 4; notSure.ifItExists(); // okay, ifItExists might exist at runtime notSure.toFixed(); // okay, toFixed exists (but the compiler doesn&#39;t check) let prettySure: Object = 4; prettySure.toFixed(); // Error: Property &#39;toFixed&#39; doesn&#39;t exist on type&#39;Object&#39;. let list: any[] = [1, true, &quot;free&quot;]; list[1] = 100; Void （空）- 用在不返回任何值的函数中 function warnUser(): void { alert(&quot;This is my warning message&quot;); } 可以用来标识 undefined 和 null let unusable: void = undefined; Null and Undefined let u: undefined = undefined; let n: null = null; 默认为其他类型的亚类型，就是可以匹配其他类型使用 –strictNullChecks 标识，就只匹配 null 、undefined、void可以使用 string | null | undefined 类型来只匹配 string 、 null 、 undefined 三种类型 官方鼓励使用 –strictNullChecks Never - 表示值从未发生 Any 类型不能匹配 Never // Function returning never must have unreachable end point function error(message: string): never { throw new Error(message); } // Inferred return type is never function fail() { return error(&quot;Something failed&quot;); } // Function returning never must have unreachable end point function infiniteLoop(): never { while (true) { } } Type assertions “angle-bracket” syntax let someValue: any = &quot;this is a string&quot;; let strLength: number = (&lt;string&gt;someValue).length; as -syntax let someValue: any = &quot;this is a string&quot;; let strLength: number = (someValue as string).length; 一般情况下，两种写法等价，但在 JSX 中，只能用 as -style 官方文档中关于数据类型的介绍 Basic Types Interfaces 接口接口会根据一个对象是否符合某种特定的数据结构来进行类型检查 只在开发是有效，编译后删除 interface Food { name: string; calories: number; } function speak(food: Food): void{ console.log(&quot;Our&quot; + food.name + &quot;has&quot; + food.calories + &quot;calories.&quot;); } var ice_cream = { name: &quot;ice cream&quot;, calories: 200 } speak(ice_cream); 属性的顺序并不重要。我们只需必要的属性存在并且是正确的类型。如果哪里有遗漏，类型错误，或者命名不同的话，编译器都会报警告信息。 interface Food { name: string; calories: number; } function speak(food: Food): void{ console.log(&quot;Our&quot; + food.name + &quot;has&quot; + food.calories + &quot;grams.&quot;); } // 将 name 改为 nmae var ice_cream = { nmae: &quot;ice cream&quot;, calories: 200 } speak(ice_cream); main.ts(16,7): error TS2345: Argument of type &#39;{ nmae: string; calories: number; } is not assignable to parameter of type &#39;Food&#39;. Property &#39;name&#39; is missing in type &#39;{ nmae: string; calories: number; }&#39;. 接口可以在属性后面添加？表示可选可以添加 [propName: 类型] : any 表示可以添加任何某种类型的属性 interface Person { name: string; age?: number; [propName: string]: any; } const preson: Person = { name: &#39;Tom&#39;, age: 20} const student: Person = { name: &#39;Tom&#39;} 类实现接口 关键字 implements interface ClockInterface { currentTime: Date; } class Clock implements ClockInterface { currentTime: Date; constructor(h: number, m: number) { } } interface ClockInterface { currentTime: Date; setTime(d: Date); } class Clock implements ClockInterface { currentTime: Date; setTime(d: Date) { this.currentTime = d; } constructor(h: number, m: number) { } } 官方文档有更详细的介绍 interfaces 类包括了构造器、继承，抽象类，接口，构造函数、setters、getters、public、private、protected、readonly、static 等 ES6 中也有实现 属性默认为 publicprivate 只有自己可以用protected 自己和子类可用readonly 只读 (原理 object.freeze) 抽象类 不能实例化 实现继承 class Menu { // Our properties: // By default they are public, but can also be private or protected. items: Array&lt;string&gt;; // The items in the menu, an array of strings. pages: number; // How many pages will the menu be, a number. constructor(item_list: Array&lt;string&gt;, total_pages: number) { // The this keyword is mandatory. this.items = item_list; this.pages = total_pages; } // Methods list(): void { console.log(&quot;Our menu for today:&quot;); for(var i=0; i&lt;this.items.length; i++) { console.log(this.items[i]); } } } // Create a new instance of the Menu class. var sundayMenu = new Menu([&quot;pancakes&quot;,&quot;waffles&quot;,&quot;orange juice&quot;], 1); // Call the list method. sundayMenu.list(); class HappyMeal extends Menu { // Properties are inherited // A new constructor has to be defined. constructor(item_list: Array&lt;string&gt;, total_pages: number) { // In this case we want the exact same constructor as the parent class (Menu), // To automatically copy it we can call super() - a reference to the parent&#39;s constructor. super(item_list, total_pages); } // Just like the properties, methods are inherited from the parent. // However, we want to override the list() function so we redefine it. list(): void{ console.log(&quot;Our special menu for children:&quot;); for(var i=0; i&lt;this.items.length; i++) { console.log(this.items[i]); } } } // Create a new instance of the HappyMeal class. var menu_for_children = new HappyMeal([&quot;candy&quot;,&quot;drink&quot;,&quot;toy&quot;], 1); // This time the log message will begin with the special introduction. menu_for_children.list(); 阅读官方文档，获得更多信息 classes 泛型泛型是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。 function genericFunc&lt;T&gt;(argument: T): T[] { var arrayOfT: T[] = []; // Create empty array of type T. arrayOfT.push(argument); // Push, now arrayOfT = [argument]. return arrayOfT; } var arrayFromString = genericFunc&lt;string&gt;(&quot;beep&quot;); console.log(arrayFromString[0]); // &quot;beep&quot; console.log(typeof arrayFromString[0]) // String var arrayFromNumber = genericFunc(42); console.log(arrayFromNumber[0]); // 42 console.log(typeof arrayFromNumber[0]) // number 带泛型的函数类型 let f: () =&gt; any = function() {} let f: &lt;T&gt;(arg: T) =&gt; T = function() {} 带泛型的接口 interface Gen&lt;T&gt; { (arg: T) : T } function fn&lt;T&gt;(arg: T): T { return arg; } let id: Gen&lt;number&gt; = fn; Gen(2) 带泛型的类 class Gen&lt;T&gt; { value: T add: (x: T, y: T) =&gt; T } let myGenNum = new Gen&lt;number&gt;() myGenNum.value = 0 myGenNum.add = (x, y) =&gt; x + y myGenNum.add(2,3) 泛型约束 interface Length { length: number } function fn&lt;T extends Length&gt;(arg: T): T { console.log(arg.length) return arg } fn&lt;string&gt;(&quot;hello&quot;) 官方文档介绍了更多关于泛型类，泛型类与接口绑定等例子generics 函数function add(x: number, y: number): number { return x + y; } let myAdd = function(x: number, y: number): number { return x+y; }; 箭头函数 // myAdd has the full function type let myAdd = function(x: number, y: number): number { return x + y; }; // The parameters &#39;x&#39; and &#39;y&#39; have the type number let myAdd: (baseValue:number, increment:number) =&gt; number = function(x, y) { return x + y; }; 参数可选 function buildName(firstName: string, lastName?: string) { // ... } 剩余参数 function buildName(firstName: string, ...restOfName: string[]) { return firstName + &quot;&quot; + restOfName.join(&quot; &quot;); } let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;); 官方文档 functions 高级类型 联合 function padLeft(value: string, padding: string | number) { // ... } let indentedString = padLeft(&quot;Hello world&quot;, true); // errors during compilation 官方文档 Advanced Types 模块化如：require.js （AMD 规范） exporter.ts var sayHi = function(): void { console.log(&quot;Hello!&quot;); } export = sayHi; importer.ts import sayHi = require(&#39;./exporter&#39;); sayHi(); 引入 require.js，查看官方文档 requirejs tsc --module amd *.ts 更多模块化的内容，可查看官方文档 modules 第三方声明文件声明文件用来是说明第三方 JavaScript 库是否和 TypeScript 兼容一个声明文件包含. d.ts 扩展名和关于该库的多种信息，还有 API 声明文件通常是手写的，但也可以用其他人写好的DefinitelyTyped The repository for high quality TypeScript type definitions也有一个用来管理 TypeScript 定义的 Node.js 流行模块，叫 Typings。 官方文档 introduction 参考资料 三十分钟学会 TypeScript: http://web.jobbole.com/87535/ 官方文档 : http://www.typescriptlang.org/docs/home.html 中文文档 : https://www.tslang.cn/index.html]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Koa 入门]]></title>
      <url>http://ldqblog.me/2017/08/10/Koa-%E5%85%A5%E9%97%A8/</url>
      <!-- <content type="html"><![CDATA[<h1 id="Koa-入门"><a href="#Koa-入门" class="headerlink" title="Koa 入门"></a>Koa 入门</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><blockquote>
<p>Node 版本必须 7.6 以上</p>
</blockquote>
<p>克隆代码库</p>
<blockquote>
<p>git clone <a href="https://github.com/ruanyf/koa-demos.git" target="_blank" rel="external">https://github.com/ruanyf/koa-demos.git</a></p>
</blockquote>
<h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><h3 id="1-开启-HTTP-服务器"><a href="#1-开启-HTTP-服务器" class="headerlink" title="1 开启 HTTP 服务器"></a>1 开启 HTTP 服务器</h3><pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

app.listen(3000);
</code></pre><h3 id="2-Context-对象"><a href="#2-Context-对象" class="headerlink" title="2 Context 对象"></a>2 Context 对象</h3><p>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
    ctx.response.body = &#39;Hello World&#39;;
};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-32b69cd94b58aced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>ctx.response 代表 HTTP Response<br>ctx.request 代表 HTTP Request</p>
<h3 id="3-response-类型"><a href="#3-response-类型" class="headerlink" title="3 response 类型"></a>3 response 类型</h3><p>Koa 默认的返回类型是 text/plain</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-cec6dc9a5a3d7674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>ctx.request.accepts 用来判断客户端希望接受什么数据<br>ctx.response.type 指定返回类型</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

if (ctx.request.accepts(&#39;xml&#39;)) {

    ctx.response.type = &#39;xml&#39;;

    ctx.response.body = &#39;&lt;data&gt;Hello World&lt;/data&gt;&#39;;

} else if (ctx.request.accepts(&#39;json&#39;)) {

    ctx.response.type = &#39;json&#39;;

    ctx.response.body = { data: &#39;Hello World&#39; };

} else if (ctx.request.accepts(&#39;html&#39;)) {

    ctx.response.type = &#39;html&#39;;

    ctx.response.body = &#39;&lt;p&gt;Hello World&lt;/p&gt;&#39;;

} else {

    ctx.response.type = &#39;text&#39;;

    ctx.response.body = &#39;Hello World&#39;;

}

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-83caa8dd754ae06e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-df6ccc66b21c55da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-0d84b50c0498d5dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-读取模板文件"><a href="#4-读取模板文件" class="headerlink" title="4 读取模板文件"></a>4 读取模板文件</h3><pre><code>const fs = require(&#39;fs&#39;);
const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

ctx.response.type = &#39;html&#39;;

ctx.response.body = fs.createReadStream(&#39;./demos/template.html&#39;);

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-6cfaa24a42e6277d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="二、路由"><a href="#二、路由" class="headerlink" title="二、路由"></a>二、路由</h2><h3 id="1-原生路由"><a href="#1-原生路由" class="headerlink" title="1 原生路由"></a>1 原生路由</h3><p>ctx.request.path<br>可获取用户请求的路径</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

if (ctx.request.path !== &#39;/&#39;) {

ctx.response.type = &#39;html&#39;;

ctx.response.body = &#39;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&#39;;

} else {

        ctx.response.body = &#39;Hello World&#39;;

}

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-efda28165ef1c82e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-6e9b906b2762e116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-koa-router"><a href="#2-koa-router" class="headerlink" title="2 koa-router"></a>2 koa-router</h3><p>route.get(path, callback)<br>callback 指定 ctx.response.type 和 ctx,response.body</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const route = require(&#39;koa-route&#39;);
const app = new Koa();

const about = ctx =&gt; {

ctx.response.type = &#39;html&#39;;

ctx.response.body = &#39;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&#39;;

};

const main = ctx =&gt; {
        ctx.response.body = &#39;Hello World&#39;;
};

app.use(route.get(&#39;/&#39;, main));
app.use(route.get(&#39;/about&#39;, about));

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-6ba08211d1b585a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-ae9d621c3e1b02a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-6e274232aaba6562.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-52627f567dc12140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="3-静态资源"><a href="#3-静态资源" class="headerlink" title="3 静态资源"></a>3 静态资源</h3><p>koa-static 处理静态资源</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();
const path = require(&#39;path&#39;);
const serve = require(&#39;koa-static&#39;);

const main = serve(path.join(__dirname));

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-51fc1d1d22dd591b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-c10a8f130e9bef9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-32fb0ac20d841137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-302-重定向"><a href="#4-302-重定向" class="headerlink" title="4 302 重定向"></a>4 302 重定向</h3><p>ctx.response.redirect()</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const route = require(&#39;koa-route&#39;);
const app = new Koa();

const redirect = ctx =&gt; {
    ctx.response.redirect(&#39;/&#39;);
};

const main = ctx =&gt; {
    ctx.response.body = &#39;Hello World&#39;;
};

app.use(route.get(&#39;/&#39;, main));
app.use(route.get(&#39;/redirect&#39;, redirect));

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-d49041f899983618.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="三、-中间件"><a href="#三、-中间件" class="headerlink" title="三、 中间件"></a>三、 中间件</h2><h3 id="1-logger"><a href="#1-logger" class="headerlink" title="1 logger"></a>1 logger</h3><p>打印日志</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {

console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);

ctx.response.body = &#39;Hello World&#39;;

};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-e3ba60c3e0d8d612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-中间件的概念"><a href="#2-中间件的概念" class="headerlink" title="2 中间件的概念"></a>2 中间件的概念</h3><p>logger 函数就叫做 “中间件”（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use() 用来加载中间件。</p>
<p>基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的 main 也是中间件。<br>参数 context 对象， next 函数 （将执行权限交给下一个中间件）</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const logger = (ctx, next) =&gt; {

console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);

next();

}

const main = ctx =&gt; {
ctx.response.body = &#39;Hello World&#39;;
};

app.use(logger);
app.use(main);
app.listen(3000);
</code></pre><h3 id="3-中间件栈"><a href="#3-中间件栈" class="headerlink" title="3 中间件栈"></a>3 中间件栈</h3><p>多个中间件会形成一个栈结构（middle stack），以 “先进后出”（first-in-last-out）的顺序执行。</p>
<blockquote>
<ol>
<li>最外层的中间件首先执行。</li>
<li>调用 next 函数，把执行权交给下一个中间件。    </li>
<li>…  </li>
<li>最内层的中间件最后执行。  </li>
<li>执行结束后，把执行权交回上一层的中间件。  </li>
<li>…  </li>
<li>最外层的中间件收回执行权之后，执行 next 函数后面的代码。  </li>
</ol>
</blockquote>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const one = (ctx, next) =&gt; {

console.log(&#39;&gt;&gt; one&#39;);

next();

console.log(&#39;&lt;&lt; one&#39;);

}

const two = (ctx, next) =&gt; {

console.log(&#39;&gt;&gt; two&#39;);

next();

console.log(&#39;&lt;&lt; two&#39;);

}

const three = (ctx, next) =&gt; {

console.log(&#39;&gt;&gt; three&#39;);

next();

console.log(&#39;&lt;&lt; three&#39;);

}

app.use(one);
app.use(two);
app.use(three);

app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-578836fa12375529.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果没有 next，中间件就不会往内层的中间件执行 而会返回外层中间件</p>
<p>把 two 的 next 注释掉</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-5f85230c6e1857aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-异步中间件"><a href="#4-异步中间件" class="headerlink" title="4 异步中间件"></a>4 异步中间件</h3><pre><code>const fs = require(&#39;fs.promised&#39;);
const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = async function (ctx, next) {
ctx.response.type = &#39;html&#39;;
ctx.response.body = await fs.readFile(&#39;./demos/template.html&#39;, &#39;utf8&#39;);
};

app.use(main);
app.listen(3000);
</code></pre><p>async await 处理异步</p>
<h3 id="5-中间件的合成"><a href="#5-中间件的合成" class="headerlink" title="5 中间件的合成"></a>5 中间件的合成</h3><p>koa-compose 将多个中间件合并成一个</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const compose = require(&#39;koa-compose&#39;);
const app = new Koa();

const logger = (ctx, next) =&gt; {

console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);

next();

}

const main = ctx =&gt; {
    ctx.response.body = &#39;Hello World&#39;;
};

const middlewares = compose([logger, main]);

app.use(middlewares);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-022a1b9a9ed7ab00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-a2cebd71f3c7e6ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="四、错误处理"><a href="#四、错误处理" class="headerlink" title="四、错误处理"></a>四、错误处理</h2><h3 id="500-错误"><a href="#500-错误" class="headerlink" title="500 错误"></a>500 错误</h3><p>500 状态码 —— 代码运行错误</p>
<p>ctx.throw 抛出错误</p>
<p>ctx.throw(500) 抛出 500 错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
  ctx.throw(500);
};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-a8b4b900929fc3d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-5735b99604f5fe9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-759028ee17851586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-20eff4f2acbc2499.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-404-错误"><a href="#2-404-错误" class="headerlink" title="2 404 错误"></a>2 404 错误</h3><p>ctx.response.status = 404 相当于 ctx.throw(404) 返回 404 错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
  ctx.response.status = 404;
  ctx.response.body = &#39;Page Not Found&#39;;
};

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-efbe181b5321d060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-feb318b8207c51a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="3-处理错误的中间件"><a href="#3-处理错误的中间件" class="headerlink" title="3 处理错误的中间件"></a>3 处理错误的中间件</h3><p>让最外层中间件负责处理所有中间件的错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const handler = async (ctx, next) =&gt; {
  try {
    await next();
  } catch (err) {
    ctx.response.status = err.statusCode || err.status || 500;
    ctx.response.body = {
      message: err.message
    };
  }
};

const main = ctx =&gt; {
  ctx.throw(500);
};

app.use(handler);
app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-b6a9a47929347e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1e9ed4f3b201c457.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="4-error-事件的监听"><a href="#4-error-事件的监听" class="headerlink" title="4 error 事件的监听"></a>4 error 事件的监听</h3><p>监听 error 事件也可以处理错误</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = ctx =&gt; {
  ctx.throw(500);
};

app.on(&#39;error&#39;, (err, ctx) =&gt; {
  console.error(&#39;server error&#39;, err);
});

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-5a622ff8b674cb25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-f0dd9f99ad67697b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="5-释放-error-事件"><a href="#5-释放-error-事件" class="headerlink" title="5 释放 error 事件"></a>5 释放 error 事件</h3><p>被 try … catch 捕获的错误不会触发 error 事件</p>
<p>要调用 ctx.app.emit(), 手动释放 error 事件</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const handler = async (ctx, next) =&gt; {
  try {
    await next();
  } catch (err) {
    ctx.response.status = err.statusCode || err.status || 500;
    ctx.response.type = &#39;html&#39;;
    ctx.response.body = &#39;&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;&#39;;
    ctx.app.emit(&#39;error&#39;, err, ctx);
  }
};

const main = ctx =&gt; {
  ctx.throw(500);
};

app.on(&#39;error&#39;, function(err) {
  console.log(&#39;logging error&#39;, err.message);
  console.log(err);
});

app.use(handler);
app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-7d43b2ac6e8bbf7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-506388f40095a28d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-ace175d9f131f842.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="五、Web-App-的功能"><a href="#五、Web-App-的功能" class="headerlink" title="五、Web App 的功能"></a>五、Web App 的功能</h2><h3 id="1-Cookies"><a href="#1-Cookies" class="headerlink" title="1 Cookies"></a>1 Cookies</h3><p>ctx.cookies 读写 Cookie<br>ctx.cookies.get() 获得 Cookie<br>ctx.cookies.set() 设置 Cookie</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const app = new Koa();

const main = function(ctx) {
  const n = Number(ctx.cookies.get(&#39;view&#39;) || 0) + 1;
  ctx.cookies.set(&#39;view&#39;, n);
  ctx.response.body = n + &#39;views&#39;;
}

app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-36da76974f1f7466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1dd21f5fa547ce7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-6878538e8bc07385.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>每刷新一次就会跟增加一次</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-f291e8cb41e4a452.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-fbbf9a5527cfc00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1f41e0f27dbcf93f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="2-表单"><a href="#2-表单" class="headerlink" title="2 表单"></a>2 表单</h3><p>Web 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。</p>
<p>koa-body 用来从 POST 请求体中提取键值对</p>
<pre><code>const Koa = require(&#39;koa&#39;);
const koaBody = require(&#39;koa-body&#39;);
const app = new Koa();

const main = async function(ctx) {
  const body = ctx.request.body;
  if (!body.name) ctx.throw(400, &#39;.name required&#39;);
  ctx.body = { name: body.name };
};

app.use(koaBody());
app.use(main);
app.listen(3000);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-b1b4ea7178e40045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-5a56b2cd0f4e2c0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>POST 方法向服务器发送一个键值对，会被正确解析。如果发送的数据不正确，就会收到错误提示。</p>
<p>打开新的命令行窗口</p>
<p>输入</p>
<p>curl -X POST –data “name=Jack” localhost:3000</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-1f6bd2a2ae6af739.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>curl -X POST –data “name” localhost:3000</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-bdee1f7139fdeb35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="3-文件上传"><a href="#3-文件上传" class="headerlink" title="3 文件上传"></a>3 文件上传</h3><p>koa-body 处理文件上传</p>
<pre><code>const os = require(&#39;os&#39;);
const path = require(&#39;path&#39;);
const Koa = require(&#39;koa&#39;);
const fs = require(&#39;fs&#39;);
const koaBody = require(&#39;koa-body&#39;);

const app = new Koa();

const main = async function(ctx) {
  const tmpdir = os.tmpdir();
  const filePaths = [];
  const files = ctx.request.body.files || {};

  for (let key in files) {
    const file = files[key];
    const filePath = path.join(tmpdir, file.name);
    console.log(filePath)
    const reader = fs.createReadStream(file.path);
    const writer = fs.createWriteStream(filePath);
    reader.pipe(writer);
    filePaths.push(filePath);
  }

  ctx.body = filePaths;
};

app.use(koaBody({ multipart: true }));
app.use(main);
app.listen(3000);
</code></pre><p>在新的命令行窗口输入</p>
<p>curl –form upload=@/path/to/file <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a></p>
<p>/path/to/file 替换成真实路径</p>
<p>curl –form upload=@/D:/Nodejs/other/koa-demos/demos/21.js <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3563580-7c57a9a9333dccf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">   </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Koa 框架教程 by 阮一峰 </strong>：<a href="http://www.ruanyifeng.com/blog/2017/08/koa.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2017/08/koa.html</a></p>
]]></content> -->
      <content type="html"><![CDATA[Koa 入门准备 Node 版本必须 7.6 以上 克隆代码库 git clone https://github.com/ruanyf/koa-demos.git 一、基本用法1 开启 HTTP 服务器const Koa = require(&#39;koa&#39;); const app = new Koa(); app.listen(3000); 2 Context 对象Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。 const Koa = require(&#39;koa&#39;); const app = new Koa(); const main = ctx =&gt; { ctx.response.body = &#39;Hello World&#39;; }; app.use(main); app.listen(3000); ctx.response 代表 HTTP Responsectx.request 代表 HTTP Request 3 response 类型Koa 默认的返回类型是 text/plain ctx.request.accepts 用来判断客户端希望接受什么数据ctx.response.type 指定返回类型 const Koa = require(&#39;koa&#39;); const app = new Koa(); const main = ctx =&gt; { if (ctx.request.accepts(&#39;xml&#39;)) { ctx.response.type = &#39;xml&#39;; ctx.response.body = &#39;&lt;data&gt;Hello World&lt;/data&gt;&#39;; } else if (ctx.request.accepts(&#39;json&#39;)) { ctx.response.type = &#39;json&#39;; ctx.response.body = { data: &#39;Hello World&#39; }; } else if (ctx.request.accepts(&#39;html&#39;)) { ctx.response.type = &#39;html&#39;; ctx.response.body = &#39;&lt;p&gt;Hello World&lt;/p&gt;&#39;; } else { ctx.response.type = &#39;text&#39;; ctx.response.body = &#39;Hello World&#39;; } }; app.use(main); app.listen(3000); 4 读取模板文件const fs = require(&#39;fs&#39;); const Koa = require(&#39;koa&#39;); const app = new Koa(); const main = ctx =&gt; { ctx.response.type = &#39;html&#39;; ctx.response.body = fs.createReadStream(&#39;./demos/template.html&#39;); }; app.use(main); app.listen(3000); 二、路由1 原生路由ctx.request.path可获取用户请求的路径 const Koa = require(&#39;koa&#39;); const app = new Koa(); const main = ctx =&gt; { if (ctx.request.path !== &#39;/&#39;) { ctx.response.type = &#39;html&#39;; ctx.response.body = &#39;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&#39;; } else { ctx.response.body = &#39;Hello World&#39;; } }; app.use(main); app.listen(3000); 2 koa-routerroute.get(path, callback)callback 指定 ctx.response.type 和 ctx,response.body const Koa = require(&#39;koa&#39;); const route = require(&#39;koa-route&#39;); const app = new Koa(); const about = ctx =&gt; { ctx.response.type = &#39;html&#39;; ctx.response.body = &#39;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&#39;; }; const main = ctx =&gt; { ctx.response.body = &#39;Hello World&#39;; }; app.use(route.get(&#39;/&#39;, main)); app.use(route.get(&#39;/about&#39;, about)); app.use(main); app.listen(3000); 3 静态资源koa-static 处理静态资源 const Koa = require(&#39;koa&#39;); const app = new Koa(); const path = require(&#39;path&#39;); const serve = require(&#39;koa-static&#39;); const main = serve(path.join(__dirname)); app.use(main); app.listen(3000); 4 302 重定向ctx.response.redirect() const Koa = require(&#39;koa&#39;); const route = require(&#39;koa-route&#39;); const app = new Koa(); const redirect = ctx =&gt; { ctx.response.redirect(&#39;/&#39;); }; const main = ctx =&gt; { ctx.response.body = &#39;Hello World&#39;; }; app.use(route.get(&#39;/&#39;, main)); app.use(route.get(&#39;/redirect&#39;, redirect)); app.use(main); app.listen(3000); 三、 中间件1 logger打印日志 const Koa = require(&#39;koa&#39;); const app = new Koa(); const main = ctx =&gt; { console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`); ctx.response.body = &#39;Hello World&#39;; }; app.use(main); app.listen(3000); 2 中间件的概念logger 函数就叫做 “中间件”（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use() 用来加载中间件。 基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的 main 也是中间件。参数 context 对象， next 函数 （将执行权限交给下一个中间件） const Koa = require(&#39;koa&#39;); const app = new Koa(); const logger = (ctx, next) =&gt; { console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`); next(); } const main = ctx =&gt; { ctx.response.body = &#39;Hello World&#39;; }; app.use(logger); app.use(main); app.listen(3000); 3 中间件栈多个中间件会形成一个栈结构（middle stack），以 “先进后出”（first-in-last-out）的顺序执行。 最外层的中间件首先执行。 调用 next 函数，把执行权交给下一个中间件。 … 最内层的中间件最后执行。 执行结束后，把执行权交回上一层的中间件。 … 最外层的中间件收回执行权之后，执行 next 函数后面的代码。 const Koa = require(&#39;koa&#39;); const app = new Koa(); const one = (ctx, next) =&gt; { console.log(&#39;&gt;&gt; one&#39;); next(); console.log(&#39;&lt;&lt; one&#39;); } const two = (ctx, next) =&gt; { console.log(&#39;&gt;&gt; two&#39;); next(); console.log(&#39;&lt;&lt; two&#39;); } const three = (ctx, next) =&gt; { console.log(&#39;&gt;&gt; three&#39;); next(); console.log(&#39;&lt;&lt; three&#39;); } app.use(one); app.use(two); app.use(three); app.listen(3000); 如果没有 next，中间件就不会往内层的中间件执行 而会返回外层中间件 把 two 的 next 注释掉 4 异步中间件const fs = require(&#39;fs.promised&#39;); const Koa = require(&#39;koa&#39;); const app = new Koa(); const main = async function (ctx, next) { ctx.response.type = &#39;html&#39;; ctx.response.body = await fs.readFile(&#39;./demos/template.html&#39;, &#39;utf8&#39;); }; app.use(main); app.listen(3000); async await 处理异步 5 中间件的合成koa-compose 将多个中间件合并成一个 const Koa = require(&#39;koa&#39;); const compose = require(&#39;koa-compose&#39;); const app = new Koa(); const logger = (ctx, next) =&gt; { console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`); next(); } const main = ctx =&gt; { ctx.response.body = &#39;Hello World&#39;; }; const middlewares = compose([logger, main]); app.use(middlewares); app.listen(3000); 四、错误处理500 错误500 状态码 —— 代码运行错误 ctx.throw 抛出错误 ctx.throw(500) 抛出 500 错误 const Koa = require(&#39;koa&#39;); const app = new Koa(); const main = ctx =&gt; { ctx.throw(500); }; app.use(main); app.listen(3000); 2 404 错误ctx.response.status = 404 相当于 ctx.throw(404) 返回 404 错误 const Koa = require(&#39;koa&#39;); const app = new Koa(); const main = ctx =&gt; { ctx.response.status = 404; ctx.response.body = &#39;Page Not Found&#39;; }; app.use(main); app.listen(3000); 3 处理错误的中间件让最外层中间件负责处理所有中间件的错误 const Koa = require(&#39;koa&#39;); const app = new Koa(); const handler = async (ctx, next) =&gt; { try { await next(); } catch (err) { ctx.response.status = err.statusCode || err.status || 500; ctx.response.body = { message: err.message }; } }; const main = ctx =&gt; { ctx.throw(500); }; app.use(handler); app.use(main); app.listen(3000); 4 error 事件的监听监听 error 事件也可以处理错误 const Koa = require(&#39;koa&#39;); const app = new Koa(); const main = ctx =&gt; { ctx.throw(500); }; app.on(&#39;error&#39;, (err, ctx) =&gt; { console.error(&#39;server error&#39;, err); }); app.use(main); app.listen(3000); 5 释放 error 事件被 try … catch 捕获的错误不会触发 error 事件 要调用 ctx.app.emit(), 手动释放 error 事件 const Koa = require(&#39;koa&#39;); const app = new Koa(); const handler = async (ctx, next) =&gt; { try { await next(); } catch (err) { ctx.response.status = err.statusCode || err.status || 500; ctx.response.type = &#39;html&#39;; ctx.response.body = &#39;&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;&#39;; ctx.app.emit(&#39;error&#39;, err, ctx); } }; const main = ctx =&gt; { ctx.throw(500); }; app.on(&#39;error&#39;, function(err) { console.log(&#39;logging error&#39;, err.message); console.log(err); }); app.use(handler); app.use(main); app.listen(3000); 五、Web App 的功能1 Cookiesctx.cookies 读写 Cookiectx.cookies.get() 获得 Cookiectx.cookies.set() 设置 Cookie const Koa = require(&#39;koa&#39;); const app = new Koa(); const main = function(ctx) { const n = Number(ctx.cookies.get(&#39;view&#39;) || 0) + 1; ctx.cookies.set(&#39;view&#39;, n); ctx.response.body = n + &#39;views&#39;; } app.use(main); app.listen(3000); 每刷新一次就会跟增加一次 2 表单Web 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。 koa-body 用来从 POST 请求体中提取键值对 const Koa = require(&#39;koa&#39;); const koaBody = require(&#39;koa-body&#39;); const app = new Koa(); const main = async function(ctx) { const body = ctx.request.body; if (!body.name) ctx.throw(400, &#39;.name required&#39;); ctx.body = { name: body.name }; }; app.use(koaBody()); app.use(main); app.listen(3000); POST 方法向服务器发送一个键值对，会被正确解析。如果发送的数据不正确，就会收到错误提示。 打开新的命令行窗口 输入 curl -X POST –data “name=Jack” localhost:3000 curl -X POST –data “name” localhost:3000 3 文件上传koa-body 处理文件上传 const os = require(&#39;os&#39;); const path = require(&#39;path&#39;); const Koa = require(&#39;koa&#39;); const fs = require(&#39;fs&#39;); const koaBody = require(&#39;koa-body&#39;); const app = new Koa(); const main = async function(ctx) { const tmpdir = os.tmpdir(); const filePaths = []; const files = ctx.request.body.files || {}; for (let key in files) { const file = files[key]; const filePath = path.join(tmpdir, file.name); console.log(filePath) const reader = fs.createReadStream(file.path); const writer = fs.createWriteStream(filePath); reader.pipe(writer); filePaths.push(filePath); } ctx.body = filePaths; }; app.use(koaBody({ multipart: true })); app.use(main); app.listen(3000); 在新的命令行窗口输入 curl –form upload=@/path/to/file http://localhost:3000 /path/to/file 替换成真实路径 curl –form upload=@/D:/Nodejs/other/koa-demos/demos/21.js http://localhost:3000 参考资料Koa 框架教程 by 阮一峰 ：http://www.ruanyifeng.com/blog/2017/08/koa.html]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[music video test]]></title>
      <url>http://ldqblog.me/2017/07/31/music-video-test/</url>
      <!-- <content type="html"><![CDATA[<h3 id="歌曲"><a href="#歌曲" class="headerlink" title="歌曲"></a>歌曲</h3><div class="aplayer" data-id="31673404" data-server="netease" data-type="song"></div>

<h3 id="歌单"><a href="#歌单" class="headerlink" title="歌单"></a>歌单</h3><div class="aplayer" data-id="11100236" data-server="netease" data-type="playlist" data-mode="random"></div>

<h3 id="b-站视频"><a href="#b-站视频" class="headerlink" title="b 站视频"></a>b 站视频</h3><iframe class="bilibiliVideo" src="https://www.bilibili.com/html/html5player.html?cid=5090828&aid=3227348" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

]]></content> -->
      <content type="html"><![CDATA[歌曲 歌单 b 站视频]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Redux 简介]]></title>
      <url>http://ldqblog.me/2017/07/23/Redux-%E7%AE%80%E4%BB%8B/</url>
      <!-- <content type="html"><![CDATA[<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code>
redux react-redux

const 文件
action 
aciton creator
reducer
store
state
dispatch
combineReducers

connect
mapStateToProps
mapDispatchToProps
middleware
</code></pre><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><pre><code>保存数据的一个单一状态树
</code></pre><p>要通过 createStore 方法生成    </p>
<pre><code>import {createStore} from &#39;redux&#39;
const store = createStore(fn)
</code></pre><h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>  Action 是一个对象。其中的 type 属性是必须的，表示 Action 的名称。<br>  其他属性可以自由设置。</p>
<pre><code>  const action = {
    type: &#39;ADD_TODO&#39;,
    payload: &#39;Learn Redux&#39;
  }
</code></pre><h2 id="action-creator"><a href="#action-creator" class="headerlink" title="action creator"></a>action creator</h2><pre><code>每次手写 action 很麻烦，于是要定义一个函数来生成 action，该函数就是
action creator
</code></pre><pre><code>const chooseNav = (index) =&gt; {
    return {
        type: CHOOSE_NAV,
        index
    }
}

const action = chooseNav(1)
</code></pre><h2 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch"></a>store.dispatch</h2><p>  要触发 action，就要使用 store.dispatch</p>
<pre><code>import { createStore } from &#39;redux&#39;;
const store = createStore(fn)

store.dispatch({
  type: &#39;ADD_TODO&#39;,
  payload: &#39;Learn Redux&#39;
})
</code></pre><h2 id="const-文件"><a href="#const-文件" class="headerlink" title="const 文件"></a>const 文件</h2><p>  将 action.type 定义为常量<br>  reducer 通过 action.type 判断是哪个 action</p>
<h2 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h2><p>  更新数据， 返回新的 state</p>
<pre><code>const initState = {

}

const reducer = (state = initState, action) =&gt; {
    switch(action.type) {
        case xxx:
            xxx
            break
        case yyy:
            yyy
            break
        default 
           return state 

    }
}
</code></pre><h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><pre><code>合并多个 reducer
</code></pre><pre><code>import { combineReducers } from &#39;redux&#39;


const chatReducer = combineReducers({
  chatLog,
  statusMessage,
  userName
})

export default chatReducer
</code></pre><h2 id="创建-stroe"><a href="#创建-stroe" class="headerlink" title="创建 stroe"></a>创建 stroe</h2><pre><code>import chatReducer from &#39;./xxx&#39;


const store = createStore(
    chatReducer
)

export default store
</code></pre><h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>   store 添加在 Provider 组件</p>
<pre><code>import store from &#39;./yyy&#39;
import {Provider} from &#39;react-redux&#39;



ReactDOM.render(
    &lt; Provider store={store} &gt;
       ...
    &lt; /Provider &gt;, 
document.getElementById(&#39;root&#39;))
</code></pre><h2 id="在组件中使用"><a href="#在组件中使用" class="headerlink" title="在组件中使用"></a>在组件中使用</h2><pre><code> mapStateToProps 传 props 给组件
 mapDispatchToProps 传 dispatch 方法 给组件
 通过 connect 传个组件 
</code></pre><p>例子</p>
<pre><code>import React, { Component } from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;
import CommentList from &#39;../components/CommentList.js&#39;
import { initComments, deleteComment} from &#39;../reducers/comments.js&#39;
import {connect} from &#39;react-redux&#39;



class CommentListContainer extends Component {
    static propTypes = {
        comments: PropTypes.array,
        initComments: PropTypes.func,
        deleteComment: PropTypes.func
    }

    componentWillMount() {
        this._loadComments()
    }

    _loadComments() {
        let comments = localStorage.getItem(&#39;comments&#39;)
        comments = comments ? JSON.parse(comments) : []
        this.props.initComments(comments)
    }

    handleDeleteComment(index) {
        const {comments} = this.props
        const newComments = [
            ...comments.slice(0, index),
            ...comments.slice(index + 1)
        ]
        localStorage.setItem(&#39;comments&#39;, JSON.stringify(newComments))
        if(this.props.onDeleteComment) {
            this.props.onDeleteComment(index)
        }
    }

    render() {
        return (
            &lt; CommentList 
                comments = {this.props.comments}
                onDeleteComment={this.handleDeleteComment.bind(this)}
            / &gt;
        )
    }
}

// 评论列表从 state.comments 中获取
const mapStateToProps = state =&gt; {
    return {
        comments: state.comments
    }
}

const mapDispatchToProps = dispatch =&gt; {
    return {
        // 提供给 CommentListContainer
        // 当从 LocalStorage 加载评论列表以后就会通过这个方法
        // 把评论列表初始化到 state 当中
        initComments: (comments) =&gt; {
            dispatch(initComments(comments))
        } ,
        // 删除评论
        onDeleteComment: (commentIndex) =&gt; {
            dispatch(deleteComment(commentIndex))
        }
    }
}


// 将 CommentListContainer connect 到 store
// 会把 comments、initComments、onDeleteComment 传给 CommentListContainer

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(CommentListContainer)
</code></pre><h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><p>   强化 redux 的功能</p>
<p>原理<br>   改写 store.dispatch </p>
<p>因为 reducer 是纯函数，只承担计算 State 的功能，不合适承担其他功能<br>View 与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。<br>Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</p>
<p>compose<br>  从右到左来组合多个函数。</p>
<p>这是函数式编程中的方法，为了方便，被放到了 Redux 里。<br>当需要把多个 store 增强器 依次执行的时候，需要用到它。</p>
<p>例子</p>
<pre><code>import {createStore, applyMiddleware, compose} from &#39;redux&#39;
import reducers from &#39;./reducers.js&#39;
import thunkMiddleware  from &#39;redux-thunk&#39;
import createLogger from &#39;redux-logger&#39;



export default () =&gt; {
    const middleware = [thunkMiddleware, createLogger]


    const composeEnhancers = 
        process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;
            typeof window === &#39;object&#39; &amp;&amp;
            window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ 
            ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
                // Specify extension’s options like name, actionsBlacklist, actionsCreators, serialize...
                }) 
            : compose

    const enhancers =  composeEnhancers(
        applyMiddleware(...middleware)
    )

    const store = createStore(
        reducers,
        enhancers
    )

    return store
}
</code></pre><h3 id="处理异步"><a href="#处理异步" class="headerlink" title="处理异步"></a>处理异步</h3><pre><code>

redux-think + async/await
    redux-think 让 dispatch 能接受 函数作为参数 （原来参数只能是对象）
    利用 async/await 的调用方式处理异步

redux-promise
    利用 promise 的调用方式处理异步


redux-promise-middleware
    优化 redux-promise


redux-saga (generator/yield)
     利用 generator/yield 的调用方式处理异步
     提供大量的 api


redux-observable (RxJS)
     利用 RxJS 的调用方式处理异步
     提供大量的 api


redux-loop
</code></pre><h3 id="其他中间件"><a href="#其他中间件" class="headerlink" title="其他中间件"></a>其他中间件</h3><pre><code>
redux-logger
</code></pre><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p><a href="https://github.com/sorrycc/blog/issues/1" target="_blank" rel="external">看看 dva 的前身 React + Redux 最佳实践，知道 dva 是怎么来的</a></p>
<h3 id="优秀的相关框架"><a href="#优秀的相关框架" class="headerlink" title="优秀的相关框架"></a>优秀的相关框架</h3><p><a href="https://github.com/dvajs/dva" target="_blank" rel="external">dva</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong> 理解 React</strong>: <a href="https://www.zhihu.com/question/41312576?sort=created" target="_blank" rel="external">https://www.zhihu.com/question/41312576?sort=created</a><br><strong>Redux 入门教程（一）—— 阮一峰 </strong>: <a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</a></p>
]]></content> -->
      <content type="html"><![CDATA[Redux概念 redux react-redux const 文件 action aciton creator reducer store state dispatch combineReducers connect mapStateToProps mapDispatchToProps middleware store保存数据的一个单一状态树 要通过 createStore 方法生成 import {createStore} from &#39;redux&#39; const store = createStore(fn) action Action 是一个对象。其中的 type 属性是必须的，表示 Action 的名称。 其他属性可以自由设置。 const action = { type: &#39;ADD_TODO&#39;, payload: &#39;Learn Redux&#39; } action creator每次手写 action 很麻烦，于是要定义一个函数来生成 action，该函数就是 action creator const chooseNav = (index) =&gt; { return { type: CHOOSE_NAV, index } } const action = chooseNav(1) store.dispatch 要触发 action，就要使用 store.dispatch import { createStore } from &#39;redux&#39;; const store = createStore(fn) store.dispatch({ type: &#39;ADD_TODO&#39;, payload: &#39;Learn Redux&#39; }) const 文件 将 action.type 定义为常量 reducer 通过 action.type 判断是哪个 action reducer 更新数据， 返回新的 state const initState = { } const reducer = (state = initState, action) =&gt; { switch(action.type) { case xxx: xxx break case yyy: yyy break default return state } } combineReducers合并多个 reducer import { combineReducers } from &#39;redux&#39; const chatReducer = combineReducers({ chatLog, statusMessage, userName }) export default chatReducer 创建 stroeimport chatReducer from &#39;./xxx&#39; const store = createStore( chatReducer ) export default store Provider store 添加在 Provider 组件 import store from &#39;./yyy&#39; import {Provider} from &#39;react-redux&#39; ReactDOM.render( &lt; Provider store={store} &gt; ... &lt; /Provider &gt;, document.getElementById(&#39;root&#39;)) 在组件中使用 mapStateToProps 传 props 给组件 mapDispatchToProps 传 dispatch 方法 给组件 通过 connect 传个组件 例子 import React, { Component } from &#39;react&#39; import PropTypes from &#39;prop-types&#39; import CommentList from &#39;../components/CommentList.js&#39; import { initComments, deleteComment} from &#39;../reducers/comments.js&#39; import {connect} from &#39;react-redux&#39; class CommentListContainer extends Component { static propTypes = { comments: PropTypes.array, initComments: PropTypes.func, deleteComment: PropTypes.func } componentWillMount() { this._loadComments() } _loadComments() { let comments = localStorage.getItem(&#39;comments&#39;) comments = comments ? JSON.parse(comments) : [] this.props.initComments(comments) } handleDeleteComment(index) { const {comments} = this.props const newComments = [ ...comments.slice(0, index), ...comments.slice(index + 1) ] localStorage.setItem(&#39;comments&#39;, JSON.stringify(newComments)) if(this.props.onDeleteComment) { this.props.onDeleteComment(index) } } render() { return ( &lt; CommentList comments = {this.props.comments} onDeleteComment={this.handleDeleteComment.bind(this)} / &gt; ) } } // 评论列表从 state.comments 中获取 const mapStateToProps = state =&gt; { return { comments: state.comments } } const mapDispatchToProps = dispatch =&gt; { return { // 提供给 CommentListContainer // 当从 LocalStorage 加载评论列表以后就会通过这个方法 // 把评论列表初始化到 state 当中 initComments: (comments) =&gt; { dispatch(initComments(comments)) } , // 删除评论 onDeleteComment: (commentIndex) =&gt; { dispatch(deleteComment(commentIndex)) } } } // 将 CommentListContainer connect 到 store // 会把 comments、initComments、onDeleteComment 传给 CommentListContainer export default connect( mapStateToProps, mapDispatchToProps )(CommentListContainer) middleware 强化 redux 的功能 原理 改写 store.dispatch 因为 reducer 是纯函数，只承担计算 State 的功能，不合适承担其他功能View 与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。 compose 从右到左来组合多个函数。 这是函数式编程中的方法，为了方便，被放到了 Redux 里。当需要把多个 store 增强器 依次执行的时候，需要用到它。 例子 import {createStore, applyMiddleware, compose} from &#39;redux&#39; import reducers from &#39;./reducers.js&#39; import thunkMiddleware from &#39;redux-thunk&#39; import createLogger from &#39;redux-logger&#39; export default () =&gt; { const middleware = [thunkMiddleware, createLogger] const composeEnhancers = process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; typeof window === &#39;object&#39; &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({ // Specify extension’s options like name, actionsBlacklist, actionsCreators, serialize... }) : compose const enhancers = composeEnhancers( applyMiddleware(...middleware) ) const store = createStore( reducers, enhancers ) return store } 处理异步 redux-think + async/await redux-think 让 dispatch 能接受 函数作为参数 （原来参数只能是对象） 利用 async/await 的调用方式处理异步 redux-promise 利用 promise 的调用方式处理异步 redux-promise-middleware 优化 redux-promise redux-saga (generator/yield) 利用 generator/yield 的调用方式处理异步 提供大量的 api redux-observable (RxJS) 利用 RxJS 的调用方式处理异步 提供大量的 api redux-loop 其他中间件 redux-logger 最佳实践看看 dva 的前身 React + Redux 最佳实践，知道 dva 是怎么来的 优秀的相关框架dva 参考资料 理解 React: https://www.zhihu.com/question/41312576?sort=createdRedux 入门教程（一）—— 阮一峰 : http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React-Router 简介]]></title>
      <url>http://ldqblog.me/2017/07/15/React-Router-%E7%AE%80%E4%BB%8B/</url>
      <!-- <content type="html"><![CDATA[<h1 id="React-Router"><a href="#React-Router" class="headerlink" title="React-Router"></a>React-Router</h1><p><a href="http://ldqblog.me/learn-react-router/build/">学习 React-Router 的例子</a></p>
<p><a href="https://github.com/LDQ-first/learn-react-router" target="_blank" rel="external">源码</a></p>
]]></content> -->
      <content type="html"><![CDATA[React-Router学习 React-Router 的例子 源码]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React 简介]]></title>
      <url>http://ldqblog.me/2017/07/13/React-%E7%AE%80%E4%BB%8B/</url>
      <!-- <content type="html"><![CDATA[<h1 id="React-简介"><a href="#React-简介" class="headerlink" title="React 简介"></a>React 简介</h1><blockquote>
<p>React.js 是一个 UI = f(states) 的框架，为了解决更新的问题，<br>React.js 使用了 virtual dom，virtual dom 通过 diff 修改 dom，来实现高效的 dom 更新。</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>一般写在 render 生命周期函数里</p>
<p>语法:</p>
<pre><code>return (
    写 HTML 

    注意 有些 属性要改写 
    如 ： class =》 className 

    标签要闭合 &lt; img src=&quot;&quot;&gt; =》 &lt; img src=&quot;&quot; /&gt; 

    可以添加 js
    但要用 {} 括起来 


)
</code></pre><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><pre><code>import React, { Component } from &#39;react&#39;

class NotFound extends Component {

    render () {

        return (


        )
    }
}
</code></pre><p>例子</p>
<pre><code>import React, { Component } from &#39;react&#39;


export default class NotFound extends Component {

    render() {

        return (
            &lt; Container className=&quot;noPadding&quot; &gt;
               &lt; NotFoundDiv &gt;
                   &lt; h1 className=&quot;title&quot; &gt;404&lt; /h1 &gt;
               &lt; /NotFoundDiv &gt;
            &lt; /Container &gt;
        )
    }
}
</code></pre><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>获取 dom 元素</p>
<pre><code>&lt; div className=&quot;contactContent&quot; 
    ref={contact =&gt; this._contact = contact} &gt;       
&lt; /div &gt;
</code></pre><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>数据</p>
<pre><code>constructor(props) {
    super(props) 
    this.state = {

    }
}
</code></pre><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>   更新 state </p>
<p>注意：</p>
<ol>
<li>setState 不会立刻改变 React 组件中 state 的值</li>
<li>函数式的 setState 用法</li>
</ol>
<p>看这篇文章<br>   <a href="https://zhuanlan.zhihu.com/p/25954470" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/25954470</a></p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>子组件接受父组件的数据</p>
<pre><code>const { _this } = this.props
</code></pre><h3 id="PropTypes"><a href="#PropTypes" class="headerlink" title="PropTypes"></a>PropTypes</h3><p>props 类型检查</p>
<pre><code>import PropTypes from &#39;prop-types&#39;


static get propTypes() {
    return {
        _this: PropTypes.object
    }
}
</code></pre><h4 id="classNames-第三方库"><a href="#classNames-第三方库" class="headerlink" title="classNames(第三方库)"></a>classNames(第三方库)</h4><p> 处理各类名</p>
<pre><code>import classNames from &#39;classnames&#39;

const { isSpread } = this.state

className={classNames(&#39;toggle&#39;, {active: isSpread})
</code></pre><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>事件<br>React 支持许多事件<br>官方文档有列出<br><a href="https://reactjs.org/docs/events.html#supported-events" target="_blank" rel="external">https://reactjs.org/docs/events.html#supported-events</a></p>
<pre><code>
&lt;a href=&quot;javascript:;&quot; className=&#39;toggle&#39;} 
onClick={() =&gt; { this._toggle() }}&gt;
    &lt;i className=&quot;bar&quot;&gt;&lt;/i&gt;
&lt;/a&gt;
</code></pre><h3 id="lists-key-map"><a href="#lists-key-map" class="headerlink" title="lists key map"></a>lists key map</h3><p>循环</p>
<pre><code>
const { navArr} = this.state

const navs = navArr.map((item, index) =&gt; {
    return (
        &lt;li key={index} className=&#39;nav&#39;} &gt;
            {item.name}
        &lt;/li&gt;
    )
})

&lt;ul className=&#39;navs&#39;&gt;
    {navs ? navs : null}
&lt;/ul&gt;
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>npm install -g create-react-app

create-react-app my-app
cd my-app/
npm start
</code></pre><p>浏览器自动打开 <a href="http://localhost:3000/" target="_blank" rel="external">http://localhost:3000/</a></p>
<p>写完</p>
<p>npm run build 构建打包</p>
<p>生成的 build 文件夹就是要发布的文件</p>
<h4 id="文件夹结构"><a href="#文件夹结构" class="headerlink" title="文件夹结构"></a>文件夹结构</h4><pre><code>
my-app
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── public
│   └── favicon.ico
│   └── index.html
│   └── manifest.json
└── src
    └── App.css
    └── App.js
    └── App.test.js
    └── index.css
    └── index.js
    └── logo.svg
    └── registerServiceWorker.js
</code></pre><p>在 src 中编写代码</p>
<p>也可以自己搭建一个脚手架</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>React 文档 </strong>: <a href="https://reactjs.org/" target="_blank" rel="external">https://reactjs.org/</a></p>
]]></content> -->
      <content type="html"><![CDATA[React 简介 React.js 是一个 UI = f(states) 的框架，为了解决更新的问题，React.js 使用了 virtual dom，virtual dom 通过 diff 修改 dom，来实现高效的 dom 更新。 概念JSX一般写在 render 生命周期函数里 语法: return ( 写 HTML 注意 有些 属性要改写 如 ： class =》 className 标签要闭合 &lt; img src=&quot;&quot;&gt; =》 &lt; img src=&quot;&quot; /&gt; 可以添加 js 但要用 {} 括起来 ) 组件import React, { Component } from &#39;react&#39; class NotFound extends Component { render () { return ( ) } } 例子 import React, { Component } from &#39;react&#39; export default class NotFound extends Component { render() { return ( &lt; Container className=&quot;noPadding&quot; &gt; &lt; NotFoundDiv &gt; &lt; h1 className=&quot;title&quot; &gt;404&lt; /h1 &gt; &lt; /NotFoundDiv &gt; &lt; /Container &gt; ) } } ref获取 dom 元素 &lt; div className=&quot;contactContent&quot; ref={contact =&gt; this._contact = contact} &gt; &lt; /div &gt; state数据 constructor(props) { super(props) this.state = { } } setState 更新 state 注意： setState 不会立刻改变 React 组件中 state 的值 函数式的 setState 用法 看这篇文章 https://zhuanlan.zhihu.com/p/25954470 props子组件接受父组件的数据 const { _this } = this.props PropTypesprops 类型检查 import PropTypes from &#39;prop-types&#39; static get propTypes() { return { _this: PropTypes.object } } classNames(第三方库) 处理各类名 import classNames from &#39;classnames&#39; const { isSpread } = this.state className={classNames(&#39;toggle&#39;, {active: isSpread}) event事件React 支持许多事件官方文档有列出https://reactjs.org/docs/events.html#supported-events &lt;a href=&quot;javascript:;&quot; className=&#39;toggle&#39;} onClick={() =&gt; { this._toggle() }}&gt; &lt;i className=&quot;bar&quot;&gt;&lt;/i&gt; &lt;/a&gt; lists key map循环 const { navArr} = this.state const navs = navArr.map((item, index) =&gt; { return ( &lt;li key={index} className=&#39;nav&#39;} &gt; {item.name} &lt;/li&gt; ) }) &lt;ul className=&#39;navs&#39;&gt; {navs ? navs : null} &lt;/ul&gt; 使用npm install -g create-react-app create-react-app my-app cd my-app/ npm start 浏览器自动打开 http://localhost:3000/ 写完 npm run build 构建打包 生成的 build 文件夹就是要发布的文件 文件夹结构 my-app ├── README.md ├── node_modules ├── package.json ├── .gitignore ├── public │ └── favicon.ico │ └── index.html │ └── manifest.json └── src └── App.css └── App.js └── App.test.js └── index.css └── index.js └── logo.svg └── registerServiceWorker.js 在 src 中编写代码 也可以自己搭建一个脚手架 参考资料React 文档 : https://reactjs.org/]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vue 生命周期]]></title>
      <url>http://ldqblog.me/2017/06/25/Vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <!-- <content type="html"><![CDATA[<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="生命周期钩子的函数"><a href="#生命周期钩子的函数" class="headerlink" title="生命周期钩子的函数"></a>生命周期钩子的函数</h3><p>实例化</p>
<p>beforeCreate<br>实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前</p>
<p>created<br>实例创建完成后</p>
<p>beforeMount<br>挂载前</p>
<p>mounted<br>挂载</p>
<p>beforeUpdate<br>数据更新前，发生在虚拟 DOM 重新渲染和打补丁之前</p>
<p>updated<br>数据更新，虚拟 DOM 重新渲染和打补丁后</p>
<p>activated<br>keep-alive 组件激活时</p>
<p>deactivated<br>keep-alive 组件停用时</p>
<p>beforeDestroy<br>实例销毁前</p>
<p>destroyed<br>实例销毁后</p>
<h3 id="实际场景应用"><a href="#实际场景应用" class="headerlink" title="实际场景应用"></a>实际场景应用</h3><p>beforeCreate<br>实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前</p>
<p>读取不到数据 (data) 和方法(methods)</p>
<p>created<br>实例创建完成后</p>
<p>在这一步，实例已完成以下的配置：数据观测 (data observer)，<br>属性和方法的运算，watch/event 事件回调。<br>然而，挂载阶段还没开始，$el 属性目前不可见。</p>
<p>可以调用实例的数据 和 方法</p>
<p>如：异步函数的调用, 初始化</p>
<p>异步数据获取后的 dom 操作可以用<br>vue.$nextTick 方法操作<br>可以对不同的异步数据做不同的 dom 操作<br>某个数据的某一次变化</p>
<p>对某个数据的变化做统一处理可以用 watch</p>
<p>beforeMount<br>挂载前</p>
<p>mounted<br>挂载</p>
<p>有初始数据的 dom 渲染, 可以获取 dom</p>
<p>beforeUpdate<br>数据更新前，发生在虚拟 DOM 重新渲染和打补丁之前</p>
<p>updated<br>数据更新，虚拟 DOM 重新渲染和打补丁后<br>数据更新后的操作</p>
<p>所有数据更新后做统一的操作</p>
<p>activated<br>keep-alive 组件激活时</p>
<p>deactivated<br>keep-alive 组件停用时</p>
<p>beforeDestroy<br>实例销毁前</p>
<p>destroyed<br>实例销毁后</p>
<p>vue.$destroyed 主动触发</p>
]]></content> -->
      <content type="html"><![CDATA[生命周期生命周期钩子的函数实例化 beforeCreate实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前 created实例创建完成后 beforeMount挂载前 mounted挂载 beforeUpdate数据更新前，发生在虚拟 DOM 重新渲染和打补丁之前 updated数据更新，虚拟 DOM 重新渲染和打补丁后 activatedkeep-alive 组件激活时 deactivatedkeep-alive 组件停用时 beforeDestroy实例销毁前 destroyed实例销毁后 实际场景应用beforeCreate实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前 读取不到数据 (data) 和方法(methods) created实例创建完成后 在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 可以调用实例的数据 和 方法 如：异步函数的调用, 初始化 异步数据获取后的 dom 操作可以用vue.$nextTick 方法操作可以对不同的异步数据做不同的 dom 操作某个数据的某一次变化 对某个数据的变化做统一处理可以用 watch beforeMount挂载前 mounted挂载 有初始数据的 dom 渲染, 可以获取 dom beforeUpdate数据更新前，发生在虚拟 DOM 重新渲染和打补丁之前 updated数据更新，虚拟 DOM 重新渲染和打补丁后数据更新后的操作 所有数据更新后做统一的操作 activatedkeep-alive 组件激活时 deactivatedkeep-alive 组件停用时 beforeDestroy实例销毁前 destroyed实例销毁后 vue.$destroyed 主动触发]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vuex 简介]]></title>
      <url>http://ldqblog.me/2017/06/24/Vuex-%E7%AE%80%E4%BB%8B/</url>
      <!-- <content type="html"><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>vue 组件通过 dispatch 来触发 actions [这步可省略， 一般用于处理异步]<br>actions 再通过 commit 触发 mutations , 改变 store 上的 state<br>最终改变 vue 组件 的 view </p>
<p>常与 computed 结合 </p>
<p>state 是唯一数据来源</p>
<p>vuex 是单一状态树</p>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>getters 派生出一些新的状态</p>
<p>Vuex 允许我们在 store 中定义 “getter”（可以认为是 store 的计算属性）。<br>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，<br>且只有当它的依赖值发生了改变才会被重新计算。</p>
<pre><code>const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: &#39;...&#39;, done: true },
      { id: 2, text: &#39;...&#39;, done: false }
    ]
  },
  getters: {
    doneTodos: state =&gt; {
      return state.todos.filter(todo =&gt; todo.done)
    }
  }
})
</code></pre><p>Getter 会暴露为 store.getters 对象：</p>
<p>store.getters.doneTodos // -&gt; [{ id: 1, text: ‘…’, done: true }]<br>Getter 也可以接受其他 getter 作为第二个参数：</p>
<pre><code>getters: {
  // ...
  doneTodosCount: (state, getters) =&gt; {
    return getters.doneTodos.length
  }
}
store.getters.doneTodosCount // -&gt; 1
</code></pre><p>我们可以很容易地在任何组件中使用它：</p>
<pre><code>computed: {
  doneTodosCount () {
    return this.$store.getters.doneTodosCount
  }
}
</code></pre><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p>
<pre><code>getters: {
  // ...
  getTodoById: (state, getters) =&gt; (id) =&gt; {
    return state.todos.find(todo =&gt; todo.id === id)
  }
}
store.getters.getTodoById(2) // -&gt; { id: 2, text: &#39;...&#39;, done: false }
</code></pre><p>mapGetters 辅助函数 类似 mapState</p>
<p>在 computed 中使用… 运算符获取 getters</p>
<h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>更改 vuex 的 store 中的状态的唯一方法是提交 mutations</p>
<p>action 通过 mutations 间接改变 store 的状态</p>
<p>acion 处理异步操作</p>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>将 store 状态分割成模块（modules）<br>便于管理</p>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><pre><code>store
  module 
    moduleHome.js
  mutations
    mutationsHome.js
  index.js




moduleHome.js

import mutations from &#39;../mutations/mutationsHome.js&#39;

export default {
    state: {
        isFullScreen: false
    },
    mutations: mutations()
}




mutationsHome.js

export default () =&gt; {
    return {
        FullScreen (state, isFullScreen) {
            state.isFullScreen = isFullScreen
        }
    }
}



index.js

import Vuex from &#39;vuex&#39;
import Vue from &#39;vue&#39;
Vue.use(Vuex)

import moduleHome from &#39;./module/moduleHome.js&#39;


export default new Vuex.Store({
    modules: {
        home: moduleHome
    }
})   





main.js

import Vue from &#39;vue&#39;
import App from &#39;./App&#39;
import store from &#39;./store/index.js&#39;

Vue.config.productionTip = false



new Vue({
  el: &#39;#app&#39;,
  store,
  render: h =&gt; h(App)
})
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>const Sidebar = resolve =&gt; require([&#39;../../components/Sidebar.vue&#39;], resolve)
const MainContent = resolve =&gt; require([&#39;../../components/MainContent.vue&#39;], resolve)
const Buttons = resolve =&gt; require([&#39;../../components/Button.vue&#39;], resolve)

import { mapState } from &#39;vuex&#39;

export default {
    name: &#39;Home&#39;,
    data () {
        return {

        } 
    },
    computed: {
        ...mapState({
            isFullScreen: state =&gt; state.home.isFullScreen
        })
        /*
            isFullScreen() {
                return this.$store.state.home.isFullScreen
            }
        */
    },
    components: {
        Buttons,
        Sidebar,
        MainContent
    },
    methods: {
        cancelFullScreen () {
            this.$store.commit(&#39;FullScreen&#39;, false)
        }
    }
}
</code></pre><h3 id="对比-redux"><a href="#对比-redux" class="headerlink" title="对比 redux"></a>对比 redux</h3><pre><code>
都是基于 Flux
吸取 redux 的优点
放弃强制的 immutability
api 更简洁
性能较好
与 vue 契合度更高
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/3563580-c893179ac3e708f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuex.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Vuex 文档 </strong>: <a href="https://vuex.vuejs.org/zh-cn/" target="_blank" rel="external">https://vuex.vuejs.org/zh-cn/</a><br><strong> 尤大的答案 </strong>: <a href="https://www.zhihu.com/question/38546875/answer/76970954" target="_blank" rel="external">https://www.zhihu.com/question/38546875/answer/76970954</a></p>
]]></content> -->
      <content type="html"><![CDATA[Vuex概念vue 组件通过 dispatch 来触发 actions [这步可省略， 一般用于处理异步]actions 再通过 commit 触发 mutations , 改变 store 上的 state最终改变 vue 组件 的 view 常与 computed 结合 state 是唯一数据来源 vuex 是单一状态树 gettersgetters 派生出一些新的状态 Vuex 允许我们在 store 中定义 “getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 const store = new Vuex.Store({ state: { todos: [ { id: 1, text: &#39;...&#39;, done: true }, { id: 2, text: &#39;...&#39;, done: false } ] }, getters: { doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done) } } }) Getter 会暴露为 store.getters 对象： store.getters.doneTodos // -&gt; [{ id: 1, text: ‘…’, done: true }]Getter 也可以接受其他 getter 作为第二个参数： getters: { // ... doneTodosCount: (state, getters) =&gt; { return getters.doneTodos.length } } store.getters.doneTodosCount // -&gt; 1 我们可以很容易地在任何组件中使用它： computed: { doneTodosCount () { return this.$store.getters.doneTodosCount } } 你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。 getters: { // ... getTodoById: (state, getters) =&gt; (id) =&gt; { return state.todos.find(todo =&gt; todo.id === id) } } store.getters.getTodoById(2) // -&gt; { id: 2, text: &#39;...&#39;, done: false } mapGetters 辅助函数 类似 mapState 在 computed 中使用… 运算符获取 getters mutations更改 vuex 的 store 中的状态的唯一方法是提交 mutations action 通过 mutations 间接改变 store 的状态 acion 处理异步操作 modules将 store 状态分割成模块（modules）便于管理 一个简单的例子store module moduleHome.js mutations mutationsHome.js index.js moduleHome.js import mutations from &#39;../mutations/mutationsHome.js&#39; export default { state: { isFullScreen: false }, mutations: mutations() } mutationsHome.js export default () =&gt; { return { FullScreen (state, isFullScreen) { state.isFullScreen = isFullScreen } } } index.js import Vuex from &#39;vuex&#39; import Vue from &#39;vue&#39; Vue.use(Vuex) import moduleHome from &#39;./module/moduleHome.js&#39; export default new Vuex.Store({ modules: { home: moduleHome } }) main.js import Vue from &#39;vue&#39; import App from &#39;./App&#39; import store from &#39;./store/index.js&#39; Vue.config.productionTip = false new Vue({ el: &#39;#app&#39;, store, render: h =&gt; h(App) }) 使用const Sidebar = resolve =&gt; require([&#39;../../components/Sidebar.vue&#39;], resolve) const MainContent = resolve =&gt; require([&#39;../../components/MainContent.vue&#39;], resolve) const Buttons = resolve =&gt; require([&#39;../../components/Button.vue&#39;], resolve) import { mapState } from &#39;vuex&#39; export default { name: &#39;Home&#39;, data () { return { } }, computed: { ...mapState({ isFullScreen: state =&gt; state.home.isFullScreen }) /* isFullScreen() { return this.$store.state.home.isFullScreen } */ }, components: { Buttons, Sidebar, MainContent }, methods: { cancelFullScreen () { this.$store.commit(&#39;FullScreen&#39;, false) } } } 对比 redux 都是基于 Flux 吸取 redux 的优点 放弃强制的 immutability api 更简洁 性能较好 与 vue 契合度更高 参考资料Vuex 文档 : https://vuex.vuejs.org/zh-cn/ 尤大的答案 : https://www.zhihu.com/question/38546875/answer/76970954]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue 版 CNode 社区 (二)]]></title>
      <url>http://ldqblog.me/2017/06/22/Vue%E7%89%88CNode%E7%A4%BE%E5%8C%BA-%E4%BA%8C/</url>
      <!-- <content type="html"><![CDATA[<h1 id="Vue-版-CNode-社区技术详情"><a href="#Vue-版-CNode-社区技术详情" class="headerlink" title="Vue 版 CNode 社区技术详情"></a>Vue 版 CNode 社区技术详情</h1><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue 配合 Vue-Router，Vuex</p>
<p>实现路由跳转，路由过渡，状态管理</p>
<p>Vue-lazyload<br>头像图片懒加载</p>
<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>实现 api 请求等的异步处理</p>
<h2 id="Moment-js"><a href="#Moment-js" class="headerlink" title="Moment.js"></a>Moment.js</h2><p>处理时间的显示</p>
<h2 id="Simplemde"><a href="#Simplemde" class="headerlink" title="Simplemde"></a>Simplemde</h2><p>用于实现 markdown 方式回复，发帖</p>
<h2 id="loaclStorge"><a href="#loaclStorge" class="headerlink" title="loaclStorge"></a>loaclStorge</h2><p>用于存储用户的登录信息<br>防止刷新或重开网页后登录失效</p>
<h2 id="滚动加载"><a href="#滚动加载" class="headerlink" title="滚动加载"></a>滚动加载</h2><p>通过监听 scroll 事件来实现</p>
<pre><code>
 scroll(e) {
            if(e.target.clientHeight  &gt; e.target.scrollTop) {
                const e = this.$refs.articles;
                bus.$emit(&#39;isShowTop&#39;, {isShow: false, e});
            }
            else {
                  const e = this.$refs.articles;
                bus.$emit(&#39;isShowTop&#39;, {isShow: true, e});
            }
            const pathArr = [&#39;/&#39;, &#39;/articleList/all&#39;, &#39;/articleList/good&#39;, &#39;/articleList/share&#39;, &#39;/articleList/ask&#39;, &#39;/articleList/job&#39;, &#39;/articleList/dev&#39;];
            if(pathArr.indexOf(this.$route.path) === -1) {
                return;
            }
            if(!this.over &amp;&amp; !this.isLoading) {
                let isOver = e.target.clientHeight + Math.ceil(e.target.scrollTop) &gt;= e.target.scrollHeight - 100;
                if(isOver) {
                    console.log(this.page)
                    this.page ++;
                    this.$store.commit(&#39;changeMore&#39;, true);
                    this.$store.commit(&#39;changeTab&#39;,{isLoading: true});
                    axios.get(`https://cnodejs.org/api/v1/topics?page=${this.page}&amp;tab=${this.tab}`)
                          .then(result =&gt;result.data.data)
                          .then(articleList =&gt; {
                              if(!articleList.length) {
                                  this.$store.commit(&#39;Over&#39;, true);
                                  this.$store.commit(&#39;changeMore&#39;, false);
                                  return ;
                              }
                              this.$store.commit(&#39;changeTab&#39;,
                               {articleList: this.articleList.concat(articleList), isLoading: false});
                          })
                          .then(() =&gt; this.$store.commit(&#39;changeMore&#39;, false));
                }
            }
        },
</code></pre><h2 id="Canvas-loading"><a href="#Canvas-loading" class="headerlink" title="Canvas loading"></a>Canvas loading</h2><p>利用  window.requestAnimationFrame  做动画</p>
<p>画个白色的圆  whiteCircle() </p>
<p>画文字 text()</p>
<p>画蓝色的圆形进度条 blueCircle()</p>
<pre><code>
    data() {
        return {
            canvas: {},
            context: {},
            centerX: 0,
            centerY: 0,
            radius: 80,
            rad: 0,
            speed: 0.1,
            timer: &#39;&#39;,
        }
    },
    mounted() {
        this.init();
    },
    methods: {
        init() {
            const canvas = this.$refs.canvasLoading;
            const context = canvas.getContext(&#39;2d&#39;);

            this.canvas = canvas;
            this.context = context;
            this.centerX = canvas.width/2;
            this.centerY = canvas.height/2;
            this.rad = 2*Math.PI/100;
            this.speed = 0.2;

             window.requestAnimFrame = (function(){
            return  window.requestAnimationFrame       ||
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame    ||
                    window.oRequestAnimationFrame      || 
                    window.msRequestAnimationFrame     || 
                   function ( callback ){
                        window.setTimeout(callback, 1000 / 60);
                    };
            })();

             window.cancelAnimationFrame = (function(){
            return  window.cancelAnimationFrame       ||
                    window.webkitCancelAnimationFrame ||
                    window.mozCancelAnimationFrame    ||
                    window.oCancelAnimationFrame      || 
                    window.msCancelAnimationFrame     || 
                    function(){
                        window.clearTimeout(this.timer);
                    };
            })();
            this.loading();
        },  
        loading() {
            this.timer = requestAnimationFrame(this.loading, this.canvas);
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.whiteCircle();
            this.text();
            this.blueCircle();
            if(this.speed &gt; 100) {
                this.speed = 0;
                cancelAnimationFrame(this.timer);                
            this.$emit(&#39;BeginLoading&#39;);
            }
            else {
                this.speed += 0.4;
            }
        },
        whiteCircle() {
            this.context.save();
            this.context.beginPath();
            this.context.strokeStyle = &#39;#FFF&#39;;
            this.context.arc(this.centerX, this.centerY, this.radius, 0, Math.PI * 2, false );
            this.context.stroke();
            this.context.closePath();
            this.context.restore();
        },
        text() {
            this.context.save();
            this.context.strokeStyle = &#39;#FFF&#39;;
            this.context.font = &#39;30px Arial&#39;;
            const text = this.speed.toFixed(0) + &#39;%&#39;;
            const textWidth = this.context.measureText(text).width;
            const translateWidth = (textWidth/2).toFixed(0);
             this.context.strokeText(text, 
                this.centerX - translateWidth + 5, this.centerY + 10);

            this.context.stroke();
            this.context.restore();
        },
        blueCircle() {
            this.context.save();
            this.context.strokeStyle = &#39;rgba(3,169,244,1)&#39;;
            this.context.lineWidth = 10;
            this.context.beginPath();
            this.context.arc(this.centerX, this.centerY, this.radius,
             -Math.PI/2, -Math.PI/2 + this.speed * this.rad, false );
            this.context.stroke();
            this.context.closePath();
            this.context.restore();
        },

    }
</code></pre>]]></content> -->
      <content type="html"><![CDATA[Vue 版 CNode 社区技术详情VueVue 配合 Vue-Router，Vuex 实现路由跳转，路由过渡，状态管理 Vue-lazyload头像图片懒加载 Axios实现 api 请求等的异步处理 Moment.js处理时间的显示 Simplemde用于实现 markdown 方式回复，发帖 loaclStorge用于存储用户的登录信息防止刷新或重开网页后登录失效 滚动加载通过监听 scroll 事件来实现 scroll(e) { if(e.target.clientHeight &gt; e.target.scrollTop) { const e = this.$refs.articles; bus.$emit(&#39;isShowTop&#39;, {isShow: false, e}); } else { const e = this.$refs.articles; bus.$emit(&#39;isShowTop&#39;, {isShow: true, e}); } const pathArr = [&#39;/&#39;, &#39;/articleList/all&#39;, &#39;/articleList/good&#39;, &#39;/articleList/share&#39;, &#39;/articleList/ask&#39;, &#39;/articleList/job&#39;, &#39;/articleList/dev&#39;]; if(pathArr.indexOf(this.$route.path) === -1) { return; } if(!this.over &amp;&amp; !this.isLoading) { let isOver = e.target.clientHeight + Math.ceil(e.target.scrollTop) &gt;= e.target.scrollHeight - 100; if(isOver) { console.log(this.page) this.page ++; this.$store.commit(&#39;changeMore&#39;, true); this.$store.commit(&#39;changeTab&#39;,{isLoading: true}); axios.get(`https://cnodejs.org/api/v1/topics?page=${this.page}&amp;tab=${this.tab}`) .then(result =&gt;result.data.data) .then(articleList =&gt; { if(!articleList.length) { this.$store.commit(&#39;Over&#39;, true); this.$store.commit(&#39;changeMore&#39;, false); return ; } this.$store.commit(&#39;changeTab&#39;, {articleList: this.articleList.concat(articleList), isLoading: false}); }) .then(() =&gt; this.$store.commit(&#39;changeMore&#39;, false)); } } }, Canvas loading利用 window.requestAnimationFrame 做动画 画个白色的圆 whiteCircle() 画文字 text() 画蓝色的圆形进度条 blueCircle() data() { return { canvas: {}, context: {}, centerX: 0, centerY: 0, radius: 80, rad: 0, speed: 0.1, timer: &#39;&#39;, } }, mounted() { this.init(); }, methods: { init() { const canvas = this.$refs.canvasLoading; const context = canvas.getContext(&#39;2d&#39;); this.canvas = canvas; this.context = context; this.centerX = canvas.width/2; this.centerY = canvas.height/2; this.rad = 2*Math.PI/100; this.speed = 0.2; window.requestAnimFrame = (function(){ return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function ( callback ){ window.setTimeout(callback, 1000 / 60); }; })(); window.cancelAnimationFrame = (function(){ return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function(){ window.clearTimeout(this.timer); }; })(); this.loading(); }, loading() { this.timer = requestAnimationFrame(this.loading, this.canvas); this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); this.whiteCircle(); this.text(); this.blueCircle(); if(this.speed &gt; 100) { this.speed = 0; cancelAnimationFrame(this.timer); this.$emit(&#39;BeginLoading&#39;); } else { this.speed += 0.4; } }, whiteCircle() { this.context.save(); this.context.beginPath(); this.context.strokeStyle = &#39;#FFF&#39;; this.context.arc(this.centerX, this.centerY, this.radius, 0, Math.PI * 2, false ); this.context.stroke(); this.context.closePath(); this.context.restore(); }, text() { this.context.save(); this.context.strokeStyle = &#39;#FFF&#39;; this.context.font = &#39;30px Arial&#39;; const text = this.speed.toFixed(0) + &#39;%&#39;; const textWidth = this.context.measureText(text).width; const translateWidth = (textWidth/2).toFixed(0); this.context.strokeText(text, this.centerX - translateWidth + 5, this.centerY + 10); this.context.stroke(); this.context.restore(); }, blueCircle() { this.context.save(); this.context.strokeStyle = &#39;rgba(3,169,244,1)&#39;; this.context.lineWidth = 10; this.context.beginPath(); this.context.arc(this.centerX, this.centerY, this.radius, -Math.PI/2, -Math.PI/2 + this.speed * this.rad, false ); this.context.stroke(); this.context.closePath(); this.context.restore(); }, }]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue 版 CNode 社区 (一)]]></title>
      <url>http://ldqblog.me/2017/06/20/Vue%E7%89%88CNode%E7%A4%BE%E5%8C%BA-%E4%B8%80/</url>
      <!-- <content type="html"><![CDATA[<h1 id="Vue-版-CNode-社区介绍"><a href="#Vue-版-CNode-社区介绍" class="headerlink" title="Vue 版 CNode 社区介绍"></a>Vue 版 CNode 社区介绍</h1><h2 id="预览地址"><a href="#预览地址" class="headerlink" title="预览地址"></a>预览地址</h2><p><a href="http://ldqblog.me/vue-CNode/dist/#/">预览地址</a></p>
<h2 id="手机可访问二维码"><a href="#手机可访问二维码" class="headerlink" title="手机可访问二维码"></a>手机可访问二维码</h2><p><img src="http://ldqblog.me/vue-CNode/static/img/mobile.png" alt="Vue 版 CNode">  </p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/LDQ-first/vue-CNode" target="_blank" rel="external">GitHub</a></p>
<hr>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>做 Vue 版 CNode 社区的原因：</p>
<pre><code>1. 学习 Vue 全家桶构建项目
2. CNode 社区提供了 API
3. 做一个属于自己的 CNode 社区，当然仅限于前端
</code></pre><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li><strong>Vue2.2</strong>: [ 前端框架 ]</li>
<li><strong>Vuex</strong>: [ 状态管理, 组件通信 ] </li>
<li><strong>Vue-router</strong>: [ 配置路由，组件切换 ]</li>
<li><strong>Vue-lazyload</strong>: [ 图片懒加载 ]</li>
<li><strong>ES6/7</strong>: [ JS 版本 ]</li>
<li><strong>Webpack</strong>: [ 模块化处理，编译打包 ]</li>
<li><strong>Express</strong>: [ 服务器 ]</li>
<li><strong>Axios</strong>: [ 基于 Promise 处理 HTTP 请求 ]</li>
<li><strong>SASS</strong>(<strong>SCSS</strong>): [ css 预处理器 ]</li>
<li><strong>Normalize.css</strong>: [ 处理浏览器默认样式 ]</li>
<li><strong>Font-awesome</strong>: [ 字体图标 ]</li>
<li><strong>Moment.js</strong>: [ 处理时间显示 ]</li>
<li><strong>Simplemde</strong>: [ markdown 编辑器 ]</li>
<li><strong>Highlight.js</strong>: [ 语法高亮 ]</li>
<li><strong>Flex</strong>: [ 弹性布局 ]</li>
<li><strong>Canvas</strong>: [ 首页 loading 效果，按钮的波纹效果 ]</li>
<li><strong>loaclStorge</strong>: [ 本地存储用户信息 ]</li>
</ul>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="http://ldqblog.me/vue-CNode/static/img / 项目结构. jpg" alt="项目结构思维导图"></p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://ldqblog.me/vue-CNode/static/result/001.jpg" alt="001">  </p>
<p><img src="http://ldqblog.me/vue-CNode/static/result/002.jpg" alt="002">  </p>
<p><img src="http://ldqblog.me/vue-CNode/static/result/003.jpg" alt="003">  </p>
<p><img src="http://ldqblog.me/vue-CNode/static/result/004.jpg" alt="004">  </p>
<h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>实现了<br>登录 (使用官方提供的 access token 方法登录)，<br>回复，发帖，（支持 Markdown）<br>滚动加载更多，（监听 scroll 事件）<br>收藏，点赞，<br>查看消息，（支持已读消息和未读消息）<br>更换主题色，(利用 Vuex，四种主题色可更换)<br>退出登录<br>查看个人信息</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>没有下拉刷新</li>
<li>图片点击查看大图不支持手指缩放，<br>导致移动端看大图体验差</li>
<li>利用 Vuex 实现的更换主题色方法比较繁琐，<br>考虑是否有其他更优的方法</li>
<li>项目结构有待改善，<br>纯组件和视图组件应分开，<br>sass 文件单独出来，没有利用到 scoped<br>vuex 没有分模块</li>
</ul>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>改善问题<br>优化代码</p>
<hr>
<h2 id="下一篇"><a href="#下一篇" class="headerlink" title="下一篇"></a>下一篇</h2><p><a href="http://ldqblog.me/2017/06/22/Vue%E7%89%88CNode%E7%A4%BE%E5%8C%BA-%E4%BA%8C/">Vue 版 CNode 社区 (二)</a></p>
<p><strong> 感谢 CNode 社区提供 API 供人学习 </strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Vue 文档 </strong>: <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="external">https://cn.vuejs.org/v2/guide/</a><br><strong>CNode API</strong>: <a href="https://cnodejs.org/api" target="_blank" rel="external">https://cnodejs.org/api</a></p>
]]></content> -->
      <content type="html"><![CDATA[Vue 版 CNode 社区介绍预览地址预览地址 手机可访问二维码 源码GitHub 起因做 Vue 版 CNode 社区的原因： 1. 学习 Vue 全家桶构建项目 2. CNode 社区提供了 API 3. 做一个属于自己的 CNode 社区，当然仅限于前端 技术栈 Vue2.2: [ 前端框架 ] Vuex: [ 状态管理, 组件通信 ] Vue-router: [ 配置路由，组件切换 ] Vue-lazyload: [ 图片懒加载 ] ES6/7: [ JS 版本 ] Webpack: [ 模块化处理，编译打包 ] Express: [ 服务器 ] Axios: [ 基于 Promise 处理 HTTP 请求 ] SASS(SCSS): [ css 预处理器 ] Normalize.css: [ 处理浏览器默认样式 ] Font-awesome: [ 字体图标 ] Moment.js: [ 处理时间显示 ] Simplemde: [ markdown 编辑器 ] Highlight.js: [ 语法高亮 ] Flex: [ 弹性布局 ] Canvas: [ 首页 loading 效果，按钮的波纹效果 ] loaclStorge: [ 本地存储用户信息 ] 项目结构 效果图 成果实现了登录 (使用官方提供的 access token 方法登录)，回复，发帖，（支持 Markdown）滚动加载更多，（监听 scroll 事件）收藏，点赞，查看消息，（支持已读消息和未读消息）更换主题色，(利用 Vuex，四种主题色可更换)退出登录查看个人信息 问题 没有下拉刷新 图片点击查看大图不支持手指缩放，导致移动端看大图体验差 利用 Vuex 实现的更换主题色方法比较繁琐，考虑是否有其他更优的方法 项目结构有待改善，纯组件和视图组件应分开，sass 文件单独出来，没有利用到 scopedvuex 没有分模块 未来改善问题优化代码 下一篇Vue 版 CNode 社区 (二) 感谢 CNode 社区提供 API 供人学习 参考资料Vue 文档 : https://cn.vuejs.org/v2/guide/CNode API: https://cnodejs.org/api]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue-Router 简介]]></title>
      <url>http://ldqblog.me/2017/06/18/Vue-Router-%E7%AE%80%E4%BB%8B/</url>
      <!-- <content type="html"><![CDATA[<h1 id="Vue-Router-简介"><a href="#Vue-Router-简介" class="headerlink" title="Vue-Router 简介"></a>Vue-Router 简介</h1><h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><blockquote>
<p>指根据不同的 url 展示不同的内容或页面</p>
</blockquote>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><pre><code>用户体验好，
不需要每次从服务器全部获取
展示更加快速
</code></pre><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><pre><code>不利于 SEO
使用浏览器的前进后退功能时，会重新发请求，
不能有效利用缓存

单页面无法记住之前滚动的位置，
无法在前进后退的时候记住之前的位置
</code></pre><h2 id="Vue-路由-——-Vue-Router"><a href="#Vue-路由-——-Vue-Router" class="headerlink" title="Vue 路由 —— Vue-Router"></a>Vue 路由 —— Vue-Router</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><pre><code>
/user/:username
/user/:username/goodlist/:goodlist_id


username，goodlist_id 是变化的

$router.params
</code></pre><h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><p>路由有子路由</p>
<pre><code>export default new Router({
  routes: [
    {
      path: &#39;/goods&#39;,
      name: &#39;GoodList&#39;,
      component: GoodList,
      children:[
        {
          path: &#39;title&#39;,
          name: &#39;title&#39;,
          component: Title
        },
        {
          path: &#39;img&#39;,
          name: &#39;img&#39;,
          component: Image
        }
      ]
    }
  ]
})
</code></pre><h4 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h4><p>不通过 <router-link>&lt; /router-link &gt; 来跳转，而通过<br>事件触发，调用 $router.push() API 来跳转</router-link></p>
<pre><code>$router.push(&quot;name&quot;)
$router.push({path:&quot;name&quot;})
$router.push({path:&quot;name?a=123&quot;})
$router.push({path:&quot;name&quot;, query: {a:&quot;123&quot;}})
$router.go(1)  // 前进 1 页  相当于 history.go(1)


&lt; button @click=&quot;jump&quot; &gt;跳转到购物车页面&lt; /button &gt;

 methods:{
    jump() {
        //this.$router.push(&quot;cart&quot;)
        this.$router.push({path:&#39;cart?goodsId=123&#39;})
    }
}
</code></pre><h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><p>给路由不同的名字，根据名字来进行匹配</p>
<pre><code>import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
import GoodList from &#39;../views/GoodList&#39;
import Title from &#39;@/views/Title&#39;
import Image from &#39;@/views/Image&#39;
import Cart from &#39;@/views/Cart&#39;

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: &#39;/goods&#39;,
      name: &#39;GoodList&#39;,
      component: GoodList,
      children:[
        {
          path: &#39;title&#39;,
          name: &#39;title&#39;,
          component: Title
        },
        {
          path: &#39;img&#39;,
          name: &#39;img&#39;,
          component: Image
        }
      ]
    },
    {
        path: &#39;/cart/:cartId&#39;,
        name: &#39;cart&#39;,
        component: Cart
    }
  ]
})


&lt; router-link :to=&quot;{name:&#39;cart&#39;,params:{cartId: 123}}&quot; &gt;跳转到购物车页面&lt; /router-link &gt;
</code></pre><h4 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h4><p>给不同的 router-view 定义名字，通过名字进行对应组件的渲染</p>
<pre><code>import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
import GoodList from &#39;../views/GoodList&#39;
import Title from &#39;@/views/Title&#39;
import Image from &#39;@/views/Image&#39;
import Cart from &#39;@/views/Cart&#39;

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: &#39;/&#39;,
      name: &#39;GoodList&#39;,
      components: {
        default: GoodList,
        title: Title,
        img: Image 
      },
      children:[
        {
          path: &#39;title&#39;,
          name: &#39;title&#39;,
          component: Title
        },
        {
          path: &#39;img&#39;,
          name: &#39;img&#39;,
          component: Image
        }
      ]
    },
    {
        path: &#39;/cart/:cartId&#39;,
        name: &#39;cart&#39;,
        component: Cart
    }
  ]
})




&lt; router-view class=&quot;main&quot; &gt;&lt; /router-view&gt;
&lt; router-view name=&quot;title&quot; class=&quot;left&quot; &gt;&lt; /router-view&gt;
&lt; router-view name=&quot;img&quot; class=&quot;right&quot; &gt;&lt; /router-view&gt;
</code></pre><h4 id="路由过渡"><a href="#路由过渡" class="headerlink" title="路由过渡"></a>路由过渡</h4><p>切换路由时有动画效果</p>
<pre><code>&lt; transition name=&quot;show&quot; &gt;
    &lt; router-view name=&quot;login&quot; &gt;&lt; /router-view &gt;
&lt; /transition&gt;


.show-enter-active {
  transition: all .3s ease;
}

.show-leave-active {
  transition: all .2s ease-in;
}


.show-enter, .show-leave-active {
  transform: translateX(200px);
  opacity: 0;
}





api，组件

&lt; router-link &gt;&lt; /router-link &gt;
this.$router.push({path: &#39;&#39;})
&lt; router-view &gt;&lt; /router-view &gt;
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>
router 
    index.js

import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
const GoodList = resolve =&gt; require([&#39;../views/GoodList.vue&#39;], resolve)

Vue.use(Router)


Vue.use(Router)

const routes = [
    {
      path: &#39;/goods/:goodsId/user/:name&#39;,
      name: &#39;GoodList&#39;,
      component: GoodList
    }
]


const router =  new Router({
  routes
})

export default router

export {
    router,
    routes
}



main.js

    import Vue from &#39;vue&#39;
    import App from &#39;./App&#39;
    import router from &#39;./router&#39;

new Vue({
    el: &#39;#app&#39;,
    router,
    render: h =&gt; h(App)
})
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Vue-Router 文档 </strong>: <a href="https://router.vuejs.org/zh-cn/index.html" target="_blank" rel="external">https://router.vuejs.org/zh-cn/index.html</a></p>
]]></content> -->
      <content type="html"><![CDATA[Vue-Router 简介前端路由 指根据不同的 url 展示不同的内容或页面 优点用户体验好， 不需要每次从服务器全部获取 展示更加快速 缺点不利于 SEO 使用浏览器的前进后退功能时，会重新发请求， 不能有效利用缓存 单页面无法记住之前滚动的位置， 无法在前进后退的时候记住之前的位置 Vue 路由 —— Vue-Router概念动态路由 /user/:username /user/:username/goodlist/:goodlist_id username，goodlist_id 是变化的 $router.params 嵌套路由路由有子路由 export default new Router({ routes: [ { path: &#39;/goods&#39;, name: &#39;GoodList&#39;, component: GoodList, children:[ { path: &#39;title&#39;, name: &#39;title&#39;, component: Title }, { path: &#39;img&#39;, name: &#39;img&#39;, component: Image } ] } ] }) 编程式路由不通过 &lt; /router-link &gt; 来跳转，而通过事件触发，调用 $router.push() API 来跳转 $router.push(&quot;name&quot;) $router.push({path:&quot;name&quot;}) $router.push({path:&quot;name?a=123&quot;}) $router.push({path:&quot;name&quot;, query: {a:&quot;123&quot;}}) $router.go(1) // 前进 1 页 相当于 history.go(1) &lt; button @click=&quot;jump&quot; &gt;跳转到购物车页面&lt; /button &gt; methods:{ jump() { //this.$router.push(&quot;cart&quot;) this.$router.push({path:&#39;cart?goodsId=123&#39;}) } } 命名路由给路由不同的名字，根据名字来进行匹配 import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; import GoodList from &#39;../views/GoodList&#39; import Title from &#39;@/views/Title&#39; import Image from &#39;@/views/Image&#39; import Cart from &#39;@/views/Cart&#39; Vue.use(Router) export default new Router({ routes: [ { path: &#39;/goods&#39;, name: &#39;GoodList&#39;, component: GoodList, children:[ { path: &#39;title&#39;, name: &#39;title&#39;, component: Title }, { path: &#39;img&#39;, name: &#39;img&#39;, component: Image } ] }, { path: &#39;/cart/:cartId&#39;, name: &#39;cart&#39;, component: Cart } ] }) &lt; router-link :to=&quot;{name:&#39;cart&#39;,params:{cartId: 123}}&quot; &gt;跳转到购物车页面&lt; /router-link &gt; 命名视图给不同的 router-view 定义名字，通过名字进行对应组件的渲染 import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; import GoodList from &#39;../views/GoodList&#39; import Title from &#39;@/views/Title&#39; import Image from &#39;@/views/Image&#39; import Cart from &#39;@/views/Cart&#39; Vue.use(Router) export default new Router({ routes: [ { path: &#39;/&#39;, name: &#39;GoodList&#39;, components: { default: GoodList, title: Title, img: Image }, children:[ { path: &#39;title&#39;, name: &#39;title&#39;, component: Title }, { path: &#39;img&#39;, name: &#39;img&#39;, component: Image } ] }, { path: &#39;/cart/:cartId&#39;, name: &#39;cart&#39;, component: Cart } ] }) &lt; router-view class=&quot;main&quot; &gt;&lt; /router-view&gt; &lt; router-view name=&quot;title&quot; class=&quot;left&quot; &gt;&lt; /router-view&gt; &lt; router-view name=&quot;img&quot; class=&quot;right&quot; &gt;&lt; /router-view&gt; 路由过渡切换路由时有动画效果 &lt; transition name=&quot;show&quot; &gt; &lt; router-view name=&quot;login&quot; &gt;&lt; /router-view &gt; &lt; /transition&gt; .show-enter-active { transition: all .3s ease; } .show-leave-active { transition: all .2s ease-in; } .show-enter, .show-leave-active { transform: translateX(200px); opacity: 0; } api，组件 &lt; router-link &gt;&lt; /router-link &gt; this.$router.push({path: &#39;&#39;}) &lt; router-view &gt;&lt; /router-view &gt; 使用 router index.js import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; const GoodList = resolve =&gt; require([&#39;../views/GoodList.vue&#39;], resolve) Vue.use(Router) Vue.use(Router) const routes = [ { path: &#39;/goods/:goodsId/user/:name&#39;, name: &#39;GoodList&#39;, component: GoodList } ] const router = new Router({ routes }) export default router export { router, routes } main.js import Vue from &#39;vue&#39; import App from &#39;./App&#39; import router from &#39;./router&#39; new Vue({ el: &#39;#app&#39;, router, render: h =&gt; h(App) }) 参考资料Vue-Router 文档 : https://router.vuejs.org/zh-cn/index.html]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vue 简介]]></title>
      <url>http://ldqblog.me/2017/06/06/Vue-%E7%AE%80%E4%BB%8B/</url>
      <!-- <content type="html"><![CDATA[<h1 id="Vue-简介"><a href="#Vue-简介" class="headerlink" title="Vue 简介"></a>Vue 简介</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Vue 是一套构建用户界面的渐进式 MVVM 框架<br>Vue 的核心库只关注视图层，将路由交给 Vue-Router ，状态管理交给 Vuex </p>
</blockquote>
<h3 id="核心概念和关键词"><a href="#核心概念和关键词" class="headerlink" title="核心概念和关键词"></a>核心概念和关键词</h3><p>template<br>data<br>methods<br>components </p>
<p>计算属性<br>watch</p>
<h4 id="计算属性-vs-watch"><a href="#计算属性-vs-watch" class="headerlink" title="计算属性 vs watch"></a>计算属性 vs watch</h4><blockquote>
<p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的 watcher。<br>这是为什么 Vue 通过 watch 选项提供一个更通用的方法，来响应数据的变化。<br>当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的。  </p>
</blockquote>
<p>指令<br>插件<br>生命周期<br>响应式<br>过渡<br>混合<br>过滤器</p>
<p>路由<br>状态管理<br>服务端渲染<br>单元测试</p>
<p>api<br>风格指南</p>
<p>生态</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装好 nodejs, 有命令行工具</p>
<p>在命令行工具中</p>
<pre><code>npm install -g vue-cli
vue init webpack myProject
cd myProject
npm install
npm run dev
</code></pre><p>浏览器会自动打开 <a href="http://localhost:8080/#/" target="_blank" rel="external">http://localhost:8080/#/</a>  (opn 模块)</p>
<p>写完代码</p>
<p>npm run build 构建打包</p>
<p>生成的 dist 文件夹就是要发布的文件</p>
<h4 id="用到的文件"><a href="#用到的文件" class="headerlink" title="用到的文件"></a>用到的文件</h4><p>build 和 config 文件夹</p>
<p>webpack 配置，可以自己修改</p>
<p>一般改 config/index.js 的 build assetsPublicPath，这是打包后的静态文件的路径前添加的路径<br>因为线上路径和开发路径很多时候有所不同</p>
<p>如: assetsPublicPath: ‘/vue-CNode/dist/‘</p>
<p>dev proxyTable</p>
<p>配置代理<br>用于解决开发时的跨域问题</p>
<pre><code>
proxyTable: {
      &#39;/goods&#39;: {
          target: &#39;http://localhost:3000&#39;
      },
      &#39;/goods/*&#39;: {
          target: &#39;http://localhost:3000&#39;
      },
      &#39;/users/**&#39;: {
          target: &#39;http://localhost:3000&#39;
      }
    },
</code></pre><p>src  编写代码</p>
<p>一种项目的录结构</p>
<p>   assets 静态资源<br>   Components 组件<br>   router 路由<br>   store vuex<br>   util 工具脚本<br>   views 路由组件<br>   App.vue 根组件<br>   main.js 入口文件</p>
<p>static<br>  静态资源</p>
<h4 id="assets-和-static-的区别"><a href="#assets-和-static-的区别" class="headerlink" title="assets 和 static 的区别"></a>assets 和 static 的区别</h4><p>assets：<br>一般存放开发过程中自己写的静态资源<br>（image, css, js 等，如：shop.css, car.png, roomListUtil.js）</p>
<p>static：<br>存放第三方静态资源（jquery.js, bootstrap.css 等），<br>这里的资源一般是直接引用，当打包编译后 assets 中的静态资源也会编译到 static 目录下，<br>这样原来引用 static 资源的地址也不用改变。<br>最后编译发布的时候会将所有的静态资源整合到 /dist/static/ 目录下，当然也可以自定义其他路径。</p>
<p>index.html<br>    模板 HTML 文件 </p>
<h4 id="Vue-的页面架构流程"><a href="#Vue-的页面架构流程" class="headerlink" title="Vue 的页面架构流程"></a>Vue 的页面架构流程</h4><p><img src="http://upload-images.jianshu.io/upload_images/3563580-ddbf4fee1d6de4c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vue.png"></p>
<h3 id="独立构建-运行时构建"><a href="#独立构建-运行时构建" class="headerlink" title="独立构建 运行时构建"></a>独立构建 运行时构建</h3><p>一、独立构建包含模板编译器，运行时构建不包含模板编译器。<br>二、模板编译器的作用就是将 template 选项编译成 render 函数，render 函数是渲染的关键。<br>三、鉴于以上两点，使用运行时构建时，不能出现 template 选项，因为此时没有模板编译器。<br>但是有一种情况除外：即 webpack+vue-loader 情况下单文件组件中出现 template 是可以的。<br>四、使用 vue-cli 生成项目时，会提醒使用哪种构建方式，npm 包默认导出的是运行时构建，<br>如果需要使用独立构建，需要在 webpack 中配置 alias(设置 alias 为 vue.common.js)<br>五、目前暂时发现的两者的应用场景上的区别有：</p>
<p>需要注意 Vue 实例化时的方式，运行时构建方式下实例化 Vue 时，不要出现 template 属性<br>index.html 中不要出现 template 或者是通过 vue-router 渲染的 route-view</p>
<p>运行时构建一定要 render 函数</p>
<pre><code>new Vue({
    el: &#39;#app&#39;,
    render: h =&gt; h(App)
})


独立构建，是指可以在 html 里放置模板，并在 Vue 实例选项中通过 el 指定模板元素（同时也是挂载元素）
</code></pre><h2 id="框架对比"><a href="#框架对比" class="headerlink" title="框架对比"></a>框架对比</h2><h4 id="Vue-和-React-的共同点"><a href="#Vue-和-React-的共同点" class="headerlink" title="Vue 和 React 的共同点"></a>Vue 和 React 的共同点</h4><p>使用 Virtual DOM<br>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件<br>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库</p>
<h4 id="Vue-的优势"><a href="#Vue-的优势" class="headerlink" title="Vue 的优势"></a>Vue 的优势</h4><p>在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，<br>所以系统能精确知晓哪个组件确实需要被重渲染。<br>React 由于 发生变化时会重新渲染整个组件树，所以需要做一些额外的优化工作<br>(PureComponent shouldComponentUpdate Immutable Reselect)</p>
<p>vue 的 template 模板就是 HTML 写法，比起 jsx 更容易编写和理解</p>
<p>vue 在每个单文件组件中可以访问自己独立的 css module，<br>在 style 标签里添加一个属性 scoped，不会污染全局</p>
<p>vue 提供大量的指令来简化开发中的重复劳动<br>如：v-for 可以构建循环，在 React 中要自己写（使用 map 构建）</p>
<p>Vue 设置样式的默认方法是单文件组件里类似 style 的标签</p>
<h4 id="Vue-的劣势"><a href="#Vue-的劣势" class="headerlink" title="Vue 的劣势"></a>Vue 的劣势</h4><p>生态比不上 React</p>
<p>在原生开发中，Weex 还没有 React Native 成熟</p>
<h4 id="Vue-与-Angular1"><a href="#Vue-与-Angular1" class="headerlink" title="Vue 与 Angular1"></a>Vue 与 Angular1</h4><p>在 API 与设计两方面上 Vue.js 都比 AngularJS 简单得多</p>
<p>Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，<br>而不是在任何时候都必须遵循 AngularJS 制定的规则，这让 Vue 能适用于各种项目。</p>
<p>AngularJS 使用双向绑定，Vue 在不同组件间强制使用单向数据流。<br>这使应用中的数据流更加清晰易懂。</p>
<p>在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，<br>而组件代表一个自给自足的独立单元——有自己的视图和数据逻辑。<br>在 AngularJS 中两者有不少相混的地方。</p>
<p>Vue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。</p>
<h4 id="Vue-与-Angular2"><a href="#Vue-与-Angular2" class="headerlink" title="Vue 与 Angular2"></a>Vue 与 Angular2</h4><p>Vue 和 TS 的整合可能不如 Angular 那么深入<br>在中小型规模的项目中，引入 TS 可能并不会带来太多明显的优势。<br>在这些情况下，用 Vue 会是更好的选择，<br>因为在不用 TS 的情况下使用 Angular 会很有挑战性。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>Vue 文档 </strong>: <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="external">https://cn.vuejs.org/v2/guide/</a></p>
]]></content> -->
      <content type="html"><![CDATA[Vue 简介简介 Vue 是一套构建用户界面的渐进式 MVVM 框架Vue 的核心库只关注视图层，将路由交给 Vue-Router ，状态管理交给 Vuex 核心概念和关键词templatedatamethodscomponents 计算属性watch 计算属性 vs watch 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的 watcher。这是为什么 Vue 通过 watch 选项提供一个更通用的方法，来响应数据的变化。当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的。 指令插件生命周期响应式过渡混合过滤器 路由状态管理服务端渲染单元测试 api风格指南 生态 使用安装好 nodejs, 有命令行工具 在命令行工具中 npm install -g vue-cli vue init webpack myProject cd myProject npm install npm run dev 浏览器会自动打开 http://localhost:8080/#/ (opn 模块) 写完代码 npm run build 构建打包 生成的 dist 文件夹就是要发布的文件 用到的文件build 和 config 文件夹 webpack 配置，可以自己修改 一般改 config/index.js 的 build assetsPublicPath，这是打包后的静态文件的路径前添加的路径因为线上路径和开发路径很多时候有所不同 如: assetsPublicPath: ‘/vue-CNode/dist/‘ dev proxyTable 配置代理用于解决开发时的跨域问题 proxyTable: { &#39;/goods&#39;: { target: &#39;http://localhost:3000&#39; }, &#39;/goods/*&#39;: { target: &#39;http://localhost:3000&#39; }, &#39;/users/**&#39;: { target: &#39;http://localhost:3000&#39; } }, src 编写代码 一种项目的录结构 assets 静态资源 Components 组件 router 路由 store vuex util 工具脚本 views 路由组件 App.vue 根组件 main.js 入口文件 static 静态资源 assets 和 static 的区别assets：一般存放开发过程中自己写的静态资源（image, css, js 等，如：shop.css, car.png, roomListUtil.js） static：存放第三方静态资源（jquery.js, bootstrap.css 等），这里的资源一般是直接引用，当打包编译后 assets 中的静态资源也会编译到 static 目录下，这样原来引用 static 资源的地址也不用改变。最后编译发布的时候会将所有的静态资源整合到 /dist/static/ 目录下，当然也可以自定义其他路径。 index.html 模板 HTML 文件 Vue 的页面架构流程 独立构建 运行时构建一、独立构建包含模板编译器，运行时构建不包含模板编译器。二、模板编译器的作用就是将 template 选项编译成 render 函数，render 函数是渲染的关键。三、鉴于以上两点，使用运行时构建时，不能出现 template 选项，因为此时没有模板编译器。但是有一种情况除外：即 webpack+vue-loader 情况下单文件组件中出现 template 是可以的。四、使用 vue-cli 生成项目时，会提醒使用哪种构建方式，npm 包默认导出的是运行时构建，如果需要使用独立构建，需要在 webpack 中配置 alias(设置 alias 为 vue.common.js)五、目前暂时发现的两者的应用场景上的区别有： 需要注意 Vue 实例化时的方式，运行时构建方式下实例化 Vue 时，不要出现 template 属性index.html 中不要出现 template 或者是通过 vue-router 渲染的 route-view 运行时构建一定要 render 函数 new Vue({ el: &#39;#app&#39;, render: h =&gt; h(App) }) 独立构建，是指可以在 html 里放置模板，并在 Vue 实例选项中通过 el 指定模板元素（同时也是挂载元素） 框架对比Vue 和 React 的共同点使用 Virtual DOM提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库 Vue 的优势在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。React 由于 发生变化时会重新渲染整个组件树，所以需要做一些额外的优化工作(PureComponent shouldComponentUpdate Immutable Reselect) vue 的 template 模板就是 HTML 写法，比起 jsx 更容易编写和理解 vue 在每个单文件组件中可以访问自己独立的 css module，在 style 标签里添加一个属性 scoped，不会污染全局 vue 提供大量的指令来简化开发中的重复劳动如：v-for 可以构建循环，在 React 中要自己写（使用 map 构建） Vue 设置样式的默认方法是单文件组件里类似 style 的标签 Vue 的劣势生态比不上 React 在原生开发中，Weex 还没有 React Native 成熟 Vue 与 Angular1在 API 与设计两方面上 Vue.js 都比 AngularJS 简单得多 Vue.js 是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是在任何时候都必须遵循 AngularJS 制定的规则，这让 Vue 能适用于各种项目。 AngularJS 使用双向绑定，Vue 在不同组件间强制使用单向数据流。这使应用中的数据流更加清晰易懂。 在 Vue 中指令和组件分得更清晰。指令只封装 DOM 操作，而组件代表一个自给自足的独立单元——有自己的视图和数据逻辑。在 AngularJS 中两者有不少相混的地方。 Vue 有更好的性能，并且非常非常容易优化，因为它不使用脏检查。 Vue 与 Angular2Vue 和 TS 的整合可能不如 Angular 那么深入在中小型规模的项目中，引入 TS 可能并不会带来太多明显的优势。在这些情况下，用 Vue 会是更好的选择，因为在不用 TS 的情况下使用 Angular 会很有挑战性。 参考资料Vue 文档 : https://cn.vuejs.org/v2/guide/]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Promise 简介]]></title>
      <url>http://ldqblog.me/2017/05/28/Promise-%E7%AE%80%E4%BB%8B/</url>
      <!-- <content type="html"><![CDATA[<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。</p>
<p> 简单点说就是处理异步请求。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><pre><code>
Promise.all(iterable)
Promise.prototype.catch(onRejected)
Promise.prototype.then(onFulfilled, onRejected)
Promise.race(iterable)
Promise.reject(reason)
Promise.resolve(value)
</code></pre><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>Promise.length<br>长度属性，其值总是为 1 (构造器参数的数目).</p>
<p>Promise.prototype<br>表示 Promise 构造器的原型.</p>
<h2 id="Promise-有几种状态"><a href="#Promise-有几种状态" class="headerlink" title="Promise 有几种状态"></a>Promise 有几种状态</h2><ul>
<li>pending: 初始状态</li>
<li>fulfilled: 成功</li>
<li>rejected: 失败</li>
</ul>
<p>pending 状态的 Promise 对象可能触发 fulfilled 状态并传递一个值给相应的状态处理方法，<br>也可能触发失败状态（rejected）并传递失败信息。<br>当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用<br>（then 方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。<br>当 Promise 状态为 fulfilled 时，调用 then 的 onfulfilled 方法，<br>当 Promise 状态为 rejected 时，调用 then 的 onrejected 方法，<br>所以在异步操作的完成和绑定处理方法之间不存在竞争）。</p>
<p>then<br>能处理成功和失败</p>
<p>catch<br>处理失败</p>
<p>Promise.all(iterable)<br>Promise.all 接收一个 Promise 对象组成的数组作为参数，<br>当这个数组所有的 Promise 对象状态都变成 resolved 或者 rejected 的时候，<br>它才会去调用 then 方法。</p>
<pre><code>
var url = &#39;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10&#39;;
var url1 = &#39;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-03-26/2017-06-10&#39;;

function renderAll() {
    return Promise.all([getJSON(url), getJSON(url1)])
}

renderAll().then(function(value) {
    console.log(value)  //[{…}, {…}]
})

function getJSON(url) {
    return new Promise(function(resolve, reject) {
        var XHR = new XMLHttpRequest();
        XHR.open(&#39;GET&#39;, url, true);
        XHR.send();

        XHR.onload = () =&gt; {
            resolve(JSON.parse(XHR.responseText))
        }

        XHR.error = () =&gt; {
            reject()
        }
        &lt;!--XHR.onreadystatechange = function() {
            if (XHR.readyState === 4) {
                if (XHR.status === 200) {
                    try {
                        var response = JSON.parse(XHR.responseText);
                        resolve(response);
                    } catch (e) {
                        reject(e);
                    }
                } else {
                    reject(new Error(XHR.statusText));
                }
            }
        }--&gt;
    })
}
</code></pre><p>Promise.race(iterable)</p>
<p>与 Promise.all 相似的是，Promise.race 都是以一个 Promise 对象组成的数组作为参数，<br>不同的是，只要当数组中的其中一个 Promsie 状态变成 resolved 或者 rejected 时，<br>就可以调用. then 方法了。而传递给 then 方法的值也会有所不同，</p>
<pre><code>

function renderRace() {
    return Promise.race([getJSON(url), getJSON(url1)])
}

renderRace().then(function(value) {
    console.log(value)  //{ret: 0, items: {…}, serverTime: 1507396689646}
})




Promise.prototype.catch(onRejected)

Promise.prototype.then(onFulfilled, onRejected)




Promise.reject(reason)


Promise.reject(&quot;Testing static reject&quot;)
       .then(function(reason) {
            // 未被调用
        }, function(reason) {
            console.log(reason)  // &quot;测试静态拒绝&quot;
        })


Promise.reject(new Error(&quot;fail&quot;))
       .then(function(error) {
            // 未被调用
        }, function(error) {
            console.log(error)  // 堆栈跟踪
        })



Promise.resolve(value)


//thenable
Promise.resolve({
    then: (resolve, reject) =&gt; {
        resolve()
    }
}).then( res =&gt; {
    console.log(res)
})


Promise.resolve(&quot;Success&quot;)
       .then(function(value) {
            console.log(value) // &quot;Success&quot;
        }, function(value) {
            // 不会被调用
        })



// 对一个数组进行 resolve

var p = Promise.resolve([1,2,3])

p.then(function(v) {
  console.log(v[0]) // 1
})


//Resolve 另一个 promise 对象

var original = Promise.resolve(true)
var cast = Promise.resolve(original)
cast.then(function(v) {
  console.log(v) // true
})
</code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>
const fs = require(&#39;fs&#39;)
const markdown = require(&#39;markdown&#39;).markdown



readFile(markdown)
        .then( mdStr =&gt; {
            return markdown.toHTML(mdStr)
        })
        .then( html =&gt; {
            writeFile(&#39;b.html&#39;, html)
        }).catch( err =&gt; {
            console.log(err)
        })



const readFile = url =&gt; {
    const promise = new Promise(( resolve, reject ) =&gt; {
        fs.readFile(url, &#39;utf-8&#39;, (err, str) =&gt; {
            if (err) {
                reject(new Error(&#39;readFile error&#39;))
            } else {
                resolve(str)
            }
        })
    })
    return promise
}


const writeFile = (url, data ) =&gt; {
    const promise = new Promise((resolve, reject ) =&gt; {
        fs.writeFile( url, data, ( err, str) =&gt; {
            if(err) {
                reject(new Error(&#39;writeFile error&#39;))
            } else {
                resolve()
            }
        })
    })

    return promise
}
</code></pre>]]></content> -->
      <content type="html"><![CDATA[PromisePromise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。 简单点说就是处理异步请求。 API Promise.all(iterable) Promise.prototype.catch(onRejected) Promise.prototype.then(onFulfilled, onRejected) Promise.race(iterable) Promise.reject(reason) Promise.resolve(value) 属性Promise.length长度属性，其值总是为 1 (构造器参数的数目). Promise.prototype表示 Promise 构造器的原型. Promise 有几种状态 pending: 初始状态 fulfilled: 成功 rejected: 失败 pending 状态的 Promise 对象可能触发 fulfilled 状态并传递一个值给相应的状态处理方法，也可能触发失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then 方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当 Promise 状态为 fulfilled 时，调用 then 的 onfulfilled 方法，当 Promise 状态为 rejected 时，调用 then 的 onrejected 方法，所以在异步操作的完成和绑定处理方法之间不存在竞争）。 then能处理成功和失败 catch处理失败 Promise.all(iterable)Promise.all 接收一个 Promise 对象组成的数组作为参数，当这个数组所有的 Promise 对象状态都变成 resolved 或者 rejected 的时候，它才会去调用 then 方法。 var url = &#39;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-02-26/2017-06-10&#39;; var url1 = &#39;https://hq.tigerbrokers.com/fundamental/finance_calendar/getType/2017-03-26/2017-06-10&#39;; function renderAll() { return Promise.all([getJSON(url), getJSON(url1)]) } renderAll().then(function(value) { console.log(value) //[{…}, {…}] }) function getJSON(url) { return new Promise(function(resolve, reject) { var XHR = new XMLHttpRequest(); XHR.open(&#39;GET&#39;, url, true); XHR.send(); XHR.onload = () =&gt; { resolve(JSON.parse(XHR.responseText)) } XHR.error = () =&gt; { reject() } &lt;!--XHR.onreadystatechange = function() { if (XHR.readyState === 4) { if (XHR.status === 200) { try { var response = JSON.parse(XHR.responseText); resolve(response); } catch (e) { reject(e); } } else { reject(new Error(XHR.statusText)); } } }--&gt; }) } Promise.race(iterable) 与 Promise.all 相似的是，Promise.race 都是以一个 Promise 对象组成的数组作为参数，不同的是，只要当数组中的其中一个 Promsie 状态变成 resolved 或者 rejected 时，就可以调用. then 方法了。而传递给 then 方法的值也会有所不同， function renderRace() { return Promise.race([getJSON(url), getJSON(url1)]) } renderRace().then(function(value) { console.log(value) //{ret: 0, items: {…}, serverTime: 1507396689646} }) Promise.prototype.catch(onRejected) Promise.prototype.then(onFulfilled, onRejected) Promise.reject(reason) Promise.reject(&quot;Testing static reject&quot;) .then(function(reason) { // 未被调用 }, function(reason) { console.log(reason) // &quot;测试静态拒绝&quot; }) Promise.reject(new Error(&quot;fail&quot;)) .then(function(error) { // 未被调用 }, function(error) { console.log(error) // 堆栈跟踪 }) Promise.resolve(value) //thenable Promise.resolve({ then: (resolve, reject) =&gt; { resolve() } }).then( res =&gt; { console.log(res) }) Promise.resolve(&quot;Success&quot;) .then(function(value) { console.log(value) // &quot;Success&quot; }, function(value) { // 不会被调用 }) // 对一个数组进行 resolve var p = Promise.resolve([1,2,3]) p.then(function(v) { console.log(v[0]) // 1 }) //Resolve 另一个 promise 对象 var original = Promise.resolve(true) var cast = Promise.resolve(original) cast.then(function(v) { console.log(v) // true }) 例子 const fs = require(&#39;fs&#39;) const markdown = require(&#39;markdown&#39;).markdown readFile(markdown) .then( mdStr =&gt; { return markdown.toHTML(mdStr) }) .then( html =&gt; { writeFile(&#39;b.html&#39;, html) }).catch( err =&gt; { console.log(err) }) const readFile = url =&gt; { const promise = new Promise(( resolve, reject ) =&gt; { fs.readFile(url, &#39;utf-8&#39;, (err, str) =&gt; { if (err) { reject(new Error(&#39;readFile error&#39;)) } else { resolve(str) } }) }) return promise } const writeFile = (url, data ) =&gt; { const promise = new Promise((resolve, reject ) =&gt; { fs.writeFile( url, data, ( err, str) =&gt; { if(err) { reject(new Error(&#39;writeFile error&#39;)) } else { resolve() } }) }) return promise }]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[test description]]></title>
      <url>http://ldqblog.me/2017/02/02/test-description/</url>
      <!-- <content type="html"><![CDATA[<ul>
<li>在 scaffolds/post.md 文件中添加 description</li>
</ul>
<pre><code>$(window).load(function(){
 $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;);
   prettyPrint();
 })
</code></pre>]]></content> -->
      <content type="html"><![CDATA[在 scaffolds/post.md 文件中添加 description $(window).load(function(){ $(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;); prettyPrint(); })]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://ldqblog.me/2017/01/17/hello-world/</url>
      <!-- <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content> -->
      <content type="html"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[photoTest]]></title>
      <url>http://ldqblog.me/2017/01/13/photoTest/</url>
      <!-- <content type="html"><![CDATA[<ul>
<li>测试图片功能</li>
</ul>
<p><img src="http://otyr3ojiw.bkt.clouddn.com/blog/170801/GgD6FJfKF9.jpeg?imageslim" alt="photos-0.jpg"><br><img src="http://otyr3ojiw.bkt.clouddn.com/blog/170801/7L37AEEbdj.jpg?imageslim" alt="photos-1.jpg"></p>
]]></content> -->
      <content type="html"><![CDATA[测试图片功能]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[第一篇 Hexo 文章]]></title>
      <url>http://ldqblog.me/2016/11/05/%E7%AC%AC%E4%B8%80%E7%AF%87Hexo%E6%96%87%E7%AB%A0/</url>
      <!-- <content type="html"><![CDATA[<ul>
<li>第一次写 Hexo 博客</li>
</ul>
]]></content> -->
      <content type="html"><![CDATA[第一次写 Hexo 博客]]></content>
    </entry>
    
  
  
</search>
